// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRAININFO_MNNTRAIN_H_
#define FLATBUFFERS_GENERATED_TRAININFO_MNNTRAIN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace MNNTrain {

struct OpInfo;
struct OpInfoBuilder;

struct KV;
struct KVBuilder;

struct TrainInfo;
struct TrainInfoBuilder;

struct OpInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OpInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8
  };
  const ::flatbuffers::String *op() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OP);
  }
  const ::flatbuffers::String *weight() const {
    return GetPointer<const ::flatbuffers::String *>(VT_WEIGHT);
  }
  const ::flatbuffers::String *bias() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BIAS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyString(op()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyString(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyString(bias()) &&
           verifier.EndTable();
  }
};

struct OpInfoBuilder {
  typedef OpInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(::flatbuffers::Offset<::flatbuffers::String> op) {
    fbb_.AddOffset(OpInfo::VT_OP, op);
  }
  void add_weight(::flatbuffers::Offset<::flatbuffers::String> weight) {
    fbb_.AddOffset(OpInfo::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<::flatbuffers::String> bias) {
    fbb_.AddOffset(OpInfo::VT_BIAS, bias);
  }
  explicit OpInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OpInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OpInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OpInfo> CreateOpInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> op = 0,
    ::flatbuffers::Offset<::flatbuffers::String> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::String> bias = 0) {
  OpInfoBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_op(op);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<OpInfo> CreateOpInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *op = nullptr,
    const char *weight = nullptr,
    const char *bias = nullptr) {
  auto op__ = op ? _fbb.CreateString(op) : 0;
  auto weight__ = weight ? _fbb.CreateString(weight) : 0;
  auto bias__ = bias ? _fbb.CreateString(bias) : 0;
  return MNNTrain::CreateOpInfo(
      _fbb,
      op__,
      weight__,
      bias__);
}

struct KV FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KVBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KVBuilder {
  typedef KV Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KV::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(KV::VT_VALUE, value);
  }
  explicit KVBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KV> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KV>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KV> CreateKV(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  KVBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KV> CreateKVDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return MNNTrain::CreateKV(
      _fbb,
      key__,
      value__);
}

struct TrainInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TrainInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRAINABLES = 4,
    VT_CONVOLUTIONS = 6,
    VT_BATCHNORMAL = 8
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>> *trainables() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>> *>(VT_TRAINABLES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::OpInfo>> *convolutions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::OpInfo>> *>(VT_CONVOLUTIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>> *batchnormal() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>> *>(VT_BATCHNORMAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRAINABLES) &&
           verifier.VerifyVector(trainables()) &&
           verifier.VerifyVectorOfTables(trainables()) &&
           VerifyOffset(verifier, VT_CONVOLUTIONS) &&
           verifier.VerifyVector(convolutions()) &&
           verifier.VerifyVectorOfTables(convolutions()) &&
           VerifyOffset(verifier, VT_BATCHNORMAL) &&
           verifier.VerifyVector(batchnormal()) &&
           verifier.VerifyVectorOfTables(batchnormal()) &&
           verifier.EndTable();
  }
};

struct TrainInfoBuilder {
  typedef TrainInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_trainables(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>>> trainables) {
    fbb_.AddOffset(TrainInfo::VT_TRAINABLES, trainables);
  }
  void add_convolutions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::OpInfo>>> convolutions) {
    fbb_.AddOffset(TrainInfo::VT_CONVOLUTIONS, convolutions);
  }
  void add_batchnormal(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>>> batchnormal) {
    fbb_.AddOffset(TrainInfo::VT_BATCHNORMAL, batchnormal);
  }
  explicit TrainInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TrainInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TrainInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TrainInfo> CreateTrainInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>>> trainables = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::OpInfo>>> convolutions = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNNTrain::KV>>> batchnormal = 0) {
  TrainInfoBuilder builder_(_fbb);
  builder_.add_batchnormal(batchnormal);
  builder_.add_convolutions(convolutions);
  builder_.add_trainables(trainables);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TrainInfo> CreateTrainInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<MNNTrain::KV>> *trainables = nullptr,
    const std::vector<::flatbuffers::Offset<MNNTrain::OpInfo>> *convolutions = nullptr,
    const std::vector<::flatbuffers::Offset<MNNTrain::KV>> *batchnormal = nullptr) {
  auto trainables__ = trainables ? _fbb.CreateVector<::flatbuffers::Offset<MNNTrain::KV>>(*trainables) : 0;
  auto convolutions__ = convolutions ? _fbb.CreateVector<::flatbuffers::Offset<MNNTrain::OpInfo>>(*convolutions) : 0;
  auto batchnormal__ = batchnormal ? _fbb.CreateVector<::flatbuffers::Offset<MNNTrain::KV>>(*batchnormal) : 0;
  return MNNTrain::CreateTrainInfo(
      _fbb,
      trainables__,
      convolutions__,
      batchnormal__);
}

}  // namespace MNNTrain

#endif  // FLATBUFFERS_GENERATED_TRAININFO_MNNTRAIN_H_
