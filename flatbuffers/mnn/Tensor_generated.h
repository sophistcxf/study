// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSOR_MNN_H_
#define FLATBUFFERS_GENERATED_TENSOR_MNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Type_generated.h"

namespace MNN {

struct Blob;
struct BlobBuilder;

struct ListValue;
struct ListValueBuilder;

struct Attribute;
struct AttributeBuilder;

struct NamedAttrList;
struct NamedAttrListBuilder;

enum MNN_DATA_FORMAT : int8_t {
  MNN_DATA_FORMAT_NCHW = 0,
  MNN_DATA_FORMAT_NHWC = 1,
  MNN_DATA_FORMAT_NC4HW4 = 2,
  MNN_DATA_FORMAT_NHWC4 = 3,
  MNN_DATA_FORMAT_UNKNOWN = 4,
  MNN_DATA_FORMAT_MIN = MNN_DATA_FORMAT_NCHW,
  MNN_DATA_FORMAT_MAX = MNN_DATA_FORMAT_UNKNOWN
};

inline const MNN_DATA_FORMAT (&EnumValuesMNN_DATA_FORMAT())[5] {
  static const MNN_DATA_FORMAT values[] = {
    MNN_DATA_FORMAT_NCHW,
    MNN_DATA_FORMAT_NHWC,
    MNN_DATA_FORMAT_NC4HW4,
    MNN_DATA_FORMAT_NHWC4,
    MNN_DATA_FORMAT_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesMNN_DATA_FORMAT() {
  static const char * const names[6] = {
    "NCHW",
    "NHWC",
    "NC4HW4",
    "NHWC4",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameMNN_DATA_FORMAT(MNN_DATA_FORMAT e) {
  if (::flatbuffers::IsOutRange(e, MNN_DATA_FORMAT_NCHW, MNN_DATA_FORMAT_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMNN_DATA_FORMAT()[index];
}

struct Blob FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BlobBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DATAFORMAT = 6,
    VT_DATATYPE = 8,
    VT_UINT8S = 10,
    VT_INT8S = 12,
    VT_INT32S = 14,
    VT_INT64S = 16,
    VT_FLOAT32S = 18,
    VT_STRINGS = 20,
    VT_EXTERNAL = 22
  };
  const ::flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  MNN::MNN_DATA_FORMAT dataFormat() const {
    return static_cast<MNN::MNN_DATA_FORMAT>(GetField<int8_t>(VT_DATAFORMAT, 0));
  }
  MNN::DataType dataType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DATATYPE, 1));
  }
  const ::flatbuffers::Vector<uint8_t> *uint8s() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_UINT8S);
  }
  const ::flatbuffers::Vector<int8_t> *int8s() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_INT8S);
  }
  const ::flatbuffers::Vector<int32_t> *int32s() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INT32S);
  }
  const ::flatbuffers::Vector<int64_t> *int64s() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_INT64S);
  }
  const ::flatbuffers::Vector<float> *float32s() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_FLOAT32S);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *strings() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_STRINGS);
  }
  const ::flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, VT_DATAFORMAT, 1) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE, 4) &&
           VerifyOffset(verifier, VT_UINT8S) &&
           verifier.VerifyVector(uint8s()) &&
           VerifyOffset(verifier, VT_INT8S) &&
           verifier.VerifyVector(int8s()) &&
           VerifyOffset(verifier, VT_INT32S) &&
           verifier.VerifyVector(int32s()) &&
           VerifyOffset(verifier, VT_INT64S) &&
           verifier.VerifyVector(int64s()) &&
           VerifyOffset(verifier, VT_FLOAT32S) &&
           verifier.VerifyVector(float32s()) &&
           VerifyOffset(verifier, VT_STRINGS) &&
           verifier.VerifyVector(strings()) &&
           verifier.VerifyVectorOfStrings(strings()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
};

struct BlobBuilder {
  typedef Blob Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Blob::VT_DIMS, dims);
  }
  void add_dataFormat(MNN::MNN_DATA_FORMAT dataFormat) {
    fbb_.AddElement<int8_t>(Blob::VT_DATAFORMAT, static_cast<int8_t>(dataFormat), 0);
  }
  void add_dataType(MNN::DataType dataType) {
    fbb_.AddElement<int32_t>(Blob::VT_DATATYPE, static_cast<int32_t>(dataType), 1);
  }
  void add_uint8s(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> uint8s) {
    fbb_.AddOffset(Blob::VT_UINT8S, uint8s);
  }
  void add_int8s(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> int8s) {
    fbb_.AddOffset(Blob::VT_INT8S, int8s);
  }
  void add_int32s(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> int32s) {
    fbb_.AddOffset(Blob::VT_INT32S, int32s);
  }
  void add_int64s(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> int64s) {
    fbb_.AddOffset(Blob::VT_INT64S, int64s);
  }
  void add_float32s(::flatbuffers::Offset<::flatbuffers::Vector<float>> float32s) {
    fbb_.AddOffset(Blob::VT_FLOAT32S, float32s);
  }
  void add_strings(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings) {
    fbb_.AddOffset(Blob::VT_STRINGS, strings);
  }
  void add_external(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Blob::VT_EXTERNAL, external);
  }
  explicit BlobBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Blob> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Blob>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Blob> CreateBlob(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims = 0,
    MNN::MNN_DATA_FORMAT dataFormat = MNN::MNN_DATA_FORMAT_NCHW,
    MNN::DataType dataType = MNN::DataType_DT_FLOAT,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> uint8s = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> int8s = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> int32s = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> int64s = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> float32s = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> strings = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external = 0) {
  BlobBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_strings(strings);
  builder_.add_float32s(float32s);
  builder_.add_int64s(int64s);
  builder_.add_int32s(int32s);
  builder_.add_int8s(int8s);
  builder_.add_uint8s(uint8s);
  builder_.add_dataType(dataType);
  builder_.add_dims(dims);
  builder_.add_dataFormat(dataFormat);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Blob> CreateBlobDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    MNN::MNN_DATA_FORMAT dataFormat = MNN::MNN_DATA_FORMAT_NCHW,
    MNN::DataType dataType = MNN::DataType_DT_FLOAT,
    const std::vector<uint8_t> *uint8s = nullptr,
    const std::vector<int8_t> *int8s = nullptr,
    const std::vector<int32_t> *int32s = nullptr,
    const std::vector<int64_t> *int64s = nullptr,
    const std::vector<float> *float32s = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *strings = nullptr,
    const std::vector<int64_t> *external = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  auto uint8s__ = uint8s ? _fbb.CreateVector<uint8_t>(*uint8s) : 0;
  auto int8s__ = int8s ? _fbb.CreateVector<int8_t>(*int8s) : 0;
  auto int32s__ = int32s ? _fbb.CreateVector<int32_t>(*int32s) : 0;
  auto int64s__ = int64s ? _fbb.CreateVector<int64_t>(*int64s) : 0;
  auto float32s__ = float32s ? _fbb.CreateVector<float>(*float32s) : 0;
  auto strings__ = strings ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*strings) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return MNN::CreateBlob(
      _fbb,
      dims__,
      dataFormat,
      dataType,
      uint8s__,
      int8s__,
      int32s__,
      int64s__,
      float32s__,
      strings__,
      external__);
}

struct ListValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ListValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_S = 4,
    VT_I = 6,
    VT_F = 8,
    VT_B = 10,
    VT_TYPE = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *s() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_S);
  }
  const ::flatbuffers::Vector<int32_t> *i() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_I);
  }
  const ::flatbuffers::Vector<float> *f() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_F);
  }
  const ::flatbuffers::Vector<uint8_t> *b() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_B);
  }
  const ::flatbuffers::Vector<int32_t> *type() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_TYPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyVector(s()) &&
           verifier.VerifyVectorOfStrings(s()) &&
           VerifyOffset(verifier, VT_I) &&
           verifier.VerifyVector(i()) &&
           VerifyOffset(verifier, VT_F) &&
           verifier.VerifyVector(f()) &&
           VerifyOffset(verifier, VT_B) &&
           verifier.VerifyVector(b()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyVector(type()) &&
           verifier.EndTable();
  }
};

struct ListValueBuilder {
  typedef ListValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_s(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> s) {
    fbb_.AddOffset(ListValue::VT_S, s);
  }
  void add_i(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> i) {
    fbb_.AddOffset(ListValue::VT_I, i);
  }
  void add_f(::flatbuffers::Offset<::flatbuffers::Vector<float>> f) {
    fbb_.AddOffset(ListValue::VT_F, f);
  }
  void add_b(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b) {
    fbb_.AddOffset(ListValue::VT_B, b);
  }
  void add_type(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> type) {
    fbb_.AddOffset(ListValue::VT_TYPE, type);
  }
  explicit ListValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ListValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ListValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ListValue> CreateListValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> s = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> i = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> f = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> b = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> type = 0) {
  ListValueBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_b(b);
  builder_.add_f(f);
  builder_.add_i(i);
  builder_.add_s(s);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ListValue> CreateListValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *s = nullptr,
    const std::vector<int32_t> *i = nullptr,
    const std::vector<float> *f = nullptr,
    const std::vector<uint8_t> *b = nullptr,
    const std::vector<int32_t> *type = nullptr) {
  auto s__ = s ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*s) : 0;
  auto i__ = i ? _fbb.CreateVector<int32_t>(*i) : 0;
  auto f__ = f ? _fbb.CreateVector<float>(*f) : 0;
  auto b__ = b ? _fbb.CreateVector<uint8_t>(*b) : 0;
  auto type__ = type ? _fbb.CreateVector<int32_t>(*type) : 0;
  return MNN::CreateListValue(
      _fbb,
      s__,
      i__,
      f__,
      b__,
      type__);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_S = 4,
    VT_I = 6,
    VT_B = 8,
    VT_KEY = 10,
    VT_TYPE = 12,
    VT_F = 14,
    VT_TENSOR = 16,
    VT_LIST = 18,
    VT_FUNC = 20
  };
  const ::flatbuffers::String *s() const {
    return GetPointer<const ::flatbuffers::String *>(VT_S);
  }
  int32_t i() const {
    return GetField<int32_t>(VT_I, 0);
  }
  bool b() const {
    return GetField<uint8_t>(VT_B, 0) != 0;
  }
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const Attribute * const o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *_key) const {
    return strcmp(key()->c_str(), _key);
  }
  template<typename StringType>
  int KeyCompareWithValue(const StringType& _key) const {
    if (key()->c_str() < _key) return -1;
    if (_key < key()->c_str()) return 1;
    return 0;
  }
  MNN::DataType type() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TYPE, 0));
  }
  float f() const {
    return GetField<float>(VT_F, 0.0f);
  }
  const MNN::Blob *tensor() const {
    return GetPointer<const MNN::Blob *>(VT_TENSOR);
  }
  const MNN::ListValue *list() const {
    return GetPointer<const MNN::ListValue *>(VT_LIST);
  }
  const MNN::NamedAttrList *func() const {
    return GetPointer<const MNN::NamedAttrList *>(VT_FUNC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_S) &&
           verifier.VerifyString(s()) &&
           VerifyField<int32_t>(verifier, VT_I, 4) &&
           VerifyField<uint8_t>(verifier, VT_B, 1) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<float>(verifier, VT_F, 4) &&
           VerifyOffset(verifier, VT_TENSOR) &&
           verifier.VerifyTable(tensor()) &&
           VerifyOffset(verifier, VT_LIST) &&
           verifier.VerifyTable(list()) &&
           VerifyOffset(verifier, VT_FUNC) &&
           verifier.VerifyTable(func()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_s(::flatbuffers::Offset<::flatbuffers::String> s) {
    fbb_.AddOffset(Attribute::VT_S, s);
  }
  void add_i(int32_t i) {
    fbb_.AddElement<int32_t>(Attribute::VT_I, i, 0);
  }
  void add_b(bool b) {
    fbb_.AddElement<uint8_t>(Attribute::VT_B, static_cast<uint8_t>(b), 0);
  }
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(Attribute::VT_KEY, key);
  }
  void add_type(MNN::DataType type) {
    fbb_.AddElement<int32_t>(Attribute::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_f(float f) {
    fbb_.AddElement<float>(Attribute::VT_F, f, 0.0f);
  }
  void add_tensor(::flatbuffers::Offset<MNN::Blob> tensor) {
    fbb_.AddOffset(Attribute::VT_TENSOR, tensor);
  }
  void add_list(::flatbuffers::Offset<MNN::ListValue> list) {
    fbb_.AddOffset(Attribute::VT_LIST, list);
  }
  void add_func(::flatbuffers::Offset<MNN::NamedAttrList> func) {
    fbb_.AddOffset(Attribute::VT_FUNC, func);
  }
  explicit AttributeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Attribute>(end);
    fbb_.Required(o, Attribute::VT_KEY);
    return o;
  }
};

inline ::flatbuffers::Offset<Attribute> CreateAttribute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> s = 0,
    int32_t i = 0,
    bool b = false,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    MNN::DataType type = MNN::DataType_DT_INVALID,
    float f = 0.0f,
    ::flatbuffers::Offset<MNN::Blob> tensor = 0,
    ::flatbuffers::Offset<MNN::ListValue> list = 0,
    ::flatbuffers::Offset<MNN::NamedAttrList> func = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_func(func);
  builder_.add_list(list);
  builder_.add_tensor(tensor);
  builder_.add_f(f);
  builder_.add_type(type);
  builder_.add_key(key);
  builder_.add_i(i);
  builder_.add_s(s);
  builder_.add_b(b);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Attribute> CreateAttributeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *s = nullptr,
    int32_t i = 0,
    bool b = false,
    const char *key = nullptr,
    MNN::DataType type = MNN::DataType_DT_INVALID,
    float f = 0.0f,
    ::flatbuffers::Offset<MNN::Blob> tensor = 0,
    ::flatbuffers::Offset<MNN::ListValue> list = 0,
    ::flatbuffers::Offset<MNN::NamedAttrList> func = 0) {
  auto s__ = s ? _fbb.CreateString(s) : 0;
  auto key__ = key ? _fbb.CreateString(key) : 0;
  return MNN::CreateAttribute(
      _fbb,
      s__,
      i,
      b,
      key__,
      type,
      f,
      tensor,
      list,
      func);
}

struct NamedAttrList FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NamedAttrListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ATTR = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *attr() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *>(VT_ATTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
};

struct NamedAttrListBuilder {
  typedef NamedAttrList Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(NamedAttrList::VT_NAME, name);
  }
  void add_attr(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> attr) {
    fbb_.AddOffset(NamedAttrList::VT_ATTR, attr);
  }
  explicit NamedAttrListBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NamedAttrList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NamedAttrList>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NamedAttrList> CreateNamedAttrList(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> attr = 0) {
  NamedAttrListBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<NamedAttrList> CreateNamedAttrListDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    std::vector<::flatbuffers::Offset<MNN::Attribute>> *attr = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<MNN::Attribute>(attr) : 0;
  return MNN::CreateNamedAttrList(
      _fbb,
      name__,
      attr__);
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_TENSOR_MNN_H_
