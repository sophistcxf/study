// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MNN_MNN_H_
#define FLATBUFFERS_GENERATED_MNN_MNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "CaffeOp_generated.h"
#include "ExtraInfo_generated.h"
#include "TFQuantizeOp_generated.h"
#include "TensorflowOp_generated.h"
#include "UserDefine_generated.h"

namespace MNN {

struct Plugin;
struct PluginBuilder;

struct Extra;
struct ExtraBuilder;

struct StringVec;
struct StringVecBuilder;

struct AttentionParam;
struct AttentionParamBuilder;

struct FmhaV2Param;
struct FmhaV2ParamBuilder;

struct FmhcaParam;
struct FmhcaParamBuilder;

struct StftParam;
struct StftParamBuilder;

struct WhileParam;
struct WhileParamBuilder;

struct IfParam;
struct IfParamBuilder;

struct RegionCommand;
struct RegionCommandBuilder;

struct LoopParam;
struct LoopParamBuilder;

struct Op;
struct OpBuilder;

struct View;
struct ViewBuilder;

struct Region;
struct RegionBuilder;

struct TensorDescribe;
struct TensorDescribeBuilder;

struct SubGraphProto;
struct SubGraphProtoBuilder;

struct TensorQuantInfo;
struct TensorQuantInfoBuilder;

struct Net;
struct NetBuilder;

enum OpType : int32_t {
  OpType_AbsVal = 0,
  OpType_QuantizedAdd = 1,
  OpType_ArgMax = 2,
  OpType_AsString = 3,
  OpType_InstanceNorm = 4,
  OpType_BatchToSpaceND = 5,
  OpType_Copy = 6,
  OpType_BinaryOp = 7,
  OpType_Bnll = 8,
  OpType_Cast = 9,
  OpType_Concat = 10,
  OpType_Const = 11,
  OpType_Convolution = 12,
  OpType_ConvolutionDepthwise = 13,
  OpType_Crop = 14,
  OpType_CropAndResize = 15,
  OpType_ImageProcess = 16,
  OpType_Deconvolution = 17,
  OpType_DeconvolutionDepthwise = 18,
  OpType_Dequantize = 19,
  OpType_DetectionOutput = 20,
  OpType_Dropout = 21,
  OpType_Eltwise = 22,
  OpType_ELU = 23,
  OpType_Unique = 24,
  OpType_Exp = 25,
  OpType_ExpandDims = 26,
  OpType_Fill = 27,
  OpType_Flatten = 28,
  OpType_Im2Col = 29,
  OpType_Gather = 30,
  OpType_GatherV2 = 31,
  OpType_Im2Seq = 32,
  OpType_InnerProduct = 33,
  OpType_Input = 34,
  OpType_Interp = 35,
  OpType_Log = 36,
  OpType_LRN = 37,
  OpType_LSTM = 38,
  OpType_MatMul = 39,
  OpType_MVN = 40,
  OpType_NonMaxSuppression = 41,
  OpType_NonMaxSuppressionV2 = 42,
  OpType_Normalize = 43,
  OpType_Pack = 44,
  OpType_Padding = 45,
  OpType_Permute = 46,
  OpType_Pooling = 47,
  OpType_Power = 48,
  OpType_PReLU = 49,
  OpType_PriorBox = 50,
  OpType_Proposal = 51,
  OpType_QuantizedAvgPool = 52,
  OpType_QuantizedBiasAdd = 53,
  OpType_QuantizedConcat = 54,
  OpType_QuantizedDepthwiseConv2D = 55,
  OpType_QuantizedLogistic = 56,
  OpType_RasterAndInterpolate = 57,
  OpType_QuantizedMaxPool = 58,
  OpType_Texture = 59,
  OpType_RasterDiff = 60,
  OpType_QuantizedReshape = 61,
  OpType_QuantizedSoftmax = 62,
  OpType_QuantizeMaxMin = 63,
  OpType_QuantizeV2 = 64,
  OpType_Range = 65,
  OpType_Rank = 66,
  OpType_ReduceJoin = 67,
  OpType_Reduction = 68,
  OpType_ReLU = 69,
  OpType_ReLU6 = 70,
  OpType_RequantizationRange = 71,
  OpType_Requantize = 72,
  OpType_Reshape = 73,
  OpType_Resize = 74,
  OpType_RNN = 75,
  OpType_ROIPooling = 76,
  OpType_Scale = 77,
  OpType_Selu = 78,
  OpType_Seq2Out = 79,
  OpType_Shape = 80,
  OpType_Sigmoid = 81,
  OpType_Size = 82,
  OpType_Slice = 83,
  OpType_SliceTf = 84,
  OpType_Softmax = 85,
  OpType_SpaceToBatchND = 86,
  OpType_SpatialProduct = 87,
  OpType_Col2Im = 88,
  OpType_Segment = 89,
  OpType_Squeeze = 90,
  OpType_StridedSlice = 91,
  OpType_CastLike = 92,
  OpType_StringSplit = 93,
  OpType_StringToNumber = 94,
  OpType_TanH = 95,
  OpType_TfQuantizedConv2D = 96,
  OpType_Threshold = 97,
  OpType_Tile = 98,
  OpType_TopKV2 = 99,
  OpType_Transpose = 100,
  OpType_UnaryOp = 101,
  OpType_Unpack = 102,
  OpType_Where = 103,
  OpType_Moments = 104,
  OpType_RNNSequenceGRU = 105,
  OpType_BatchMatMul = 106,
  OpType_Unsqueeze = 107,
  OpType_CosineSimilarity = 108,
  OpType_DepthToSpace = 109,
  OpType_SpaceToDepth = 110,
  OpType_ReverseSequence = 111,
  OpType_Pooling3D = 112,
  OpType_Convolution3D = 113,
  OpType_MatrixBandPart = 114,
  OpType_GatherND = 115,
  OpType_DetectionPostProcess = 116,
  OpType_UnravelIndex = 117,
  OpType_ScatterNd = 118,
  OpType_OneHot = 119,
  OpType_BroadcastTo = 120,
  OpType_Dilation2D = 121,
  OpType_Interp3D = 122,
  OpType_Raster = 128,
  OpType_ConvertTensor = 129,
  OpType_ArgMin = 130,
  OpType_LinSpace = 131,
  OpType_RandomUniform = 132,
  OpType_TensorArray = 133,
  OpType_TensorArraySize = 134,
  OpType_TensorArrayRead = 135,
  OpType_TensorArrayWrite = 136,
  OpType_TensorArrayGather = 137,
  OpType_TensorArrayScatter = 138,
  OpType_TensorArraySplit = 139,
  OpType_TensorArrayConcat = 140,
  OpType_LSTMBlockCell = 141,
  OpType_Reverse = 142,
  OpType_ROIAlign = 143,
  OpType_RandomNormal = 144,
  OpType_TensorArrayInsert = 145,
  OpType_TensorArrayErase = 146,
  OpType_EyeLike = 147,
  OpType_CumSum = 148,
  OpType_Det = 149,
  OpType_CumProd = 150,
  OpType_ScatterElements = 151,
  OpType_GatherElements = 152,
  OpType_Svd = 153,
  OpType_Histogram = 154,
  OpType_DynamicQuant = 155,
  OpType_Stft = 156,
  OpType_Plugin = 256,
  OpType_Select = 257,
  OpType_ZerosLike = 258,
  OpType_Broastcast = 259,
  OpType_SetDiff1D = 260,
  OpType_ReluGrad = 261,
  OpType_Identity = 262,
  OpType_PoolGrad = 263,
  OpType_SoftmaxGrad = 264,
  OpType_Conv2DBackPropFilter = 265,
  OpType_TrainableParam = 266,
  OpType_BatchNorm = 267,
  OpType_ConvTranspose3D = 268,
  OpType_ZeroGrad = 269,
  OpType_Attention = 299,
  OpType_FmhaV2 = 300,
  OpType_Fmhca = 301,
  OpType_SeqLen2Spatial = 302,
  OpType_SplitGeLU = 303,
  OpType_GroupNorm = 304,
  OpType_Extra = 512,
  OpType_ConvInt8 = 513,
  OpType_Int8ToFloat = 514,
  OpType_DepthwiseConvInt8 = 515,
  OpType_PoolInt8 = 516,
  OpType_FloatToInt8 = 517,
  OpType_EltwiseInt8 = 518,
  OpType_While = 600,
  OpType_If = 601,
  OpType_LayerNorm = 603,
  OpType_GridSample = 604,
  OpType_MIN = OpType_AbsVal,
  OpType_MAX = OpType_GridSample
};

inline const OpType (&EnumValuesOpType())[183] {
  static const OpType values[] = {
    OpType_AbsVal,
    OpType_QuantizedAdd,
    OpType_ArgMax,
    OpType_AsString,
    OpType_InstanceNorm,
    OpType_BatchToSpaceND,
    OpType_Copy,
    OpType_BinaryOp,
    OpType_Bnll,
    OpType_Cast,
    OpType_Concat,
    OpType_Const,
    OpType_Convolution,
    OpType_ConvolutionDepthwise,
    OpType_Crop,
    OpType_CropAndResize,
    OpType_ImageProcess,
    OpType_Deconvolution,
    OpType_DeconvolutionDepthwise,
    OpType_Dequantize,
    OpType_DetectionOutput,
    OpType_Dropout,
    OpType_Eltwise,
    OpType_ELU,
    OpType_Unique,
    OpType_Exp,
    OpType_ExpandDims,
    OpType_Fill,
    OpType_Flatten,
    OpType_Im2Col,
    OpType_Gather,
    OpType_GatherV2,
    OpType_Im2Seq,
    OpType_InnerProduct,
    OpType_Input,
    OpType_Interp,
    OpType_Log,
    OpType_LRN,
    OpType_LSTM,
    OpType_MatMul,
    OpType_MVN,
    OpType_NonMaxSuppression,
    OpType_NonMaxSuppressionV2,
    OpType_Normalize,
    OpType_Pack,
    OpType_Padding,
    OpType_Permute,
    OpType_Pooling,
    OpType_Power,
    OpType_PReLU,
    OpType_PriorBox,
    OpType_Proposal,
    OpType_QuantizedAvgPool,
    OpType_QuantizedBiasAdd,
    OpType_QuantizedConcat,
    OpType_QuantizedDepthwiseConv2D,
    OpType_QuantizedLogistic,
    OpType_RasterAndInterpolate,
    OpType_QuantizedMaxPool,
    OpType_Texture,
    OpType_RasterDiff,
    OpType_QuantizedReshape,
    OpType_QuantizedSoftmax,
    OpType_QuantizeMaxMin,
    OpType_QuantizeV2,
    OpType_Range,
    OpType_Rank,
    OpType_ReduceJoin,
    OpType_Reduction,
    OpType_ReLU,
    OpType_ReLU6,
    OpType_RequantizationRange,
    OpType_Requantize,
    OpType_Reshape,
    OpType_Resize,
    OpType_RNN,
    OpType_ROIPooling,
    OpType_Scale,
    OpType_Selu,
    OpType_Seq2Out,
    OpType_Shape,
    OpType_Sigmoid,
    OpType_Size,
    OpType_Slice,
    OpType_SliceTf,
    OpType_Softmax,
    OpType_SpaceToBatchND,
    OpType_SpatialProduct,
    OpType_Col2Im,
    OpType_Segment,
    OpType_Squeeze,
    OpType_StridedSlice,
    OpType_CastLike,
    OpType_StringSplit,
    OpType_StringToNumber,
    OpType_TanH,
    OpType_TfQuantizedConv2D,
    OpType_Threshold,
    OpType_Tile,
    OpType_TopKV2,
    OpType_Transpose,
    OpType_UnaryOp,
    OpType_Unpack,
    OpType_Where,
    OpType_Moments,
    OpType_RNNSequenceGRU,
    OpType_BatchMatMul,
    OpType_Unsqueeze,
    OpType_CosineSimilarity,
    OpType_DepthToSpace,
    OpType_SpaceToDepth,
    OpType_ReverseSequence,
    OpType_Pooling3D,
    OpType_Convolution3D,
    OpType_MatrixBandPart,
    OpType_GatherND,
    OpType_DetectionPostProcess,
    OpType_UnravelIndex,
    OpType_ScatterNd,
    OpType_OneHot,
    OpType_BroadcastTo,
    OpType_Dilation2D,
    OpType_Interp3D,
    OpType_Raster,
    OpType_ConvertTensor,
    OpType_ArgMin,
    OpType_LinSpace,
    OpType_RandomUniform,
    OpType_TensorArray,
    OpType_TensorArraySize,
    OpType_TensorArrayRead,
    OpType_TensorArrayWrite,
    OpType_TensorArrayGather,
    OpType_TensorArrayScatter,
    OpType_TensorArraySplit,
    OpType_TensorArrayConcat,
    OpType_LSTMBlockCell,
    OpType_Reverse,
    OpType_ROIAlign,
    OpType_RandomNormal,
    OpType_TensorArrayInsert,
    OpType_TensorArrayErase,
    OpType_EyeLike,
    OpType_CumSum,
    OpType_Det,
    OpType_CumProd,
    OpType_ScatterElements,
    OpType_GatherElements,
    OpType_Svd,
    OpType_Histogram,
    OpType_DynamicQuant,
    OpType_Stft,
    OpType_Plugin,
    OpType_Select,
    OpType_ZerosLike,
    OpType_Broastcast,
    OpType_SetDiff1D,
    OpType_ReluGrad,
    OpType_Identity,
    OpType_PoolGrad,
    OpType_SoftmaxGrad,
    OpType_Conv2DBackPropFilter,
    OpType_TrainableParam,
    OpType_BatchNorm,
    OpType_ConvTranspose3D,
    OpType_ZeroGrad,
    OpType_Attention,
    OpType_FmhaV2,
    OpType_Fmhca,
    OpType_SeqLen2Spatial,
    OpType_SplitGeLU,
    OpType_GroupNorm,
    OpType_Extra,
    OpType_ConvInt8,
    OpType_Int8ToFloat,
    OpType_DepthwiseConvInt8,
    OpType_PoolInt8,
    OpType_FloatToInt8,
    OpType_EltwiseInt8,
    OpType_While,
    OpType_If,
    OpType_LayerNorm,
    OpType_GridSample
  };
  return values;
}

inline const char * const *EnumNamesOpType() {
  static const char * const names[606] = {
    "AbsVal",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "InstanceNorm",
    "BatchToSpaceND",
    "Copy",
    "BinaryOp",
    "Bnll",
    "Cast",
    "Concat",
    "Const",
    "Convolution",
    "ConvolutionDepthwise",
    "Crop",
    "CropAndResize",
    "ImageProcess",
    "Deconvolution",
    "DeconvolutionDepthwise",
    "Dequantize",
    "DetectionOutput",
    "Dropout",
    "Eltwise",
    "ELU",
    "Unique",
    "Exp",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Im2Col",
    "Gather",
    "GatherV2",
    "Im2Seq",
    "InnerProduct",
    "Input",
    "Interp",
    "Log",
    "LRN",
    "LSTM",
    "MatMul",
    "MVN",
    "NonMaxSuppression",
    "NonMaxSuppressionV2",
    "Normalize",
    "Pack",
    "Padding",
    "Permute",
    "Pooling",
    "Power",
    "PReLU",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedDepthwiseConv2D",
    "QuantizedLogistic",
    "RasterAndInterpolate",
    "QuantizedMaxPool",
    "Texture",
    "RasterDiff",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "Reduction",
    "ReLU",
    "ReLU6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RNN",
    "ROIPooling",
    "Scale",
    "Selu",
    "Seq2Out",
    "Shape",
    "Sigmoid",
    "Size",
    "Slice",
    "SliceTf",
    "Softmax",
    "SpaceToBatchND",
    "SpatialProduct",
    "Col2Im",
    "Segment",
    "Squeeze",
    "StridedSlice",
    "CastLike",
    "StringSplit",
    "StringToNumber",
    "TanH",
    "TfQuantizedConv2D",
    "Threshold",
    "Tile",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "Unpack",
    "Where",
    "Moments",
    "RNNSequenceGRU",
    "BatchMatMul",
    "Unsqueeze",
    "CosineSimilarity",
    "DepthToSpace",
    "SpaceToDepth",
    "ReverseSequence",
    "Pooling3D",
    "Convolution3D",
    "MatrixBandPart",
    "GatherND",
    "DetectionPostProcess",
    "UnravelIndex",
    "ScatterNd",
    "OneHot",
    "BroadcastTo",
    "Dilation2D",
    "Interp3D",
    "",
    "",
    "",
    "",
    "",
    "Raster",
    "ConvertTensor",
    "ArgMin",
    "LinSpace",
    "RandomUniform",
    "TensorArray",
    "TensorArraySize",
    "TensorArrayRead",
    "TensorArrayWrite",
    "TensorArrayGather",
    "TensorArrayScatter",
    "TensorArraySplit",
    "TensorArrayConcat",
    "LSTMBlockCell",
    "Reverse",
    "ROIAlign",
    "RandomNormal",
    "TensorArrayInsert",
    "TensorArrayErase",
    "EyeLike",
    "CumSum",
    "Det",
    "CumProd",
    "ScatterElements",
    "GatherElements",
    "Svd",
    "Histogram",
    "DynamicQuant",
    "Stft",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Plugin",
    "Select",
    "ZerosLike",
    "Broastcast",
    "SetDiff1D",
    "ReluGrad",
    "Identity",
    "PoolGrad",
    "SoftmaxGrad",
    "Conv2DBackPropFilter",
    "TrainableParam",
    "BatchNorm",
    "ConvTranspose3D",
    "ZeroGrad",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Attention",
    "FmhaV2",
    "Fmhca",
    "SeqLen2Spatial",
    "SplitGeLU",
    "GroupNorm",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "Extra",
    "ConvInt8",
    "Int8ToFloat",
    "DepthwiseConvInt8",
    "PoolInt8",
    "FloatToInt8",
    "EltwiseInt8",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "While",
    "If",
    "",
    "LayerNorm",
    "GridSample",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpType(OpType e) {
  if (::flatbuffers::IsOutRange(e, OpType_AbsVal, OpType_GridSample)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpType()[index];
}

enum OpParameter : uint8_t {
  OpParameter_NONE = 0,
  OpParameter_QuantizedAdd = 1,
  OpParameter_ArgMax = 2,
  OpParameter_AsString = 3,
  OpParameter_Axis = 4,
  OpParameter_BatchNorm = 5,
  OpParameter_BinaryOp = 6,
  OpParameter_Blob = 7,
  OpParameter_CastParam = 8,
  OpParameter_Convolution2D = 9,
  OpParameter_Crop = 10,
  OpParameter_CropAndResize = 11,
  OpParameter_Dequantize = 12,
  OpParameter_DetectionOutput = 13,
  OpParameter_Eltwise = 14,
  OpParameter_ExpandDims = 15,
  OpParameter_Fill = 16,
  OpParameter_Flatten = 17,
  OpParameter_Gather = 18,
  OpParameter_GatherV2 = 19,
  OpParameter_InnerProduct = 20,
  OpParameter_Input = 21,
  OpParameter_Interp = 22,
  OpParameter_LRN = 23,
  OpParameter_LSTM = 24,
  OpParameter_MatMul = 25,
  OpParameter_NonMaxSuppressionV2 = 26,
  OpParameter_Normalize = 27,
  OpParameter_PackParam = 28,
  OpParameter_Permute = 29,
  OpParameter_Plugin = 30,
  OpParameter_Pool = 31,
  OpParameter_PRelu = 32,
  OpParameter_PriorBox = 33,
  OpParameter_Proposal = 34,
  OpParameter_QuantizedAvgPool = 35,
  OpParameter_QuantizedBiasAdd = 36,
  OpParameter_QuantizedConcat = 37,
  OpParameter_QuantizedLogistic = 38,
  OpParameter_QuantizedMatMul = 39,
  OpParameter_QuantizedMaxPool = 40,
  OpParameter_QuantizedRelu = 41,
  OpParameter_QuantizedRelu6 = 42,
  OpParameter_QuantizedReshape = 43,
  OpParameter_QuantizedSoftmax = 44,
  OpParameter_QuantizeMaxMin = 45,
  OpParameter_QuantizeV2 = 46,
  OpParameter_Range = 47,
  OpParameter_Rank = 48,
  OpParameter_ReduceJoin = 49,
  OpParameter_ReductionParam = 50,
  OpParameter_Relu = 51,
  OpParameter_Relu6 = 52,
  OpParameter_RequantizationRange = 53,
  OpParameter_Requantize = 54,
  OpParameter_Reshape = 55,
  OpParameter_Resize = 56,
  OpParameter_RoiParameters = 57,
  OpParameter_Scale = 58,
  OpParameter_Selu = 59,
  OpParameter_Size = 60,
  OpParameter_Slice = 61,
  OpParameter_SliceTf = 62,
  OpParameter_SpaceBatch = 63,
  OpParameter_SqueezeParam = 64,
  OpParameter_StridedSliceParam = 65,
  OpParameter_TensorConvertInfo = 66,
  OpParameter_TfQuantizedConv2D = 67,
  OpParameter_TopKV2 = 68,
  OpParameter_Transpose = 69,
  OpParameter_UnaryOp = 70,
  OpParameter_MomentsParam = 71,
  OpParameter_RNNParam = 72,
  OpParameter_BatchMatMulParam = 73,
  OpParameter_QuantizedFloatParam = 74,
  OpParameter_DepthSpaceParam = 75,
  OpParameter_EltwiseInt8 = 76,
  OpParameter_ReverseSequenceParam = 77,
  OpParameter_Extra = 78,
  OpParameter_Pool3D = 79,
  OpParameter_Convolution3D = 80,
  OpParameter_ELU = 81,
  OpParameter_DetectionPostProcessParam = 82,
  OpParameter_OneHotParam = 83,
  OpParameter_PadParam = 84,
  OpParameter_WhileParam = 85,
  OpParameter_IfParam = 86,
  OpParameter_RandomUniform = 87,
  OpParameter_LayerNorm = 88,
  OpParameter_TensorArray = 89,
  OpParameter_LSTMBlockCell = 90,
  OpParameter_GridSample = 91,
  OpParameter_LoopParam = 92,
  OpParameter_ImageProcessParam = 93,
  OpParameter_CumSum = 94,
  OpParameter_GroupNorm = 95,
  OpParameter_FmhaV2Param = 96,
  OpParameter_FmhcaParam = 97,
  OpParameter_AttentionParam = 98,
  OpParameter_StftParam = 99,
  OpParameter_MIN = OpParameter_NONE,
  OpParameter_MAX = OpParameter_StftParam
};

inline const OpParameter (&EnumValuesOpParameter())[100] {
  static const OpParameter values[] = {
    OpParameter_NONE,
    OpParameter_QuantizedAdd,
    OpParameter_ArgMax,
    OpParameter_AsString,
    OpParameter_Axis,
    OpParameter_BatchNorm,
    OpParameter_BinaryOp,
    OpParameter_Blob,
    OpParameter_CastParam,
    OpParameter_Convolution2D,
    OpParameter_Crop,
    OpParameter_CropAndResize,
    OpParameter_Dequantize,
    OpParameter_DetectionOutput,
    OpParameter_Eltwise,
    OpParameter_ExpandDims,
    OpParameter_Fill,
    OpParameter_Flatten,
    OpParameter_Gather,
    OpParameter_GatherV2,
    OpParameter_InnerProduct,
    OpParameter_Input,
    OpParameter_Interp,
    OpParameter_LRN,
    OpParameter_LSTM,
    OpParameter_MatMul,
    OpParameter_NonMaxSuppressionV2,
    OpParameter_Normalize,
    OpParameter_PackParam,
    OpParameter_Permute,
    OpParameter_Plugin,
    OpParameter_Pool,
    OpParameter_PRelu,
    OpParameter_PriorBox,
    OpParameter_Proposal,
    OpParameter_QuantizedAvgPool,
    OpParameter_QuantizedBiasAdd,
    OpParameter_QuantizedConcat,
    OpParameter_QuantizedLogistic,
    OpParameter_QuantizedMatMul,
    OpParameter_QuantizedMaxPool,
    OpParameter_QuantizedRelu,
    OpParameter_QuantizedRelu6,
    OpParameter_QuantizedReshape,
    OpParameter_QuantizedSoftmax,
    OpParameter_QuantizeMaxMin,
    OpParameter_QuantizeV2,
    OpParameter_Range,
    OpParameter_Rank,
    OpParameter_ReduceJoin,
    OpParameter_ReductionParam,
    OpParameter_Relu,
    OpParameter_Relu6,
    OpParameter_RequantizationRange,
    OpParameter_Requantize,
    OpParameter_Reshape,
    OpParameter_Resize,
    OpParameter_RoiParameters,
    OpParameter_Scale,
    OpParameter_Selu,
    OpParameter_Size,
    OpParameter_Slice,
    OpParameter_SliceTf,
    OpParameter_SpaceBatch,
    OpParameter_SqueezeParam,
    OpParameter_StridedSliceParam,
    OpParameter_TensorConvertInfo,
    OpParameter_TfQuantizedConv2D,
    OpParameter_TopKV2,
    OpParameter_Transpose,
    OpParameter_UnaryOp,
    OpParameter_MomentsParam,
    OpParameter_RNNParam,
    OpParameter_BatchMatMulParam,
    OpParameter_QuantizedFloatParam,
    OpParameter_DepthSpaceParam,
    OpParameter_EltwiseInt8,
    OpParameter_ReverseSequenceParam,
    OpParameter_Extra,
    OpParameter_Pool3D,
    OpParameter_Convolution3D,
    OpParameter_ELU,
    OpParameter_DetectionPostProcessParam,
    OpParameter_OneHotParam,
    OpParameter_PadParam,
    OpParameter_WhileParam,
    OpParameter_IfParam,
    OpParameter_RandomUniform,
    OpParameter_LayerNorm,
    OpParameter_TensorArray,
    OpParameter_LSTMBlockCell,
    OpParameter_GridSample,
    OpParameter_LoopParam,
    OpParameter_ImageProcessParam,
    OpParameter_CumSum,
    OpParameter_GroupNorm,
    OpParameter_FmhaV2Param,
    OpParameter_FmhcaParam,
    OpParameter_AttentionParam,
    OpParameter_StftParam
  };
  return values;
}

inline const char * const *EnumNamesOpParameter() {
  static const char * const names[101] = {
    "NONE",
    "QuantizedAdd",
    "ArgMax",
    "AsString",
    "Axis",
    "BatchNorm",
    "BinaryOp",
    "Blob",
    "CastParam",
    "Convolution2D",
    "Crop",
    "CropAndResize",
    "Dequantize",
    "DetectionOutput",
    "Eltwise",
    "ExpandDims",
    "Fill",
    "Flatten",
    "Gather",
    "GatherV2",
    "InnerProduct",
    "Input",
    "Interp",
    "LRN",
    "LSTM",
    "MatMul",
    "NonMaxSuppressionV2",
    "Normalize",
    "PackParam",
    "Permute",
    "Plugin",
    "Pool",
    "PRelu",
    "PriorBox",
    "Proposal",
    "QuantizedAvgPool",
    "QuantizedBiasAdd",
    "QuantizedConcat",
    "QuantizedLogistic",
    "QuantizedMatMul",
    "QuantizedMaxPool",
    "QuantizedRelu",
    "QuantizedRelu6",
    "QuantizedReshape",
    "QuantizedSoftmax",
    "QuantizeMaxMin",
    "QuantizeV2",
    "Range",
    "Rank",
    "ReduceJoin",
    "ReductionParam",
    "Relu",
    "Relu6",
    "RequantizationRange",
    "Requantize",
    "Reshape",
    "Resize",
    "RoiParameters",
    "Scale",
    "Selu",
    "Size",
    "Slice",
    "SliceTf",
    "SpaceBatch",
    "SqueezeParam",
    "StridedSliceParam",
    "TensorConvertInfo",
    "TfQuantizedConv2D",
    "TopKV2",
    "Transpose",
    "UnaryOp",
    "MomentsParam",
    "RNNParam",
    "BatchMatMulParam",
    "QuantizedFloatParam",
    "DepthSpaceParam",
    "EltwiseInt8",
    "ReverseSequenceParam",
    "Extra",
    "Pool3D",
    "Convolution3D",
    "ELU",
    "DetectionPostProcessParam",
    "OneHotParam",
    "PadParam",
    "WhileParam",
    "IfParam",
    "RandomUniform",
    "LayerNorm",
    "TensorArray",
    "LSTMBlockCell",
    "GridSample",
    "LoopParam",
    "ImageProcessParam",
    "CumSum",
    "GroupNorm",
    "FmhaV2Param",
    "FmhcaParam",
    "AttentionParam",
    "StftParam",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParameter(OpParameter e) {
  if (::flatbuffers::IsOutRange(e, OpParameter_NONE, OpParameter_StftParam)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpParameter()[index];
}

template<typename T> struct OpParameterTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterTraits<MNN::QuantizedAdd> {
  static const OpParameter enum_value = OpParameter_QuantizedAdd;
};

template<> struct OpParameterTraits<MNN::ArgMax> {
  static const OpParameter enum_value = OpParameter_ArgMax;
};

template<> struct OpParameterTraits<MNN::AsString> {
  static const OpParameter enum_value = OpParameter_AsString;
};

template<> struct OpParameterTraits<MNN::Axis> {
  static const OpParameter enum_value = OpParameter_Axis;
};

template<> struct OpParameterTraits<MNN::BatchNorm> {
  static const OpParameter enum_value = OpParameter_BatchNorm;
};

template<> struct OpParameterTraits<MNN::BinaryOp> {
  static const OpParameter enum_value = OpParameter_BinaryOp;
};

template<> struct OpParameterTraits<MNN::Blob> {
  static const OpParameter enum_value = OpParameter_Blob;
};

template<> struct OpParameterTraits<MNN::CastParam> {
  static const OpParameter enum_value = OpParameter_CastParam;
};

template<> struct OpParameterTraits<MNN::Convolution2D> {
  static const OpParameter enum_value = OpParameter_Convolution2D;
};

template<> struct OpParameterTraits<MNN::Crop> {
  static const OpParameter enum_value = OpParameter_Crop;
};

template<> struct OpParameterTraits<MNN::CropAndResize> {
  static const OpParameter enum_value = OpParameter_CropAndResize;
};

template<> struct OpParameterTraits<MNN::Dequantize> {
  static const OpParameter enum_value = OpParameter_Dequantize;
};

template<> struct OpParameterTraits<MNN::DetectionOutput> {
  static const OpParameter enum_value = OpParameter_DetectionOutput;
};

template<> struct OpParameterTraits<MNN::Eltwise> {
  static const OpParameter enum_value = OpParameter_Eltwise;
};

template<> struct OpParameterTraits<MNN::ExpandDims> {
  static const OpParameter enum_value = OpParameter_ExpandDims;
};

template<> struct OpParameterTraits<MNN::Fill> {
  static const OpParameter enum_value = OpParameter_Fill;
};

template<> struct OpParameterTraits<MNN::Flatten> {
  static const OpParameter enum_value = OpParameter_Flatten;
};

template<> struct OpParameterTraits<MNN::Gather> {
  static const OpParameter enum_value = OpParameter_Gather;
};

template<> struct OpParameterTraits<MNN::GatherV2> {
  static const OpParameter enum_value = OpParameter_GatherV2;
};

template<> struct OpParameterTraits<MNN::InnerProduct> {
  static const OpParameter enum_value = OpParameter_InnerProduct;
};

template<> struct OpParameterTraits<MNN::Input> {
  static const OpParameter enum_value = OpParameter_Input;
};

template<> struct OpParameterTraits<MNN::Interp> {
  static const OpParameter enum_value = OpParameter_Interp;
};

template<> struct OpParameterTraits<MNN::LRN> {
  static const OpParameter enum_value = OpParameter_LRN;
};

template<> struct OpParameterTraits<MNN::LSTM> {
  static const OpParameter enum_value = OpParameter_LSTM;
};

template<> struct OpParameterTraits<MNN::MatMul> {
  static const OpParameter enum_value = OpParameter_MatMul;
};

template<> struct OpParameterTraits<MNN::NonMaxSuppressionV2> {
  static const OpParameter enum_value = OpParameter_NonMaxSuppressionV2;
};

template<> struct OpParameterTraits<MNN::Normalize> {
  static const OpParameter enum_value = OpParameter_Normalize;
};

template<> struct OpParameterTraits<MNN::PackParam> {
  static const OpParameter enum_value = OpParameter_PackParam;
};

template<> struct OpParameterTraits<MNN::Permute> {
  static const OpParameter enum_value = OpParameter_Permute;
};

template<> struct OpParameterTraits<MNN::Plugin> {
  static const OpParameter enum_value = OpParameter_Plugin;
};

template<> struct OpParameterTraits<MNN::Pool> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<> struct OpParameterTraits<MNN::PRelu> {
  static const OpParameter enum_value = OpParameter_PRelu;
};

template<> struct OpParameterTraits<MNN::PriorBox> {
  static const OpParameter enum_value = OpParameter_PriorBox;
};

template<> struct OpParameterTraits<MNN::Proposal> {
  static const OpParameter enum_value = OpParameter_Proposal;
};

template<> struct OpParameterTraits<MNN::QuantizedAvgPool> {
  static const OpParameter enum_value = OpParameter_QuantizedAvgPool;
};

template<> struct OpParameterTraits<MNN::QuantizedBiasAdd> {
  static const OpParameter enum_value = OpParameter_QuantizedBiasAdd;
};

template<> struct OpParameterTraits<MNN::QuantizedConcat> {
  static const OpParameter enum_value = OpParameter_QuantizedConcat;
};

template<> struct OpParameterTraits<MNN::QuantizedLogistic> {
  static const OpParameter enum_value = OpParameter_QuantizedLogistic;
};

template<> struct OpParameterTraits<MNN::QuantizedMatMul> {
  static const OpParameter enum_value = OpParameter_QuantizedMatMul;
};

template<> struct OpParameterTraits<MNN::QuantizedMaxPool> {
  static const OpParameter enum_value = OpParameter_QuantizedMaxPool;
};

template<> struct OpParameterTraits<MNN::QuantizedRelu> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu;
};

template<> struct OpParameterTraits<MNN::QuantizedRelu6> {
  static const OpParameter enum_value = OpParameter_QuantizedRelu6;
};

template<> struct OpParameterTraits<MNN::QuantizedReshape> {
  static const OpParameter enum_value = OpParameter_QuantizedReshape;
};

template<> struct OpParameterTraits<MNN::QuantizedSoftmax> {
  static const OpParameter enum_value = OpParameter_QuantizedSoftmax;
};

template<> struct OpParameterTraits<MNN::QuantizeMaxMin> {
  static const OpParameter enum_value = OpParameter_QuantizeMaxMin;
};

template<> struct OpParameterTraits<MNN::QuantizeV2> {
  static const OpParameter enum_value = OpParameter_QuantizeV2;
};

template<> struct OpParameterTraits<MNN::Range> {
  static const OpParameter enum_value = OpParameter_Range;
};

template<> struct OpParameterTraits<MNN::Rank> {
  static const OpParameter enum_value = OpParameter_Rank;
};

template<> struct OpParameterTraits<MNN::ReduceJoin> {
  static const OpParameter enum_value = OpParameter_ReduceJoin;
};

template<> struct OpParameterTraits<MNN::ReductionParam> {
  static const OpParameter enum_value = OpParameter_ReductionParam;
};

template<> struct OpParameterTraits<MNN::Relu> {
  static const OpParameter enum_value = OpParameter_Relu;
};

template<> struct OpParameterTraits<MNN::Relu6> {
  static const OpParameter enum_value = OpParameter_Relu6;
};

template<> struct OpParameterTraits<MNN::RequantizationRange> {
  static const OpParameter enum_value = OpParameter_RequantizationRange;
};

template<> struct OpParameterTraits<MNN::Requantize> {
  static const OpParameter enum_value = OpParameter_Requantize;
};

template<> struct OpParameterTraits<MNN::Reshape> {
  static const OpParameter enum_value = OpParameter_Reshape;
};

template<> struct OpParameterTraits<MNN::Resize> {
  static const OpParameter enum_value = OpParameter_Resize;
};

template<> struct OpParameterTraits<MNN::RoiParameters> {
  static const OpParameter enum_value = OpParameter_RoiParameters;
};

template<> struct OpParameterTraits<MNN::Scale> {
  static const OpParameter enum_value = OpParameter_Scale;
};

template<> struct OpParameterTraits<MNN::Selu> {
  static const OpParameter enum_value = OpParameter_Selu;
};

template<> struct OpParameterTraits<MNN::Size> {
  static const OpParameter enum_value = OpParameter_Size;
};

template<> struct OpParameterTraits<MNN::Slice> {
  static const OpParameter enum_value = OpParameter_Slice;
};

template<> struct OpParameterTraits<MNN::SliceTf> {
  static const OpParameter enum_value = OpParameter_SliceTf;
};

template<> struct OpParameterTraits<MNN::SpaceBatch> {
  static const OpParameter enum_value = OpParameter_SpaceBatch;
};

template<> struct OpParameterTraits<MNN::SqueezeParam> {
  static const OpParameter enum_value = OpParameter_SqueezeParam;
};

template<> struct OpParameterTraits<MNN::StridedSliceParam> {
  static const OpParameter enum_value = OpParameter_StridedSliceParam;
};

template<> struct OpParameterTraits<MNN::TensorConvertInfo> {
  static const OpParameter enum_value = OpParameter_TensorConvertInfo;
};

template<> struct OpParameterTraits<MNN::TfQuantizedConv2D> {
  static const OpParameter enum_value = OpParameter_TfQuantizedConv2D;
};

template<> struct OpParameterTraits<MNN::TopKV2> {
  static const OpParameter enum_value = OpParameter_TopKV2;
};

template<> struct OpParameterTraits<MNN::Transpose> {
  static const OpParameter enum_value = OpParameter_Transpose;
};

template<> struct OpParameterTraits<MNN::UnaryOp> {
  static const OpParameter enum_value = OpParameter_UnaryOp;
};

template<> struct OpParameterTraits<MNN::MomentsParam> {
  static const OpParameter enum_value = OpParameter_MomentsParam;
};

template<> struct OpParameterTraits<MNN::RNNParam> {
  static const OpParameter enum_value = OpParameter_RNNParam;
};

template<> struct OpParameterTraits<MNN::BatchMatMulParam> {
  static const OpParameter enum_value = OpParameter_BatchMatMulParam;
};

template<> struct OpParameterTraits<MNN::QuantizedFloatParam> {
  static const OpParameter enum_value = OpParameter_QuantizedFloatParam;
};

template<> struct OpParameterTraits<MNN::DepthSpaceParam> {
  static const OpParameter enum_value = OpParameter_DepthSpaceParam;
};

template<> struct OpParameterTraits<MNN::EltwiseInt8> {
  static const OpParameter enum_value = OpParameter_EltwiseInt8;
};

template<> struct OpParameterTraits<MNN::ReverseSequenceParam> {
  static const OpParameter enum_value = OpParameter_ReverseSequenceParam;
};

template<> struct OpParameterTraits<MNN::Extra> {
  static const OpParameter enum_value = OpParameter_Extra;
};

template<> struct OpParameterTraits<MNN::Pool3D> {
  static const OpParameter enum_value = OpParameter_Pool3D;
};

template<> struct OpParameterTraits<MNN::Convolution3D> {
  static const OpParameter enum_value = OpParameter_Convolution3D;
};

template<> struct OpParameterTraits<MNN::ELU> {
  static const OpParameter enum_value = OpParameter_ELU;
};

template<> struct OpParameterTraits<MNN::DetectionPostProcessParam> {
  static const OpParameter enum_value = OpParameter_DetectionPostProcessParam;
};

template<> struct OpParameterTraits<MNN::OneHotParam> {
  static const OpParameter enum_value = OpParameter_OneHotParam;
};

template<> struct OpParameterTraits<MNN::PadParam> {
  static const OpParameter enum_value = OpParameter_PadParam;
};

template<> struct OpParameterTraits<MNN::WhileParam> {
  static const OpParameter enum_value = OpParameter_WhileParam;
};

template<> struct OpParameterTraits<MNN::IfParam> {
  static const OpParameter enum_value = OpParameter_IfParam;
};

template<> struct OpParameterTraits<MNN::RandomUniform> {
  static const OpParameter enum_value = OpParameter_RandomUniform;
};

template<> struct OpParameterTraits<MNN::LayerNorm> {
  static const OpParameter enum_value = OpParameter_LayerNorm;
};

template<> struct OpParameterTraits<MNN::TensorArray> {
  static const OpParameter enum_value = OpParameter_TensorArray;
};

template<> struct OpParameterTraits<MNN::LSTMBlockCell> {
  static const OpParameter enum_value = OpParameter_LSTMBlockCell;
};

template<> struct OpParameterTraits<MNN::GridSample> {
  static const OpParameter enum_value = OpParameter_GridSample;
};

template<> struct OpParameterTraits<MNN::LoopParam> {
  static const OpParameter enum_value = OpParameter_LoopParam;
};

template<> struct OpParameterTraits<MNN::ImageProcessParam> {
  static const OpParameter enum_value = OpParameter_ImageProcessParam;
};

template<> struct OpParameterTraits<MNN::CumSum> {
  static const OpParameter enum_value = OpParameter_CumSum;
};

template<> struct OpParameterTraits<MNN::GroupNorm> {
  static const OpParameter enum_value = OpParameter_GroupNorm;
};

template<> struct OpParameterTraits<MNN::FmhaV2Param> {
  static const OpParameter enum_value = OpParameter_FmhaV2Param;
};

template<> struct OpParameterTraits<MNN::FmhcaParam> {
  static const OpParameter enum_value = OpParameter_FmhcaParam;
};

template<> struct OpParameterTraits<MNN::AttentionParam> {
  static const OpParameter enum_value = OpParameter_AttentionParam;
};

template<> struct OpParameterTraits<MNN::StftParam> {
  static const OpParameter enum_value = OpParameter_StftParam;
};

bool VerifyOpParameter(::flatbuffers::Verifier &verifier, const void *obj, OpParameter type);
bool VerifyOpParameterVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

enum ForwardType : int8_t {
  ForwardType_CPU = 0,
  ForwardType_METAL = 1,
  ForwardType_OPENCL = 2,
  ForwardType_OPENGLES = 3,
  ForwardType_VULKAN = 4,
  ForwardType_MIN = ForwardType_CPU,
  ForwardType_MAX = ForwardType_VULKAN
};

inline const ForwardType (&EnumValuesForwardType())[5] {
  static const ForwardType values[] = {
    ForwardType_CPU,
    ForwardType_METAL,
    ForwardType_OPENCL,
    ForwardType_OPENGLES,
    ForwardType_VULKAN
  };
  return values;
}

inline const char * const *EnumNamesForwardType() {
  static const char * const names[6] = {
    "CPU",
    "METAL",
    "OPENCL",
    "OPENGLES",
    "VULKAN",
    nullptr
  };
  return names;
}

inline const char *EnumNameForwardType(ForwardType e) {
  if (::flatbuffers::IsOutRange(e, ForwardType_CPU, ForwardType_VULKAN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesForwardType()[index];
}

enum Usage : int8_t {
  Usage_INFERENCE = 0,
  Usage_TRAIN = 1,
  Usage_INFERENCE_STATIC = 2,
  Usage_MIN = Usage_INFERENCE,
  Usage_MAX = Usage_INFERENCE_STATIC
};

inline const Usage (&EnumValuesUsage())[3] {
  static const Usage values[] = {
    Usage_INFERENCE,
    Usage_TRAIN,
    Usage_INFERENCE_STATIC
  };
  return values;
}

inline const char * const *EnumNamesUsage() {
  static const char * const names[4] = {
    "INFERENCE",
    "TRAIN",
    "INFERENCE_STATIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameUsage(Usage e) {
  if (::flatbuffers::IsOutRange(e, Usage_INFERENCE, Usage_INFERENCE_STATIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUsage()[index];
}

struct Plugin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PluginBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ATTR = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *attr() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *>(VT_ATTR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
};

struct PluginBuilder {
  typedef Plugin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Plugin::VT_TYPE, type);
  }
  void add_attr(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> attr) {
    fbb_.AddOffset(Plugin::VT_ATTR, attr);
  }
  explicit PluginBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Plugin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Plugin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Plugin> CreatePlugin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> attr = 0) {
  PluginBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Plugin> CreatePluginDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    std::vector<::flatbuffers::Offset<MNN::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<MNN::Attribute>(attr) : 0;
  return MNN::CreatePlugin(
      _fbb,
      type__,
      attr__);
}

struct Extra FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExtraBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ENGINE = 6,
    VT_INFO = 8,
    VT_ATTR = 10,
    VT_VECTOR = 12
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::String *engine() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ENGINE);
  }
  const ::flatbuffers::Vector<int8_t> *info() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_INFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *attr() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *>(VT_ATTR);
  }
  bool vector() const {
    return GetField<uint8_t>(VT_VECTOR, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ENGINE) &&
           verifier.VerifyString(engine()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           VerifyField<uint8_t>(verifier, VT_VECTOR, 1) &&
           verifier.EndTable();
  }
};

struct ExtraBuilder {
  typedef Extra Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(Extra::VT_TYPE, type);
  }
  void add_engine(::flatbuffers::Offset<::flatbuffers::String> engine) {
    fbb_.AddOffset(Extra::VT_ENGINE, engine);
  }
  void add_info(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> info) {
    fbb_.AddOffset(Extra::VT_INFO, info);
  }
  void add_attr(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> attr) {
    fbb_.AddOffset(Extra::VT_ATTR, attr);
  }
  void add_vector(bool vector) {
    fbb_.AddElement<uint8_t>(Extra::VT_VECTOR, static_cast<uint8_t>(vector), 0);
  }
  explicit ExtraBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Extra> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Extra>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Extra> CreateExtra(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::String> engine = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> info = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> attr = 0,
    bool vector = false) {
  ExtraBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_info(info);
  builder_.add_engine(engine);
  builder_.add_type(type);
  builder_.add_vector(vector);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Extra> CreateExtraDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *engine = nullptr,
    const std::vector<int8_t> *info = nullptr,
    std::vector<::flatbuffers::Offset<MNN::Attribute>> *attr = nullptr,
    bool vector = false) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto engine__ = engine ? _fbb.CreateString(engine) : 0;
  auto info__ = info ? _fbb.CreateVector<int8_t>(*info) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<MNN::Attribute>(attr) : 0;
  return MNN::CreateExtra(
      _fbb,
      type__,
      engine__,
      info__,
      attr__,
      vector);
}

struct StringVec FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StringVecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfStrings(data()) &&
           verifier.EndTable();
  }
};

struct StringVecBuilder {
  typedef StringVec Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> data) {
    fbb_.AddOffset(StringVec::VT_DATA, data);
  }
  explicit StringVecBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StringVec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StringVec>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StringVec> CreateStringVec(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> data = 0) {
  StringVecBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StringVec> CreateStringVecDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*data) : 0;
  return MNN::CreateStringVec(
      _fbb,
      data__);
}

struct AttentionParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AttentionParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KV_CACHE = 4
  };
  bool kv_cache() const {
    return GetField<uint8_t>(VT_KV_CACHE, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KV_CACHE, 1) &&
           verifier.EndTable();
  }
};

struct AttentionParamBuilder {
  typedef AttentionParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_kv_cache(bool kv_cache) {
    fbb_.AddElement<uint8_t>(AttentionParam::VT_KV_CACHE, static_cast<uint8_t>(kv_cache), 1);
  }
  explicit AttentionParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AttentionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AttentionParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AttentionParam> CreateAttentionParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool kv_cache = true) {
  AttentionParamBuilder builder_(_fbb);
  builder_.add_kv_cache(kv_cache);
  return builder_.Finish();
}

struct FmhaV2Param FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FmhaV2ParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADS = 4
  };
  int32_t heads() const {
    return GetField<int32_t>(VT_HEADS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEADS, 4) &&
           verifier.EndTable();
  }
};

struct FmhaV2ParamBuilder {
  typedef FmhaV2Param Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heads(int32_t heads) {
    fbb_.AddElement<int32_t>(FmhaV2Param::VT_HEADS, heads, 0);
  }
  explicit FmhaV2ParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FmhaV2Param> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FmhaV2Param>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FmhaV2Param> CreateFmhaV2Param(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t heads = 0) {
  FmhaV2ParamBuilder builder_(_fbb);
  builder_.add_heads(heads);
  return builder_.Finish();
}

struct FmhcaParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FmhcaParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HEADS = 4
  };
  int32_t heads() const {
    return GetField<int32_t>(VT_HEADS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_HEADS, 4) &&
           verifier.EndTable();
  }
};

struct FmhcaParamBuilder {
  typedef FmhcaParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_heads(int32_t heads) {
    fbb_.AddElement<int32_t>(FmhcaParam::VT_HEADS, heads, 0);
  }
  explicit FmhcaParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FmhcaParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FmhcaParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FmhcaParam> CreateFmhcaParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t heads = 0) {
  FmhcaParamBuilder builder_(_fbb);
  builder_.add_heads(heads);
  return builder_.Finish();
}

struct StftParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StftParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N_FFT = 4,
    VT_HOP_LENGTH = 6,
    VT_ABS = 8
  };
  int32_t n_fft() const {
    return GetField<int32_t>(VT_N_FFT, 0);
  }
  int32_t hop_length() const {
    return GetField<int32_t>(VT_HOP_LENGTH, 0);
  }
  bool abs() const {
    return GetField<uint8_t>(VT_ABS, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N_FFT, 4) &&
           VerifyField<int32_t>(verifier, VT_HOP_LENGTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_ABS, 1) &&
           verifier.EndTable();
  }
};

struct StftParamBuilder {
  typedef StftParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_n_fft(int32_t n_fft) {
    fbb_.AddElement<int32_t>(StftParam::VT_N_FFT, n_fft, 0);
  }
  void add_hop_length(int32_t hop_length) {
    fbb_.AddElement<int32_t>(StftParam::VT_HOP_LENGTH, hop_length, 0);
  }
  void add_abs(bool abs) {
    fbb_.AddElement<uint8_t>(StftParam::VT_ABS, static_cast<uint8_t>(abs), 1);
  }
  explicit StftParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StftParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StftParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StftParam> CreateStftParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t n_fft = 0,
    int32_t hop_length = 0,
    bool abs = true) {
  StftParamBuilder builder_(_fbb);
  builder_.add_hop_length(hop_length);
  builder_.add_n_fft(n_fft);
  builder_.add_abs(abs);
  return builder_.Finish();
}

struct WhileParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WhileParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COND_GRAPH = 4,
    VT_BODY_GRAPH = 6,
    VT_ALIASES_INPUTS = 8,
    VT_ALIASES_OUTPUTS = 10,
    VT_ALIASES_UPDATES = 12
  };
  const ::flatbuffers::String *cond_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COND_GRAPH);
  }
  const ::flatbuffers::String *body_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BODY_GRAPH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *>(VT_ALIASES_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *aliases_outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ALIASES_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_updates() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *>(VT_ALIASES_UPDATES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COND_GRAPH) &&
           verifier.VerifyString(cond_graph()) &&
           VerifyOffset(verifier, VT_BODY_GRAPH) &&
           verifier.VerifyString(body_graph()) &&
           VerifyOffset(verifier, VT_ALIASES_INPUTS) &&
           verifier.VerifyVector(aliases_inputs()) &&
           verifier.VerifyVectorOfTables(aliases_inputs()) &&
           VerifyOffset(verifier, VT_ALIASES_OUTPUTS) &&
           verifier.VerifyVector(aliases_outputs()) &&
           verifier.VerifyVectorOfStrings(aliases_outputs()) &&
           VerifyOffset(verifier, VT_ALIASES_UPDATES) &&
           verifier.VerifyVector(aliases_updates()) &&
           verifier.VerifyVectorOfTables(aliases_updates()) &&
           verifier.EndTable();
  }
};

struct WhileParamBuilder {
  typedef WhileParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cond_graph(::flatbuffers::Offset<::flatbuffers::String> cond_graph) {
    fbb_.AddOffset(WhileParam::VT_COND_GRAPH, cond_graph);
  }
  void add_body_graph(::flatbuffers::Offset<::flatbuffers::String> body_graph) {
    fbb_.AddOffset(WhileParam::VT_BODY_GRAPH, body_graph);
  }
  void add_aliases_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_inputs) {
    fbb_.AddOffset(WhileParam::VT_ALIASES_INPUTS, aliases_inputs);
  }
  void add_aliases_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aliases_outputs) {
    fbb_.AddOffset(WhileParam::VT_ALIASES_OUTPUTS, aliases_outputs);
  }
  void add_aliases_updates(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_updates) {
    fbb_.AddOffset(WhileParam::VT_ALIASES_UPDATES, aliases_updates);
  }
  explicit WhileParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WhileParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WhileParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WhileParam> CreateWhileParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> cond_graph = 0,
    ::flatbuffers::Offset<::flatbuffers::String> body_graph = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> aliases_outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_updates = 0) {
  WhileParamBuilder builder_(_fbb);
  builder_.add_aliases_updates(aliases_updates);
  builder_.add_aliases_outputs(aliases_outputs);
  builder_.add_aliases_inputs(aliases_inputs);
  builder_.add_body_graph(body_graph);
  builder_.add_cond_graph(cond_graph);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WhileParam> CreateWhileParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *cond_graph = nullptr,
    const char *body_graph = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_inputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *aliases_outputs = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_updates = nullptr) {
  auto cond_graph__ = cond_graph ? _fbb.CreateString(cond_graph) : 0;
  auto body_graph__ = body_graph ? _fbb.CreateString(body_graph) : 0;
  auto aliases_inputs__ = aliases_inputs ? _fbb.CreateVector<::flatbuffers::Offset<MNN::StringVec>>(*aliases_inputs) : 0;
  auto aliases_outputs__ = aliases_outputs ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*aliases_outputs) : 0;
  auto aliases_updates__ = aliases_updates ? _fbb.CreateVector<::flatbuffers::Offset<MNN::StringVec>>(*aliases_updates) : 0;
  return MNN::CreateWhileParam(
      _fbb,
      cond_graph__,
      body_graph__,
      aliases_inputs__,
      aliases_outputs__,
      aliases_updates__);
}

struct IfParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IfParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_THEN_GRAPH = 4,
    VT_ELSE_GRAPH = 6,
    VT_ALIASES_INPUTS = 8,
    VT_ALIASES_OUTPUTS = 10
  };
  const ::flatbuffers::String *then_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_THEN_GRAPH);
  }
  const ::flatbuffers::String *else_graph() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ELSE_GRAPH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_inputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *>(VT_ALIASES_INPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_outputs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>> *>(VT_ALIASES_OUTPUTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_THEN_GRAPH) &&
           verifier.VerifyString(then_graph()) &&
           VerifyOffset(verifier, VT_ELSE_GRAPH) &&
           verifier.VerifyString(else_graph()) &&
           VerifyOffset(verifier, VT_ALIASES_INPUTS) &&
           verifier.VerifyVector(aliases_inputs()) &&
           verifier.VerifyVectorOfTables(aliases_inputs()) &&
           VerifyOffset(verifier, VT_ALIASES_OUTPUTS) &&
           verifier.VerifyVector(aliases_outputs()) &&
           verifier.VerifyVectorOfTables(aliases_outputs()) &&
           verifier.EndTable();
  }
};

struct IfParamBuilder {
  typedef IfParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_then_graph(::flatbuffers::Offset<::flatbuffers::String> then_graph) {
    fbb_.AddOffset(IfParam::VT_THEN_GRAPH, then_graph);
  }
  void add_else_graph(::flatbuffers::Offset<::flatbuffers::String> else_graph) {
    fbb_.AddOffset(IfParam::VT_ELSE_GRAPH, else_graph);
  }
  void add_aliases_inputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_inputs) {
    fbb_.AddOffset(IfParam::VT_ALIASES_INPUTS, aliases_inputs);
  }
  void add_aliases_outputs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_outputs) {
    fbb_.AddOffset(IfParam::VT_ALIASES_OUTPUTS, aliases_outputs);
  }
  explicit IfParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IfParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IfParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IfParam> CreateIfParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> then_graph = 0,
    ::flatbuffers::Offset<::flatbuffers::String> else_graph = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::StringVec>>> aliases_outputs = 0) {
  IfParamBuilder builder_(_fbb);
  builder_.add_aliases_outputs(aliases_outputs);
  builder_.add_aliases_inputs(aliases_inputs);
  builder_.add_else_graph(else_graph);
  builder_.add_then_graph(then_graph);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IfParam> CreateIfParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *then_graph = nullptr,
    const char *else_graph = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_inputs = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::StringVec>> *aliases_outputs = nullptr) {
  auto then_graph__ = then_graph ? _fbb.CreateString(then_graph) : 0;
  auto else_graph__ = else_graph ? _fbb.CreateString(else_graph) : 0;
  auto aliases_inputs__ = aliases_inputs ? _fbb.CreateVector<::flatbuffers::Offset<MNN::StringVec>>(*aliases_inputs) : 0;
  auto aliases_outputs__ = aliases_outputs ? _fbb.CreateVector<::flatbuffers::Offset<MNN::StringVec>>(*aliases_outputs) : 0;
  return MNN::CreateIfParam(
      _fbb,
      then_graph__,
      else_graph__,
      aliases_inputs__,
      aliases_outputs__);
}

struct RegionCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegionCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OP = 4,
    VT_STEPS = 6,
    VT_SIZE = 8,
    VT_INDEXES = 10,
    VT_VIEW = 12,
    VT_FUSE = 14,
    VT_ITERINDEXES = 16
  };
  const MNN::Op *op() const {
    return GetPointer<const MNN::Op *>(VT_OP);
  }
  const ::flatbuffers::Vector<int32_t> *steps() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STEPS);
  }
  const ::flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  const ::flatbuffers::Vector<int32_t> *indexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INDEXES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::View>> *view() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::View>> *>(VT_VIEW);
  }
  int32_t fuse() const {
    return GetField<int32_t>(VT_FUSE, -1);
  }
  const ::flatbuffers::Vector<int32_t> *iterIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ITERINDEXES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OP) &&
           verifier.VerifyTable(op()) &&
           VerifyOffset(verifier, VT_STEPS) &&
           verifier.VerifyVector(steps()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           VerifyOffset(verifier, VT_INDEXES) &&
           verifier.VerifyVector(indexes()) &&
           VerifyOffset(verifier, VT_VIEW) &&
           verifier.VerifyVector(view()) &&
           verifier.VerifyVectorOfTables(view()) &&
           VerifyField<int32_t>(verifier, VT_FUSE, 4) &&
           VerifyOffset(verifier, VT_ITERINDEXES) &&
           verifier.VerifyVector(iterIndexes()) &&
           verifier.EndTable();
  }
};

struct RegionCommandBuilder {
  typedef RegionCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_op(::flatbuffers::Offset<MNN::Op> op) {
    fbb_.AddOffset(RegionCommand::VT_OP, op);
  }
  void add_steps(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> steps) {
    fbb_.AddOffset(RegionCommand::VT_STEPS, steps);
  }
  void add_size(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(RegionCommand::VT_SIZE, size);
  }
  void add_indexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> indexes) {
    fbb_.AddOffset(RegionCommand::VT_INDEXES, indexes);
  }
  void add_view(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::View>>> view) {
    fbb_.AddOffset(RegionCommand::VT_VIEW, view);
  }
  void add_fuse(int32_t fuse) {
    fbb_.AddElement<int32_t>(RegionCommand::VT_FUSE, fuse, -1);
  }
  void add_iterIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> iterIndexes) {
    fbb_.AddOffset(RegionCommand::VT_ITERINDEXES, iterIndexes);
  }
  explicit RegionCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RegionCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RegionCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RegionCommand> CreateRegionCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Op> op = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> steps = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> size = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> indexes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::View>>> view = 0,
    int32_t fuse = -1,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> iterIndexes = 0) {
  RegionCommandBuilder builder_(_fbb);
  builder_.add_iterIndexes(iterIndexes);
  builder_.add_fuse(fuse);
  builder_.add_view(view);
  builder_.add_indexes(indexes);
  builder_.add_size(size);
  builder_.add_steps(steps);
  builder_.add_op(op);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RegionCommand> CreateRegionCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Op> op = 0,
    const std::vector<int32_t> *steps = nullptr,
    const std::vector<int32_t> *size = nullptr,
    const std::vector<int32_t> *indexes = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::View>> *view = nullptr,
    int32_t fuse = -1,
    const std::vector<int32_t> *iterIndexes = nullptr) {
  auto steps__ = steps ? _fbb.CreateVector<int32_t>(*steps) : 0;
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  auto indexes__ = indexes ? _fbb.CreateVector<int32_t>(*indexes) : 0;
  auto view__ = view ? _fbb.CreateVector<::flatbuffers::Offset<MNN::View>>(*view) : 0;
  auto iterIndexes__ = iterIndexes ? _fbb.CreateVector<int32_t>(*iterIndexes) : 0;
  return MNN::CreateRegionCommand(
      _fbb,
      op,
      steps__,
      size__,
      indexes__,
      view__,
      fuse,
      iterIndexes__);
}

struct LoopParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LoopParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORNUMBER = 4,
    VT_OUTPUTINDEXES = 6,
    VT_INPUTINDEXES = 8,
    VT_EXTRATENSORINFOS = 10,
    VT_PARALLEL = 12,
    VT_LOOPNUMBER = 14,
    VT_COMMANDS = 16,
    VT_INITCOMMAND = 18
  };
  int32_t tensorNumber() const {
    return GetField<int32_t>(VT_TENSORNUMBER, 0);
  }
  const ::flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTINDEXES);
  }
  const ::flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTINDEXES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>> *extraTensorInfos() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>> *>(VT_EXTRATENSORINFOS);
  }
  bool parallel() const {
    return GetField<uint8_t>(VT_PARALLEL, 1) != 0;
  }
  int32_t loopNumber() const {
    return GetField<int32_t>(VT_LOOPNUMBER, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>> *>(VT_COMMANDS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>> *initCommand() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>> *>(VT_INITCOMMAND);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TENSORNUMBER, 4) &&
           VerifyOffset(verifier, VT_OUTPUTINDEXES) &&
           verifier.VerifyVector(outputIndexes()) &&
           VerifyOffset(verifier, VT_INPUTINDEXES) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyOffset(verifier, VT_EXTRATENSORINFOS) &&
           verifier.VerifyVector(extraTensorInfos()) &&
           verifier.VerifyVectorOfTables(extraTensorInfos()) &&
           VerifyField<uint8_t>(verifier, VT_PARALLEL, 1) &&
           VerifyField<int32_t>(verifier, VT_LOOPNUMBER, 4) &&
           VerifyOffset(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           VerifyOffset(verifier, VT_INITCOMMAND) &&
           verifier.VerifyVector(initCommand()) &&
           verifier.VerifyVectorOfTables(initCommand()) &&
           verifier.EndTable();
  }
};

struct LoopParamBuilder {
  typedef LoopParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensorNumber(int32_t tensorNumber) {
    fbb_.AddElement<int32_t>(LoopParam::VT_TENSORNUMBER, tensorNumber, 0);
  }
  void add_outputIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(LoopParam::VT_OUTPUTINDEXES, outputIndexes);
  }
  void add_inputIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(LoopParam::VT_INPUTINDEXES, inputIndexes);
  }
  void add_extraTensorInfos(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>>> extraTensorInfos) {
    fbb_.AddOffset(LoopParam::VT_EXTRATENSORINFOS, extraTensorInfos);
  }
  void add_parallel(bool parallel) {
    fbb_.AddElement<uint8_t>(LoopParam::VT_PARALLEL, static_cast<uint8_t>(parallel), 1);
  }
  void add_loopNumber(int32_t loopNumber) {
    fbb_.AddElement<int32_t>(LoopParam::VT_LOOPNUMBER, loopNumber, 0);
  }
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>>> commands) {
    fbb_.AddOffset(LoopParam::VT_COMMANDS, commands);
  }
  void add_initCommand(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>>> initCommand) {
    fbb_.AddOffset(LoopParam::VT_INITCOMMAND, initCommand);
  }
  explicit LoopParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LoopParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LoopParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LoopParam> CreateLoopParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensorNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputIndexes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputIndexes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>>> extraTensorInfos = 0,
    bool parallel = true,
    int32_t loopNumber = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>>> commands = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::RegionCommand>>> initCommand = 0) {
  LoopParamBuilder builder_(_fbb);
  builder_.add_initCommand(initCommand);
  builder_.add_commands(commands);
  builder_.add_loopNumber(loopNumber);
  builder_.add_extraTensorInfos(extraTensorInfos);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_tensorNumber(tensorNumber);
  builder_.add_parallel(parallel);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LoopParam> CreateLoopParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t tensorNumber = 0,
    const std::vector<int32_t> *outputIndexes = nullptr,
    const std::vector<int32_t> *inputIndexes = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::TensorDescribe>> *extraTensorInfos = nullptr,
    bool parallel = true,
    int32_t loopNumber = 0,
    const std::vector<::flatbuffers::Offset<MNN::RegionCommand>> *commands = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::RegionCommand>> *initCommand = nullptr) {
  auto outputIndexes__ = outputIndexes ? _fbb.CreateVector<int32_t>(*outputIndexes) : 0;
  auto inputIndexes__ = inputIndexes ? _fbb.CreateVector<int32_t>(*inputIndexes) : 0;
  auto extraTensorInfos__ = extraTensorInfos ? _fbb.CreateVector<::flatbuffers::Offset<MNN::TensorDescribe>>(*extraTensorInfos) : 0;
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<MNN::RegionCommand>>(*commands) : 0;
  auto initCommand__ = initCommand ? _fbb.CreateVector<::flatbuffers::Offset<MNN::RegionCommand>>(*initCommand) : 0;
  return MNN::CreateLoopParam(
      _fbb,
      tensorNumber,
      outputIndexes__,
      inputIndexes__,
      extraTensorInfos__,
      parallel,
      loopNumber,
      commands__,
      initCommand__);
}

struct Op FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUTINDEXES = 4,
    VT_MAIN_TYPE = 6,
    VT_MAIN = 8,
    VT_NAME = 10,
    VT_OUTPUTINDEXES = 12,
    VT_TYPE = 14,
    VT_DEFAULTDIMENTIONFORMAT = 16,
    VT_EXTERNALPATH = 18
  };
  const ::flatbuffers::Vector<int32_t> *inputIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTINDEXES);
  }
  MNN::OpParameter main_type() const {
    return static_cast<MNN::OpParameter>(GetField<uint8_t>(VT_MAIN_TYPE, 0));
  }
  const void *main() const {
    return GetPointer<const void *>(VT_MAIN);
  }
  template<typename T> const T *main_as() const;
  const MNN::QuantizedAdd *main_as_QuantizedAdd() const {
    return main_type() == MNN::OpParameter_QuantizedAdd ? static_cast<const MNN::QuantizedAdd *>(main()) : nullptr;
  }
  const MNN::ArgMax *main_as_ArgMax() const {
    return main_type() == MNN::OpParameter_ArgMax ? static_cast<const MNN::ArgMax *>(main()) : nullptr;
  }
  const MNN::AsString *main_as_AsString() const {
    return main_type() == MNN::OpParameter_AsString ? static_cast<const MNN::AsString *>(main()) : nullptr;
  }
  const MNN::Axis *main_as_Axis() const {
    return main_type() == MNN::OpParameter_Axis ? static_cast<const MNN::Axis *>(main()) : nullptr;
  }
  const MNN::BatchNorm *main_as_BatchNorm() const {
    return main_type() == MNN::OpParameter_BatchNorm ? static_cast<const MNN::BatchNorm *>(main()) : nullptr;
  }
  const MNN::BinaryOp *main_as_BinaryOp() const {
    return main_type() == MNN::OpParameter_BinaryOp ? static_cast<const MNN::BinaryOp *>(main()) : nullptr;
  }
  const MNN::Blob *main_as_Blob() const {
    return main_type() == MNN::OpParameter_Blob ? static_cast<const MNN::Blob *>(main()) : nullptr;
  }
  const MNN::CastParam *main_as_CastParam() const {
    return main_type() == MNN::OpParameter_CastParam ? static_cast<const MNN::CastParam *>(main()) : nullptr;
  }
  const MNN::Convolution2D *main_as_Convolution2D() const {
    return main_type() == MNN::OpParameter_Convolution2D ? static_cast<const MNN::Convolution2D *>(main()) : nullptr;
  }
  const MNN::Crop *main_as_Crop() const {
    return main_type() == MNN::OpParameter_Crop ? static_cast<const MNN::Crop *>(main()) : nullptr;
  }
  const MNN::CropAndResize *main_as_CropAndResize() const {
    return main_type() == MNN::OpParameter_CropAndResize ? static_cast<const MNN::CropAndResize *>(main()) : nullptr;
  }
  const MNN::Dequantize *main_as_Dequantize() const {
    return main_type() == MNN::OpParameter_Dequantize ? static_cast<const MNN::Dequantize *>(main()) : nullptr;
  }
  const MNN::DetectionOutput *main_as_DetectionOutput() const {
    return main_type() == MNN::OpParameter_DetectionOutput ? static_cast<const MNN::DetectionOutput *>(main()) : nullptr;
  }
  const MNN::Eltwise *main_as_Eltwise() const {
    return main_type() == MNN::OpParameter_Eltwise ? static_cast<const MNN::Eltwise *>(main()) : nullptr;
  }
  const MNN::ExpandDims *main_as_ExpandDims() const {
    return main_type() == MNN::OpParameter_ExpandDims ? static_cast<const MNN::ExpandDims *>(main()) : nullptr;
  }
  const MNN::Fill *main_as_Fill() const {
    return main_type() == MNN::OpParameter_Fill ? static_cast<const MNN::Fill *>(main()) : nullptr;
  }
  const MNN::Flatten *main_as_Flatten() const {
    return main_type() == MNN::OpParameter_Flatten ? static_cast<const MNN::Flatten *>(main()) : nullptr;
  }
  const MNN::Gather *main_as_Gather() const {
    return main_type() == MNN::OpParameter_Gather ? static_cast<const MNN::Gather *>(main()) : nullptr;
  }
  const MNN::GatherV2 *main_as_GatherV2() const {
    return main_type() == MNN::OpParameter_GatherV2 ? static_cast<const MNN::GatherV2 *>(main()) : nullptr;
  }
  const MNN::InnerProduct *main_as_InnerProduct() const {
    return main_type() == MNN::OpParameter_InnerProduct ? static_cast<const MNN::InnerProduct *>(main()) : nullptr;
  }
  const MNN::Input *main_as_Input() const {
    return main_type() == MNN::OpParameter_Input ? static_cast<const MNN::Input *>(main()) : nullptr;
  }
  const MNN::Interp *main_as_Interp() const {
    return main_type() == MNN::OpParameter_Interp ? static_cast<const MNN::Interp *>(main()) : nullptr;
  }
  const MNN::LRN *main_as_LRN() const {
    return main_type() == MNN::OpParameter_LRN ? static_cast<const MNN::LRN *>(main()) : nullptr;
  }
  const MNN::LSTM *main_as_LSTM() const {
    return main_type() == MNN::OpParameter_LSTM ? static_cast<const MNN::LSTM *>(main()) : nullptr;
  }
  const MNN::MatMul *main_as_MatMul() const {
    return main_type() == MNN::OpParameter_MatMul ? static_cast<const MNN::MatMul *>(main()) : nullptr;
  }
  const MNN::NonMaxSuppressionV2 *main_as_NonMaxSuppressionV2() const {
    return main_type() == MNN::OpParameter_NonMaxSuppressionV2 ? static_cast<const MNN::NonMaxSuppressionV2 *>(main()) : nullptr;
  }
  const MNN::Normalize *main_as_Normalize() const {
    return main_type() == MNN::OpParameter_Normalize ? static_cast<const MNN::Normalize *>(main()) : nullptr;
  }
  const MNN::PackParam *main_as_PackParam() const {
    return main_type() == MNN::OpParameter_PackParam ? static_cast<const MNN::PackParam *>(main()) : nullptr;
  }
  const MNN::Permute *main_as_Permute() const {
    return main_type() == MNN::OpParameter_Permute ? static_cast<const MNN::Permute *>(main()) : nullptr;
  }
  const MNN::Plugin *main_as_Plugin() const {
    return main_type() == MNN::OpParameter_Plugin ? static_cast<const MNN::Plugin *>(main()) : nullptr;
  }
  const MNN::Pool *main_as_Pool() const {
    return main_type() == MNN::OpParameter_Pool ? static_cast<const MNN::Pool *>(main()) : nullptr;
  }
  const MNN::PRelu *main_as_PRelu() const {
    return main_type() == MNN::OpParameter_PRelu ? static_cast<const MNN::PRelu *>(main()) : nullptr;
  }
  const MNN::PriorBox *main_as_PriorBox() const {
    return main_type() == MNN::OpParameter_PriorBox ? static_cast<const MNN::PriorBox *>(main()) : nullptr;
  }
  const MNN::Proposal *main_as_Proposal() const {
    return main_type() == MNN::OpParameter_Proposal ? static_cast<const MNN::Proposal *>(main()) : nullptr;
  }
  const MNN::QuantizedAvgPool *main_as_QuantizedAvgPool() const {
    return main_type() == MNN::OpParameter_QuantizedAvgPool ? static_cast<const MNN::QuantizedAvgPool *>(main()) : nullptr;
  }
  const MNN::QuantizedBiasAdd *main_as_QuantizedBiasAdd() const {
    return main_type() == MNN::OpParameter_QuantizedBiasAdd ? static_cast<const MNN::QuantizedBiasAdd *>(main()) : nullptr;
  }
  const MNN::QuantizedConcat *main_as_QuantizedConcat() const {
    return main_type() == MNN::OpParameter_QuantizedConcat ? static_cast<const MNN::QuantizedConcat *>(main()) : nullptr;
  }
  const MNN::QuantizedLogistic *main_as_QuantizedLogistic() const {
    return main_type() == MNN::OpParameter_QuantizedLogistic ? static_cast<const MNN::QuantizedLogistic *>(main()) : nullptr;
  }
  const MNN::QuantizedMatMul *main_as_QuantizedMatMul() const {
    return main_type() == MNN::OpParameter_QuantizedMatMul ? static_cast<const MNN::QuantizedMatMul *>(main()) : nullptr;
  }
  const MNN::QuantizedMaxPool *main_as_QuantizedMaxPool() const {
    return main_type() == MNN::OpParameter_QuantizedMaxPool ? static_cast<const MNN::QuantizedMaxPool *>(main()) : nullptr;
  }
  const MNN::QuantizedRelu *main_as_QuantizedRelu() const {
    return main_type() == MNN::OpParameter_QuantizedRelu ? static_cast<const MNN::QuantizedRelu *>(main()) : nullptr;
  }
  const MNN::QuantizedRelu6 *main_as_QuantizedRelu6() const {
    return main_type() == MNN::OpParameter_QuantizedRelu6 ? static_cast<const MNN::QuantizedRelu6 *>(main()) : nullptr;
  }
  const MNN::QuantizedReshape *main_as_QuantizedReshape() const {
    return main_type() == MNN::OpParameter_QuantizedReshape ? static_cast<const MNN::QuantizedReshape *>(main()) : nullptr;
  }
  const MNN::QuantizedSoftmax *main_as_QuantizedSoftmax() const {
    return main_type() == MNN::OpParameter_QuantizedSoftmax ? static_cast<const MNN::QuantizedSoftmax *>(main()) : nullptr;
  }
  const MNN::QuantizeMaxMin *main_as_QuantizeMaxMin() const {
    return main_type() == MNN::OpParameter_QuantizeMaxMin ? static_cast<const MNN::QuantizeMaxMin *>(main()) : nullptr;
  }
  const MNN::QuantizeV2 *main_as_QuantizeV2() const {
    return main_type() == MNN::OpParameter_QuantizeV2 ? static_cast<const MNN::QuantizeV2 *>(main()) : nullptr;
  }
  const MNN::Range *main_as_Range() const {
    return main_type() == MNN::OpParameter_Range ? static_cast<const MNN::Range *>(main()) : nullptr;
  }
  const MNN::Rank *main_as_Rank() const {
    return main_type() == MNN::OpParameter_Rank ? static_cast<const MNN::Rank *>(main()) : nullptr;
  }
  const MNN::ReduceJoin *main_as_ReduceJoin() const {
    return main_type() == MNN::OpParameter_ReduceJoin ? static_cast<const MNN::ReduceJoin *>(main()) : nullptr;
  }
  const MNN::ReductionParam *main_as_ReductionParam() const {
    return main_type() == MNN::OpParameter_ReductionParam ? static_cast<const MNN::ReductionParam *>(main()) : nullptr;
  }
  const MNN::Relu *main_as_Relu() const {
    return main_type() == MNN::OpParameter_Relu ? static_cast<const MNN::Relu *>(main()) : nullptr;
  }
  const MNN::Relu6 *main_as_Relu6() const {
    return main_type() == MNN::OpParameter_Relu6 ? static_cast<const MNN::Relu6 *>(main()) : nullptr;
  }
  const MNN::RequantizationRange *main_as_RequantizationRange() const {
    return main_type() == MNN::OpParameter_RequantizationRange ? static_cast<const MNN::RequantizationRange *>(main()) : nullptr;
  }
  const MNN::Requantize *main_as_Requantize() const {
    return main_type() == MNN::OpParameter_Requantize ? static_cast<const MNN::Requantize *>(main()) : nullptr;
  }
  const MNN::Reshape *main_as_Reshape() const {
    return main_type() == MNN::OpParameter_Reshape ? static_cast<const MNN::Reshape *>(main()) : nullptr;
  }
  const MNN::Resize *main_as_Resize() const {
    return main_type() == MNN::OpParameter_Resize ? static_cast<const MNN::Resize *>(main()) : nullptr;
  }
  const MNN::RoiParameters *main_as_RoiParameters() const {
    return main_type() == MNN::OpParameter_RoiParameters ? static_cast<const MNN::RoiParameters *>(main()) : nullptr;
  }
  const MNN::Scale *main_as_Scale() const {
    return main_type() == MNN::OpParameter_Scale ? static_cast<const MNN::Scale *>(main()) : nullptr;
  }
  const MNN::Selu *main_as_Selu() const {
    return main_type() == MNN::OpParameter_Selu ? static_cast<const MNN::Selu *>(main()) : nullptr;
  }
  const MNN::Size *main_as_Size() const {
    return main_type() == MNN::OpParameter_Size ? static_cast<const MNN::Size *>(main()) : nullptr;
  }
  const MNN::Slice *main_as_Slice() const {
    return main_type() == MNN::OpParameter_Slice ? static_cast<const MNN::Slice *>(main()) : nullptr;
  }
  const MNN::SliceTf *main_as_SliceTf() const {
    return main_type() == MNN::OpParameter_SliceTf ? static_cast<const MNN::SliceTf *>(main()) : nullptr;
  }
  const MNN::SpaceBatch *main_as_SpaceBatch() const {
    return main_type() == MNN::OpParameter_SpaceBatch ? static_cast<const MNN::SpaceBatch *>(main()) : nullptr;
  }
  const MNN::SqueezeParam *main_as_SqueezeParam() const {
    return main_type() == MNN::OpParameter_SqueezeParam ? static_cast<const MNN::SqueezeParam *>(main()) : nullptr;
  }
  const MNN::StridedSliceParam *main_as_StridedSliceParam() const {
    return main_type() == MNN::OpParameter_StridedSliceParam ? static_cast<const MNN::StridedSliceParam *>(main()) : nullptr;
  }
  const MNN::TensorConvertInfo *main_as_TensorConvertInfo() const {
    return main_type() == MNN::OpParameter_TensorConvertInfo ? static_cast<const MNN::TensorConvertInfo *>(main()) : nullptr;
  }
  const MNN::TfQuantizedConv2D *main_as_TfQuantizedConv2D() const {
    return main_type() == MNN::OpParameter_TfQuantizedConv2D ? static_cast<const MNN::TfQuantizedConv2D *>(main()) : nullptr;
  }
  const MNN::TopKV2 *main_as_TopKV2() const {
    return main_type() == MNN::OpParameter_TopKV2 ? static_cast<const MNN::TopKV2 *>(main()) : nullptr;
  }
  const MNN::Transpose *main_as_Transpose() const {
    return main_type() == MNN::OpParameter_Transpose ? static_cast<const MNN::Transpose *>(main()) : nullptr;
  }
  const MNN::UnaryOp *main_as_UnaryOp() const {
    return main_type() == MNN::OpParameter_UnaryOp ? static_cast<const MNN::UnaryOp *>(main()) : nullptr;
  }
  const MNN::MomentsParam *main_as_MomentsParam() const {
    return main_type() == MNN::OpParameter_MomentsParam ? static_cast<const MNN::MomentsParam *>(main()) : nullptr;
  }
  const MNN::RNNParam *main_as_RNNParam() const {
    return main_type() == MNN::OpParameter_RNNParam ? static_cast<const MNN::RNNParam *>(main()) : nullptr;
  }
  const MNN::BatchMatMulParam *main_as_BatchMatMulParam() const {
    return main_type() == MNN::OpParameter_BatchMatMulParam ? static_cast<const MNN::BatchMatMulParam *>(main()) : nullptr;
  }
  const MNN::QuantizedFloatParam *main_as_QuantizedFloatParam() const {
    return main_type() == MNN::OpParameter_QuantizedFloatParam ? static_cast<const MNN::QuantizedFloatParam *>(main()) : nullptr;
  }
  const MNN::DepthSpaceParam *main_as_DepthSpaceParam() const {
    return main_type() == MNN::OpParameter_DepthSpaceParam ? static_cast<const MNN::DepthSpaceParam *>(main()) : nullptr;
  }
  const MNN::EltwiseInt8 *main_as_EltwiseInt8() const {
    return main_type() == MNN::OpParameter_EltwiseInt8 ? static_cast<const MNN::EltwiseInt8 *>(main()) : nullptr;
  }
  const MNN::ReverseSequenceParam *main_as_ReverseSequenceParam() const {
    return main_type() == MNN::OpParameter_ReverseSequenceParam ? static_cast<const MNN::ReverseSequenceParam *>(main()) : nullptr;
  }
  const MNN::Extra *main_as_Extra() const {
    return main_type() == MNN::OpParameter_Extra ? static_cast<const MNN::Extra *>(main()) : nullptr;
  }
  const MNN::Pool3D *main_as_Pool3D() const {
    return main_type() == MNN::OpParameter_Pool3D ? static_cast<const MNN::Pool3D *>(main()) : nullptr;
  }
  const MNN::Convolution3D *main_as_Convolution3D() const {
    return main_type() == MNN::OpParameter_Convolution3D ? static_cast<const MNN::Convolution3D *>(main()) : nullptr;
  }
  const MNN::ELU *main_as_ELU() const {
    return main_type() == MNN::OpParameter_ELU ? static_cast<const MNN::ELU *>(main()) : nullptr;
  }
  const MNN::DetectionPostProcessParam *main_as_DetectionPostProcessParam() const {
    return main_type() == MNN::OpParameter_DetectionPostProcessParam ? static_cast<const MNN::DetectionPostProcessParam *>(main()) : nullptr;
  }
  const MNN::OneHotParam *main_as_OneHotParam() const {
    return main_type() == MNN::OpParameter_OneHotParam ? static_cast<const MNN::OneHotParam *>(main()) : nullptr;
  }
  const MNN::PadParam *main_as_PadParam() const {
    return main_type() == MNN::OpParameter_PadParam ? static_cast<const MNN::PadParam *>(main()) : nullptr;
  }
  const MNN::WhileParam *main_as_WhileParam() const {
    return main_type() == MNN::OpParameter_WhileParam ? static_cast<const MNN::WhileParam *>(main()) : nullptr;
  }
  const MNN::IfParam *main_as_IfParam() const {
    return main_type() == MNN::OpParameter_IfParam ? static_cast<const MNN::IfParam *>(main()) : nullptr;
  }
  const MNN::RandomUniform *main_as_RandomUniform() const {
    return main_type() == MNN::OpParameter_RandomUniform ? static_cast<const MNN::RandomUniform *>(main()) : nullptr;
  }
  const MNN::LayerNorm *main_as_LayerNorm() const {
    return main_type() == MNN::OpParameter_LayerNorm ? static_cast<const MNN::LayerNorm *>(main()) : nullptr;
  }
  const MNN::TensorArray *main_as_TensorArray() const {
    return main_type() == MNN::OpParameter_TensorArray ? static_cast<const MNN::TensorArray *>(main()) : nullptr;
  }
  const MNN::LSTMBlockCell *main_as_LSTMBlockCell() const {
    return main_type() == MNN::OpParameter_LSTMBlockCell ? static_cast<const MNN::LSTMBlockCell *>(main()) : nullptr;
  }
  const MNN::GridSample *main_as_GridSample() const {
    return main_type() == MNN::OpParameter_GridSample ? static_cast<const MNN::GridSample *>(main()) : nullptr;
  }
  const MNN::LoopParam *main_as_LoopParam() const {
    return main_type() == MNN::OpParameter_LoopParam ? static_cast<const MNN::LoopParam *>(main()) : nullptr;
  }
  const MNN::ImageProcessParam *main_as_ImageProcessParam() const {
    return main_type() == MNN::OpParameter_ImageProcessParam ? static_cast<const MNN::ImageProcessParam *>(main()) : nullptr;
  }
  const MNN::CumSum *main_as_CumSum() const {
    return main_type() == MNN::OpParameter_CumSum ? static_cast<const MNN::CumSum *>(main()) : nullptr;
  }
  const MNN::GroupNorm *main_as_GroupNorm() const {
    return main_type() == MNN::OpParameter_GroupNorm ? static_cast<const MNN::GroupNorm *>(main()) : nullptr;
  }
  const MNN::FmhaV2Param *main_as_FmhaV2Param() const {
    return main_type() == MNN::OpParameter_FmhaV2Param ? static_cast<const MNN::FmhaV2Param *>(main()) : nullptr;
  }
  const MNN::FmhcaParam *main_as_FmhcaParam() const {
    return main_type() == MNN::OpParameter_FmhcaParam ? static_cast<const MNN::FmhcaParam *>(main()) : nullptr;
  }
  const MNN::AttentionParam *main_as_AttentionParam() const {
    return main_type() == MNN::OpParameter_AttentionParam ? static_cast<const MNN::AttentionParam *>(main()) : nullptr;
  }
  const MNN::StftParam *main_as_StftParam() const {
    return main_type() == MNN::OpParameter_StftParam ? static_cast<const MNN::StftParam *>(main()) : nullptr;
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<int32_t> *outputIndexes() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTINDEXES);
  }
  MNN::OpType type() const {
    return static_cast<MNN::OpType>(GetField<int32_t>(VT_TYPE, 0));
  }
  MNN::MNN_DATA_FORMAT defaultDimentionFormat() const {
    return static_cast<MNN::MNN_DATA_FORMAT>(GetField<int8_t>(VT_DEFAULTDIMENTIONFORMAT, 1));
  }
  const ::flatbuffers::String *externalPath() const {
    return GetPointer<const ::flatbuffers::String *>(VT_EXTERNALPATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUTINDEXES) &&
           verifier.VerifyVector(inputIndexes()) &&
           VerifyField<uint8_t>(verifier, VT_MAIN_TYPE, 1) &&
           VerifyOffset(verifier, VT_MAIN) &&
           VerifyOpParameter(verifier, main(), main_type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEXES) &&
           verifier.VerifyVector(outputIndexes()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<int8_t>(verifier, VT_DEFAULTDIMENTIONFORMAT, 1) &&
           VerifyOffset(verifier, VT_EXTERNALPATH) &&
           verifier.VerifyString(externalPath()) &&
           verifier.EndTable();
  }
};

template<> inline const MNN::QuantizedAdd *Op::main_as<MNN::QuantizedAdd>() const {
  return main_as_QuantizedAdd();
}

template<> inline const MNN::ArgMax *Op::main_as<MNN::ArgMax>() const {
  return main_as_ArgMax();
}

template<> inline const MNN::AsString *Op::main_as<MNN::AsString>() const {
  return main_as_AsString();
}

template<> inline const MNN::Axis *Op::main_as<MNN::Axis>() const {
  return main_as_Axis();
}

template<> inline const MNN::BatchNorm *Op::main_as<MNN::BatchNorm>() const {
  return main_as_BatchNorm();
}

template<> inline const MNN::BinaryOp *Op::main_as<MNN::BinaryOp>() const {
  return main_as_BinaryOp();
}

template<> inline const MNN::Blob *Op::main_as<MNN::Blob>() const {
  return main_as_Blob();
}

template<> inline const MNN::CastParam *Op::main_as<MNN::CastParam>() const {
  return main_as_CastParam();
}

template<> inline const MNN::Convolution2D *Op::main_as<MNN::Convolution2D>() const {
  return main_as_Convolution2D();
}

template<> inline const MNN::Crop *Op::main_as<MNN::Crop>() const {
  return main_as_Crop();
}

template<> inline const MNN::CropAndResize *Op::main_as<MNN::CropAndResize>() const {
  return main_as_CropAndResize();
}

template<> inline const MNN::Dequantize *Op::main_as<MNN::Dequantize>() const {
  return main_as_Dequantize();
}

template<> inline const MNN::DetectionOutput *Op::main_as<MNN::DetectionOutput>() const {
  return main_as_DetectionOutput();
}

template<> inline const MNN::Eltwise *Op::main_as<MNN::Eltwise>() const {
  return main_as_Eltwise();
}

template<> inline const MNN::ExpandDims *Op::main_as<MNN::ExpandDims>() const {
  return main_as_ExpandDims();
}

template<> inline const MNN::Fill *Op::main_as<MNN::Fill>() const {
  return main_as_Fill();
}

template<> inline const MNN::Flatten *Op::main_as<MNN::Flatten>() const {
  return main_as_Flatten();
}

template<> inline const MNN::Gather *Op::main_as<MNN::Gather>() const {
  return main_as_Gather();
}

template<> inline const MNN::GatherV2 *Op::main_as<MNN::GatherV2>() const {
  return main_as_GatherV2();
}

template<> inline const MNN::InnerProduct *Op::main_as<MNN::InnerProduct>() const {
  return main_as_InnerProduct();
}

template<> inline const MNN::Input *Op::main_as<MNN::Input>() const {
  return main_as_Input();
}

template<> inline const MNN::Interp *Op::main_as<MNN::Interp>() const {
  return main_as_Interp();
}

template<> inline const MNN::LRN *Op::main_as<MNN::LRN>() const {
  return main_as_LRN();
}

template<> inline const MNN::LSTM *Op::main_as<MNN::LSTM>() const {
  return main_as_LSTM();
}

template<> inline const MNN::MatMul *Op::main_as<MNN::MatMul>() const {
  return main_as_MatMul();
}

template<> inline const MNN::NonMaxSuppressionV2 *Op::main_as<MNN::NonMaxSuppressionV2>() const {
  return main_as_NonMaxSuppressionV2();
}

template<> inline const MNN::Normalize *Op::main_as<MNN::Normalize>() const {
  return main_as_Normalize();
}

template<> inline const MNN::PackParam *Op::main_as<MNN::PackParam>() const {
  return main_as_PackParam();
}

template<> inline const MNN::Permute *Op::main_as<MNN::Permute>() const {
  return main_as_Permute();
}

template<> inline const MNN::Plugin *Op::main_as<MNN::Plugin>() const {
  return main_as_Plugin();
}

template<> inline const MNN::Pool *Op::main_as<MNN::Pool>() const {
  return main_as_Pool();
}

template<> inline const MNN::PRelu *Op::main_as<MNN::PRelu>() const {
  return main_as_PRelu();
}

template<> inline const MNN::PriorBox *Op::main_as<MNN::PriorBox>() const {
  return main_as_PriorBox();
}

template<> inline const MNN::Proposal *Op::main_as<MNN::Proposal>() const {
  return main_as_Proposal();
}

template<> inline const MNN::QuantizedAvgPool *Op::main_as<MNN::QuantizedAvgPool>() const {
  return main_as_QuantizedAvgPool();
}

template<> inline const MNN::QuantizedBiasAdd *Op::main_as<MNN::QuantizedBiasAdd>() const {
  return main_as_QuantizedBiasAdd();
}

template<> inline const MNN::QuantizedConcat *Op::main_as<MNN::QuantizedConcat>() const {
  return main_as_QuantizedConcat();
}

template<> inline const MNN::QuantizedLogistic *Op::main_as<MNN::QuantizedLogistic>() const {
  return main_as_QuantizedLogistic();
}

template<> inline const MNN::QuantizedMatMul *Op::main_as<MNN::QuantizedMatMul>() const {
  return main_as_QuantizedMatMul();
}

template<> inline const MNN::QuantizedMaxPool *Op::main_as<MNN::QuantizedMaxPool>() const {
  return main_as_QuantizedMaxPool();
}

template<> inline const MNN::QuantizedRelu *Op::main_as<MNN::QuantizedRelu>() const {
  return main_as_QuantizedRelu();
}

template<> inline const MNN::QuantizedRelu6 *Op::main_as<MNN::QuantizedRelu6>() const {
  return main_as_QuantizedRelu6();
}

template<> inline const MNN::QuantizedReshape *Op::main_as<MNN::QuantizedReshape>() const {
  return main_as_QuantizedReshape();
}

template<> inline const MNN::QuantizedSoftmax *Op::main_as<MNN::QuantizedSoftmax>() const {
  return main_as_QuantizedSoftmax();
}

template<> inline const MNN::QuantizeMaxMin *Op::main_as<MNN::QuantizeMaxMin>() const {
  return main_as_QuantizeMaxMin();
}

template<> inline const MNN::QuantizeV2 *Op::main_as<MNN::QuantizeV2>() const {
  return main_as_QuantizeV2();
}

template<> inline const MNN::Range *Op::main_as<MNN::Range>() const {
  return main_as_Range();
}

template<> inline const MNN::Rank *Op::main_as<MNN::Rank>() const {
  return main_as_Rank();
}

template<> inline const MNN::ReduceJoin *Op::main_as<MNN::ReduceJoin>() const {
  return main_as_ReduceJoin();
}

template<> inline const MNN::ReductionParam *Op::main_as<MNN::ReductionParam>() const {
  return main_as_ReductionParam();
}

template<> inline const MNN::Relu *Op::main_as<MNN::Relu>() const {
  return main_as_Relu();
}

template<> inline const MNN::Relu6 *Op::main_as<MNN::Relu6>() const {
  return main_as_Relu6();
}

template<> inline const MNN::RequantizationRange *Op::main_as<MNN::RequantizationRange>() const {
  return main_as_RequantizationRange();
}

template<> inline const MNN::Requantize *Op::main_as<MNN::Requantize>() const {
  return main_as_Requantize();
}

template<> inline const MNN::Reshape *Op::main_as<MNN::Reshape>() const {
  return main_as_Reshape();
}

template<> inline const MNN::Resize *Op::main_as<MNN::Resize>() const {
  return main_as_Resize();
}

template<> inline const MNN::RoiParameters *Op::main_as<MNN::RoiParameters>() const {
  return main_as_RoiParameters();
}

template<> inline const MNN::Scale *Op::main_as<MNN::Scale>() const {
  return main_as_Scale();
}

template<> inline const MNN::Selu *Op::main_as<MNN::Selu>() const {
  return main_as_Selu();
}

template<> inline const MNN::Size *Op::main_as<MNN::Size>() const {
  return main_as_Size();
}

template<> inline const MNN::Slice *Op::main_as<MNN::Slice>() const {
  return main_as_Slice();
}

template<> inline const MNN::SliceTf *Op::main_as<MNN::SliceTf>() const {
  return main_as_SliceTf();
}

template<> inline const MNN::SpaceBatch *Op::main_as<MNN::SpaceBatch>() const {
  return main_as_SpaceBatch();
}

template<> inline const MNN::SqueezeParam *Op::main_as<MNN::SqueezeParam>() const {
  return main_as_SqueezeParam();
}

template<> inline const MNN::StridedSliceParam *Op::main_as<MNN::StridedSliceParam>() const {
  return main_as_StridedSliceParam();
}

template<> inline const MNN::TensorConvertInfo *Op::main_as<MNN::TensorConvertInfo>() const {
  return main_as_TensorConvertInfo();
}

template<> inline const MNN::TfQuantizedConv2D *Op::main_as<MNN::TfQuantizedConv2D>() const {
  return main_as_TfQuantizedConv2D();
}

template<> inline const MNN::TopKV2 *Op::main_as<MNN::TopKV2>() const {
  return main_as_TopKV2();
}

template<> inline const MNN::Transpose *Op::main_as<MNN::Transpose>() const {
  return main_as_Transpose();
}

template<> inline const MNN::UnaryOp *Op::main_as<MNN::UnaryOp>() const {
  return main_as_UnaryOp();
}

template<> inline const MNN::MomentsParam *Op::main_as<MNN::MomentsParam>() const {
  return main_as_MomentsParam();
}

template<> inline const MNN::RNNParam *Op::main_as<MNN::RNNParam>() const {
  return main_as_RNNParam();
}

template<> inline const MNN::BatchMatMulParam *Op::main_as<MNN::BatchMatMulParam>() const {
  return main_as_BatchMatMulParam();
}

template<> inline const MNN::QuantizedFloatParam *Op::main_as<MNN::QuantizedFloatParam>() const {
  return main_as_QuantizedFloatParam();
}

template<> inline const MNN::DepthSpaceParam *Op::main_as<MNN::DepthSpaceParam>() const {
  return main_as_DepthSpaceParam();
}

template<> inline const MNN::EltwiseInt8 *Op::main_as<MNN::EltwiseInt8>() const {
  return main_as_EltwiseInt8();
}

template<> inline const MNN::ReverseSequenceParam *Op::main_as<MNN::ReverseSequenceParam>() const {
  return main_as_ReverseSequenceParam();
}

template<> inline const MNN::Extra *Op::main_as<MNN::Extra>() const {
  return main_as_Extra();
}

template<> inline const MNN::Pool3D *Op::main_as<MNN::Pool3D>() const {
  return main_as_Pool3D();
}

template<> inline const MNN::Convolution3D *Op::main_as<MNN::Convolution3D>() const {
  return main_as_Convolution3D();
}

template<> inline const MNN::ELU *Op::main_as<MNN::ELU>() const {
  return main_as_ELU();
}

template<> inline const MNN::DetectionPostProcessParam *Op::main_as<MNN::DetectionPostProcessParam>() const {
  return main_as_DetectionPostProcessParam();
}

template<> inline const MNN::OneHotParam *Op::main_as<MNN::OneHotParam>() const {
  return main_as_OneHotParam();
}

template<> inline const MNN::PadParam *Op::main_as<MNN::PadParam>() const {
  return main_as_PadParam();
}

template<> inline const MNN::WhileParam *Op::main_as<MNN::WhileParam>() const {
  return main_as_WhileParam();
}

template<> inline const MNN::IfParam *Op::main_as<MNN::IfParam>() const {
  return main_as_IfParam();
}

template<> inline const MNN::RandomUniform *Op::main_as<MNN::RandomUniform>() const {
  return main_as_RandomUniform();
}

template<> inline const MNN::LayerNorm *Op::main_as<MNN::LayerNorm>() const {
  return main_as_LayerNorm();
}

template<> inline const MNN::TensorArray *Op::main_as<MNN::TensorArray>() const {
  return main_as_TensorArray();
}

template<> inline const MNN::LSTMBlockCell *Op::main_as<MNN::LSTMBlockCell>() const {
  return main_as_LSTMBlockCell();
}

template<> inline const MNN::GridSample *Op::main_as<MNN::GridSample>() const {
  return main_as_GridSample();
}

template<> inline const MNN::LoopParam *Op::main_as<MNN::LoopParam>() const {
  return main_as_LoopParam();
}

template<> inline const MNN::ImageProcessParam *Op::main_as<MNN::ImageProcessParam>() const {
  return main_as_ImageProcessParam();
}

template<> inline const MNN::CumSum *Op::main_as<MNN::CumSum>() const {
  return main_as_CumSum();
}

template<> inline const MNN::GroupNorm *Op::main_as<MNN::GroupNorm>() const {
  return main_as_GroupNorm();
}

template<> inline const MNN::FmhaV2Param *Op::main_as<MNN::FmhaV2Param>() const {
  return main_as_FmhaV2Param();
}

template<> inline const MNN::FmhcaParam *Op::main_as<MNN::FmhcaParam>() const {
  return main_as_FmhcaParam();
}

template<> inline const MNN::AttentionParam *Op::main_as<MNN::AttentionParam>() const {
  return main_as_AttentionParam();
}

template<> inline const MNN::StftParam *Op::main_as<MNN::StftParam>() const {
  return main_as_StftParam();
}

struct OpBuilder {
  typedef Op Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_inputIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputIndexes) {
    fbb_.AddOffset(Op::VT_INPUTINDEXES, inputIndexes);
  }
  void add_main_type(MNN::OpParameter main_type) {
    fbb_.AddElement<uint8_t>(Op::VT_MAIN_TYPE, static_cast<uint8_t>(main_type), 0);
  }
  void add_main(::flatbuffers::Offset<void> main) {
    fbb_.AddOffset(Op::VT_MAIN, main);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Op::VT_NAME, name);
  }
  void add_outputIndexes(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputIndexes) {
    fbb_.AddOffset(Op::VT_OUTPUTINDEXES, outputIndexes);
  }
  void add_type(MNN::OpType type) {
    fbb_.AddElement<int32_t>(Op::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  void add_defaultDimentionFormat(MNN::MNN_DATA_FORMAT defaultDimentionFormat) {
    fbb_.AddElement<int8_t>(Op::VT_DEFAULTDIMENTIONFORMAT, static_cast<int8_t>(defaultDimentionFormat), 1);
  }
  void add_externalPath(::flatbuffers::Offset<::flatbuffers::String> externalPath) {
    fbb_.AddOffset(Op::VT_EXTERNALPATH, externalPath);
  }
  explicit OpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Op> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Op>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Op> CreateOp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputIndexes = 0,
    MNN::OpParameter main_type = MNN::OpParameter_NONE,
    ::flatbuffers::Offset<void> main = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputIndexes = 0,
    MNN::OpType type = MNN::OpType_AbsVal,
    MNN::MNN_DATA_FORMAT defaultDimentionFormat = MNN::MNN_DATA_FORMAT_NHWC,
    ::flatbuffers::Offset<::flatbuffers::String> externalPath = 0) {
  OpBuilder builder_(_fbb);
  builder_.add_externalPath(externalPath);
  builder_.add_type(type);
  builder_.add_outputIndexes(outputIndexes);
  builder_.add_name(name);
  builder_.add_main(main);
  builder_.add_inputIndexes(inputIndexes);
  builder_.add_defaultDimentionFormat(defaultDimentionFormat);
  builder_.add_main_type(main_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Op> CreateOpDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *inputIndexes = nullptr,
    MNN::OpParameter main_type = MNN::OpParameter_NONE,
    ::flatbuffers::Offset<void> main = 0,
    const char *name = nullptr,
    const std::vector<int32_t> *outputIndexes = nullptr,
    MNN::OpType type = MNN::OpType_AbsVal,
    MNN::MNN_DATA_FORMAT defaultDimentionFormat = MNN::MNN_DATA_FORMAT_NHWC,
    const char *externalPath = nullptr) {
  auto inputIndexes__ = inputIndexes ? _fbb.CreateVector<int32_t>(*inputIndexes) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto outputIndexes__ = outputIndexes ? _fbb.CreateVector<int32_t>(*outputIndexes) : 0;
  auto externalPath__ = externalPath ? _fbb.CreateString(externalPath) : 0;
  return MNN::CreateOp(
      _fbb,
      inputIndexes__,
      main_type,
      main,
      name__,
      outputIndexes__,
      type,
      defaultDimentionFormat,
      externalPath__);
}

struct View FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ViewBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OFFSET = 4,
    VT_STRIDE = 6
  };
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const ::flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OFFSET, 4) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           verifier.EndTable();
  }
};

struct ViewBuilder {
  typedef View Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(View::VT_OFFSET, offset, 0);
  }
  void add_stride(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(View::VT_STRIDE, stride);
  }
  explicit ViewBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<View> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<View>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<View> CreateView(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> stride = 0) {
  ViewBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_offset(offset);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<View> CreateViewDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t offset = 0,
    const std::vector<int32_t> *stride = nullptr) {
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  return MNN::CreateView(
      _fbb,
      offset,
      stride__);
}

struct Region FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RegionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC = 4,
    VT_DST = 6,
    VT_SIZE = 8,
    VT_ORIGIN = 10
  };
  const MNN::View *src() const {
    return GetPointer<const MNN::View *>(VT_SRC);
  }
  const MNN::View *dst() const {
    return GetPointer<const MNN::View *>(VT_DST);
  }
  const ::flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  int32_t origin() const {
    return GetField<int32_t>(VT_ORIGIN, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.VerifyTable(src()) &&
           VerifyOffset(verifier, VT_DST) &&
           verifier.VerifyTable(dst()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           VerifyField<int32_t>(verifier, VT_ORIGIN, 4) &&
           verifier.EndTable();
  }
};

struct RegionBuilder {
  typedef Region Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_src(::flatbuffers::Offset<MNN::View> src) {
    fbb_.AddOffset(Region::VT_SRC, src);
  }
  void add_dst(::flatbuffers::Offset<MNN::View> dst) {
    fbb_.AddOffset(Region::VT_DST, dst);
  }
  void add_size(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Region::VT_SIZE, size);
  }
  void add_origin(int32_t origin) {
    fbb_.AddElement<int32_t>(Region::VT_ORIGIN, origin, 0);
  }
  explicit RegionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Region> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Region>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Region> CreateRegion(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::View> src = 0,
    ::flatbuffers::Offset<MNN::View> dst = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> size = 0,
    int32_t origin = 0) {
  RegionBuilder builder_(_fbb);
  builder_.add_origin(origin);
  builder_.add_size(size);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Region> CreateRegionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::View> src = 0,
    ::flatbuffers::Offset<MNN::View> dst = 0,
    const std::vector<int32_t> *size = nullptr,
    int32_t origin = 0) {
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  return MNN::CreateRegion(
      _fbb,
      src,
      dst,
      size__,
      origin);
}

struct TensorDescribe FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorDescribeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOB = 4,
    VT_INDEX = 6,
    VT_NAME = 8,
    VT_REGIONS = 10,
    VT_QUANTINFO = 12
  };
  const MNN::Blob *blob() const {
    return GetPointer<const MNN::Blob *>(VT_BLOB);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Region>> *regions() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Region>> *>(VT_REGIONS);
  }
  const MNN::TensorQuantInfo *quantInfo() const {
    return GetPointer<const MNN::TensorQuantInfo *>(VT_QUANTINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOB) &&
           verifier.VerifyTable(blob()) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_REGIONS) &&
           verifier.VerifyVector(regions()) &&
           verifier.VerifyVectorOfTables(regions()) &&
           VerifyOffset(verifier, VT_QUANTINFO) &&
           verifier.VerifyTable(quantInfo()) &&
           verifier.EndTable();
  }
};

struct TensorDescribeBuilder {
  typedef TensorDescribe Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blob(::flatbuffers::Offset<MNN::Blob> blob) {
    fbb_.AddOffset(TensorDescribe::VT_BLOB, blob);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(TensorDescribe::VT_INDEX, index, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(TensorDescribe::VT_NAME, name);
  }
  void add_regions(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Region>>> regions) {
    fbb_.AddOffset(TensorDescribe::VT_REGIONS, regions);
  }
  void add_quantInfo(::flatbuffers::Offset<MNN::TensorQuantInfo> quantInfo) {
    fbb_.AddOffset(TensorDescribe::VT_QUANTINFO, quantInfo);
  }
  explicit TensorDescribeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorDescribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorDescribe>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Blob> blob = 0,
    int32_t index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Region>>> regions = 0,
    ::flatbuffers::Offset<MNN::TensorQuantInfo> quantInfo = 0) {
  TensorDescribeBuilder builder_(_fbb);
  builder_.add_quantInfo(quantInfo);
  builder_.add_regions(regions);
  builder_.add_name(name);
  builder_.add_index(index);
  builder_.add_blob(blob);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorDescribe> CreateTensorDescribeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Blob> blob = 0,
    int32_t index = 0,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::Region>> *regions = nullptr,
    ::flatbuffers::Offset<MNN::TensorQuantInfo> quantInfo = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto regions__ = regions ? _fbb.CreateVector<::flatbuffers::Offset<MNN::Region>>(*regions) : 0;
  return MNN::CreateTensorDescribe(
      _fbb,
      blob,
      index,
      name__,
      regions__,
      quantInfo);
}

struct SubGraphProto FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubGraphProtoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_TENSORS = 10,
    VT_NODES = 12,
    VT_EXTRATENSORDESCRIBE = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>> *extraTensorDescribe() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>> *>(VT_EXTRATENSORDESCRIBE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfStrings(tensors()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_EXTRATENSORDESCRIBE) &&
           verifier.VerifyVector(extraTensorDescribe()) &&
           verifier.VerifyVectorOfTables(extraTensorDescribe()) &&
           verifier.EndTable();
  }
};

struct SubGraphProtoBuilder {
  typedef SubGraphProto Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SubGraphProto::VT_NAME, name);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraphProto::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraphProto::VT_OUTPUTS, outputs);
  }
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensors) {
    fbb_.AddOffset(SubGraphProto::VT_TENSORS, tensors);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>>> nodes) {
    fbb_.AddOffset(SubGraphProto::VT_NODES, nodes);
  }
  void add_extraTensorDescribe(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>>> extraTensorDescribe) {
    fbb_.AddOffset(SubGraphProto::VT_EXTRATENSORDESCRIBE, extraTensorDescribe);
  }
  explicit SubGraphProtoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubGraphProto> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubGraphProto>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubGraphProto> CreateSubGraphProto(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>>> extraTensorDescribe = 0) {
  SubGraphProtoBuilder builder_(_fbb);
  builder_.add_extraTensorDescribe(extraTensorDescribe);
  builder_.add_nodes(nodes);
  builder_.add_tensors(tensors);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubGraphProto> CreateSubGraphProtoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tensors = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::Op>> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::TensorDescribe>> *extraTensorDescribe = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tensors) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<MNN::Op>>(*nodes) : 0;
  auto extraTensorDescribe__ = extraTensorDescribe ? _fbb.CreateVector<::flatbuffers::Offset<MNN::TensorDescribe>>(*extraTensorDescribe) : 0;
  return MNN::CreateSubGraphProto(
      _fbb,
      name__,
      inputs__,
      outputs__,
      tensors__,
      nodes__,
      extraTensorDescribe__);
}

struct TensorQuantInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorQuantInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZERO = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_TYPE = 12
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float zero() const {
    return GetField<float>(VT_ZERO, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, -128.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 127.0f);
  }
  MNN::DataType type() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<float>(verifier, VT_ZERO, 4) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
};

struct TensorQuantInfoBuilder {
  typedef TensorQuantInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_SCALE, scale, 0.0f);
  }
  void add_zero(float zero) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_ZERO, zero, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_MIN, min, -128.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_MAX, max, 127.0f);
  }
  void add_type(MNN::DataType type) {
    fbb_.AddElement<int32_t>(TensorQuantInfo::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit TensorQuantInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorQuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorQuantInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float zero = 0.0f,
    float min = -128.0f,
    float max = 127.0f,
    MNN::DataType type = MNN::DataType_DT_INVALID) {
  TensorQuantInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_zero(zero);
  builder_.add_scale(scale);
  return builder_.Finish();
}

struct Net FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NetBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIZCODE = 4,
    VT_EXTRATENSORDESCRIBE = 6,
    VT_EXTRAINFO = 8,
    VT_OPLISTS = 10,
    VT_OUTPUTNAME = 12,
    VT_PREFERFORWARDTYPE = 14,
    VT_SOURCETYPE = 16,
    VT_TENSORNAME = 18,
    VT_TENSORNUMBER = 20,
    VT_USAGE = 22,
    VT_SUBGRAPHS = 24,
    VT_MNN_UUID = 26
  };
  const ::flatbuffers::String *bizCode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_BIZCODE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>> *extraTensorDescribe() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>> *>(VT_EXTRATENSORDESCRIBE);
  }
  const MNN::ExtraInfo *extraInfo() const {
    return GetPointer<const MNN::ExtraInfo *>(VT_EXTRAINFO);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>> *oplists() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>> *>(VT_OPLISTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *outputName() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_OUTPUTNAME);
  }
  MNN::ForwardType preferForwardType() const {
    return static_cast<MNN::ForwardType>(GetField<int8_t>(VT_PREFERFORWARDTYPE, 0));
  }
  MNN::NetSource sourceType() const {
    return static_cast<MNN::NetSource>(GetField<int8_t>(VT_SOURCETYPE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *tensorName() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_TENSORNAME);
  }
  int32_t tensorNumber() const {
    return GetField<int32_t>(VT_TENSORNUMBER, 0);
  }
  MNN::Usage usage() const {
    return static_cast<MNN::Usage>(GetField<int8_t>(VT_USAGE, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::SubGraphProto>> *subgraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::SubGraphProto>> *>(VT_SUBGRAPHS);
  }
  const ::flatbuffers::String *mnn_uuid() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MNN_UUID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BIZCODE) &&
           verifier.VerifyString(bizCode()) &&
           VerifyOffset(verifier, VT_EXTRATENSORDESCRIBE) &&
           verifier.VerifyVector(extraTensorDescribe()) &&
           verifier.VerifyVectorOfTables(extraTensorDescribe()) &&
           VerifyOffset(verifier, VT_EXTRAINFO) &&
           verifier.VerifyTable(extraInfo()) &&
           VerifyOffset(verifier, VT_OPLISTS) &&
           verifier.VerifyVector(oplists()) &&
           verifier.VerifyVectorOfTables(oplists()) &&
           VerifyOffset(verifier, VT_OUTPUTNAME) &&
           verifier.VerifyVector(outputName()) &&
           verifier.VerifyVectorOfStrings(outputName()) &&
           VerifyField<int8_t>(verifier, VT_PREFERFORWARDTYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_SOURCETYPE, 1) &&
           VerifyOffset(verifier, VT_TENSORNAME) &&
           verifier.VerifyVector(tensorName()) &&
           verifier.VerifyVectorOfStrings(tensorName()) &&
           VerifyField<int32_t>(verifier, VT_TENSORNUMBER, 4) &&
           VerifyField<int8_t>(verifier, VT_USAGE, 1) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_MNN_UUID) &&
           verifier.VerifyString(mnn_uuid()) &&
           verifier.EndTable();
  }
};

struct NetBuilder {
  typedef Net Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_bizCode(::flatbuffers::Offset<::flatbuffers::String> bizCode) {
    fbb_.AddOffset(Net::VT_BIZCODE, bizCode);
  }
  void add_extraTensorDescribe(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>>> extraTensorDescribe) {
    fbb_.AddOffset(Net::VT_EXTRATENSORDESCRIBE, extraTensorDescribe);
  }
  void add_extraInfo(::flatbuffers::Offset<MNN::ExtraInfo> extraInfo) {
    fbb_.AddOffset(Net::VT_EXTRAINFO, extraInfo);
  }
  void add_oplists(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>>> oplists) {
    fbb_.AddOffset(Net::VT_OPLISTS, oplists);
  }
  void add_outputName(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputName) {
    fbb_.AddOffset(Net::VT_OUTPUTNAME, outputName);
  }
  void add_preferForwardType(MNN::ForwardType preferForwardType) {
    fbb_.AddElement<int8_t>(Net::VT_PREFERFORWARDTYPE, static_cast<int8_t>(preferForwardType), 0);
  }
  void add_sourceType(MNN::NetSource sourceType) {
    fbb_.AddElement<int8_t>(Net::VT_SOURCETYPE, static_cast<int8_t>(sourceType), 0);
  }
  void add_tensorName(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensorName) {
    fbb_.AddOffset(Net::VT_TENSORNAME, tensorName);
  }
  void add_tensorNumber(int32_t tensorNumber) {
    fbb_.AddElement<int32_t>(Net::VT_TENSORNUMBER, tensorNumber, 0);
  }
  void add_usage(MNN::Usage usage) {
    fbb_.AddElement<int8_t>(Net::VT_USAGE, static_cast<int8_t>(usage), 0);
  }
  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::SubGraphProto>>> subgraphs) {
    fbb_.AddOffset(Net::VT_SUBGRAPHS, subgraphs);
  }
  void add_mnn_uuid(::flatbuffers::Offset<::flatbuffers::String> mnn_uuid) {
    fbb_.AddOffset(Net::VT_MNN_UUID, mnn_uuid);
  }
  explicit NetBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Net> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Net>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Net> CreateNet(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> bizCode = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::TensorDescribe>>> extraTensorDescribe = 0,
    ::flatbuffers::Offset<MNN::ExtraInfo> extraInfo = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Op>>> oplists = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> outputName = 0,
    MNN::ForwardType preferForwardType = MNN::ForwardType_CPU,
    MNN::NetSource sourceType = MNN::NetSource_CAFFE,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> tensorName = 0,
    int32_t tensorNumber = 0,
    MNN::Usage usage = MNN::Usage_INFERENCE,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::SubGraphProto>>> subgraphs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> mnn_uuid = 0) {
  NetBuilder builder_(_fbb);
  builder_.add_mnn_uuid(mnn_uuid);
  builder_.add_subgraphs(subgraphs);
  builder_.add_tensorNumber(tensorNumber);
  builder_.add_tensorName(tensorName);
  builder_.add_outputName(outputName);
  builder_.add_oplists(oplists);
  builder_.add_extraInfo(extraInfo);
  builder_.add_extraTensorDescribe(extraTensorDescribe);
  builder_.add_bizCode(bizCode);
  builder_.add_usage(usage);
  builder_.add_sourceType(sourceType);
  builder_.add_preferForwardType(preferForwardType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Net> CreateNetDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *bizCode = nullptr,
    const std::vector<::flatbuffers::Offset<MNN::TensorDescribe>> *extraTensorDescribe = nullptr,
    ::flatbuffers::Offset<MNN::ExtraInfo> extraInfo = 0,
    const std::vector<::flatbuffers::Offset<MNN::Op>> *oplists = nullptr,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *outputName = nullptr,
    MNN::ForwardType preferForwardType = MNN::ForwardType_CPU,
    MNN::NetSource sourceType = MNN::NetSource_CAFFE,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *tensorName = nullptr,
    int32_t tensorNumber = 0,
    MNN::Usage usage = MNN::Usage_INFERENCE,
    const std::vector<::flatbuffers::Offset<MNN::SubGraphProto>> *subgraphs = nullptr,
    const char *mnn_uuid = nullptr) {
  auto bizCode__ = bizCode ? _fbb.CreateString(bizCode) : 0;
  auto extraTensorDescribe__ = extraTensorDescribe ? _fbb.CreateVector<::flatbuffers::Offset<MNN::TensorDescribe>>(*extraTensorDescribe) : 0;
  auto oplists__ = oplists ? _fbb.CreateVector<::flatbuffers::Offset<MNN::Op>>(*oplists) : 0;
  auto outputName__ = outputName ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*outputName) : 0;
  auto tensorName__ = tensorName ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*tensorName) : 0;
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<MNN::SubGraphProto>>(*subgraphs) : 0;
  auto mnn_uuid__ = mnn_uuid ? _fbb.CreateString(mnn_uuid) : 0;
  return MNN::CreateNet(
      _fbb,
      bizCode__,
      extraTensorDescribe__,
      extraInfo,
      oplists__,
      outputName__,
      preferForwardType,
      sourceType,
      tensorName__,
      tensorNumber,
      usage,
      subgraphs__,
      mnn_uuid__);
}

inline bool VerifyOpParameter(::flatbuffers::Verifier &verifier, const void *obj, OpParameter type) {
  switch (type) {
    case OpParameter_NONE: {
      return true;
    }
    case OpParameter_QuantizedAdd: {
      auto ptr = reinterpret_cast<const MNN::QuantizedAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const MNN::ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_AsString: {
      auto ptr = reinterpret_cast<const MNN::AsString *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Axis: {
      auto ptr = reinterpret_cast<const MNN::Axis *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const MNN::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BinaryOp: {
      auto ptr = reinterpret_cast<const MNN::BinaryOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const MNN::Blob *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CastParam: {
      auto ptr = reinterpret_cast<const MNN::CastParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Convolution2D: {
      auto ptr = reinterpret_cast<const MNN::Convolution2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Crop: {
      auto ptr = reinterpret_cast<const MNN::Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CropAndResize: {
      auto ptr = reinterpret_cast<const MNN::CropAndResize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Dequantize: {
      auto ptr = reinterpret_cast<const MNN::Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DetectionOutput: {
      auto ptr = reinterpret_cast<const MNN::DetectionOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const MNN::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const MNN::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Fill: {
      auto ptr = reinterpret_cast<const MNN::Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const MNN::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const MNN::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GatherV2: {
      auto ptr = reinterpret_cast<const MNN::GatherV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_InnerProduct: {
      auto ptr = reinterpret_cast<const MNN::InnerProduct *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const MNN::Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Interp: {
      auto ptr = reinterpret_cast<const MNN::Interp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const MNN::LRN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LSTM: {
      auto ptr = reinterpret_cast<const MNN::LSTM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MatMul: {
      auto ptr = reinterpret_cast<const MNN::MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_NonMaxSuppressionV2: {
      auto ptr = reinterpret_cast<const MNN::NonMaxSuppressionV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const MNN::Normalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PackParam: {
      auto ptr = reinterpret_cast<const MNN::PackParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const MNN::Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Plugin: {
      auto ptr = reinterpret_cast<const MNN::Plugin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const MNN::Pool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const MNN::PRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PriorBox: {
      auto ptr = reinterpret_cast<const MNN::PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Proposal: {
      auto ptr = reinterpret_cast<const MNN::Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedAvgPool: {
      auto ptr = reinterpret_cast<const MNN::QuantizedAvgPool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedBiasAdd: {
      auto ptr = reinterpret_cast<const MNN::QuantizedBiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedConcat: {
      auto ptr = reinterpret_cast<const MNN::QuantizedConcat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedLogistic: {
      auto ptr = reinterpret_cast<const MNN::QuantizedLogistic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedMatMul: {
      auto ptr = reinterpret_cast<const MNN::QuantizedMatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedMaxPool: {
      auto ptr = reinterpret_cast<const MNN::QuantizedMaxPool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedRelu: {
      auto ptr = reinterpret_cast<const MNN::QuantizedRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedRelu6: {
      auto ptr = reinterpret_cast<const MNN::QuantizedRelu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedReshape: {
      auto ptr = reinterpret_cast<const MNN::QuantizedReshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedSoftmax: {
      auto ptr = reinterpret_cast<const MNN::QuantizedSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizeMaxMin: {
      auto ptr = reinterpret_cast<const MNN::QuantizeMaxMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizeV2: {
      auto ptr = reinterpret_cast<const MNN::QuantizeV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Range: {
      auto ptr = reinterpret_cast<const MNN::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Rank: {
      auto ptr = reinterpret_cast<const MNN::Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReduceJoin: {
      auto ptr = reinterpret_cast<const MNN::ReduceJoin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReductionParam: {
      auto ptr = reinterpret_cast<const MNN::ReductionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const MNN::Relu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const MNN::Relu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RequantizationRange: {
      auto ptr = reinterpret_cast<const MNN::RequantizationRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Requantize: {
      auto ptr = reinterpret_cast<const MNN::Requantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const MNN::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Resize: {
      auto ptr = reinterpret_cast<const MNN::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RoiParameters: {
      auto ptr = reinterpret_cast<const MNN::RoiParameters *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Scale: {
      auto ptr = reinterpret_cast<const MNN::Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Selu: {
      auto ptr = reinterpret_cast<const MNN::Selu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Size: {
      auto ptr = reinterpret_cast<const MNN::Size *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const MNN::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SliceTf: {
      auto ptr = reinterpret_cast<const MNN::SliceTf *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SpaceBatch: {
      auto ptr = reinterpret_cast<const MNN::SpaceBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_SqueezeParam: {
      auto ptr = reinterpret_cast<const MNN::SqueezeParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_StridedSliceParam: {
      auto ptr = reinterpret_cast<const MNN::StridedSliceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TensorConvertInfo: {
      auto ptr = reinterpret_cast<const MNN::TensorConvertInfo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TfQuantizedConv2D: {
      auto ptr = reinterpret_cast<const MNN::TfQuantizedConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TopKV2: {
      auto ptr = reinterpret_cast<const MNN::TopKV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Transpose: {
      auto ptr = reinterpret_cast<const MNN::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_UnaryOp: {
      auto ptr = reinterpret_cast<const MNN::UnaryOp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MomentsParam: {
      auto ptr = reinterpret_cast<const MNN::MomentsParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RNNParam: {
      auto ptr = reinterpret_cast<const MNN::RNNParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchMatMulParam: {
      auto ptr = reinterpret_cast<const MNN::BatchMatMulParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_QuantizedFloatParam: {
      auto ptr = reinterpret_cast<const MNN::QuantizedFloatParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DepthSpaceParam: {
      auto ptr = reinterpret_cast<const MNN::DepthSpaceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_EltwiseInt8: {
      auto ptr = reinterpret_cast<const MNN::EltwiseInt8 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ReverseSequenceParam: {
      auto ptr = reinterpret_cast<const MNN::ReverseSequenceParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const MNN::Extra *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool3D: {
      auto ptr = reinterpret_cast<const MNN::Pool3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Convolution3D: {
      auto ptr = reinterpret_cast<const MNN::Convolution3D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const MNN::ELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_DetectionPostProcessParam: {
      auto ptr = reinterpret_cast<const MNN::DetectionPostProcessParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_OneHotParam: {
      auto ptr = reinterpret_cast<const MNN::OneHotParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PadParam: {
      auto ptr = reinterpret_cast<const MNN::PadParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_WhileParam: {
      auto ptr = reinterpret_cast<const MNN::WhileParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_IfParam: {
      auto ptr = reinterpret_cast<const MNN::IfParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_RandomUniform: {
      auto ptr = reinterpret_cast<const MNN::RandomUniform *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const MNN::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_TensorArray: {
      auto ptr = reinterpret_cast<const MNN::TensorArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LSTMBlockCell: {
      auto ptr = reinterpret_cast<const MNN::LSTMBlockCell *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GridSample: {
      auto ptr = reinterpret_cast<const MNN::GridSample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LoopParam: {
      auto ptr = reinterpret_cast<const MNN::LoopParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ImageProcessParam: {
      auto ptr = reinterpret_cast<const MNN::ImageProcessParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_CumSum: {
      auto ptr = reinterpret_cast<const MNN::CumSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_GroupNorm: {
      auto ptr = reinterpret_cast<const MNN::GroupNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_FmhaV2Param: {
      auto ptr = reinterpret_cast<const MNN::FmhaV2Param *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_FmhcaParam: {
      auto ptr = reinterpret_cast<const MNN::FmhcaParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_AttentionParam: {
      auto ptr = reinterpret_cast<const MNN::AttentionParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_StftParam: {
      auto ptr = reinterpret_cast<const MNN::StftParam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpParameterVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParameter(
        verifier,  values->Get(i), types->GetEnum<OpParameter>(i))) {
      return false;
    }
  }
  return true;
}

inline const MNN::Net *GetNet(const void *buf) {
  return ::flatbuffers::GetRoot<MNN::Net>(buf);
}

inline const MNN::Net *GetSizePrefixedNet(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MNN::Net>(buf);
}

inline bool VerifyNetBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MNN::Net>(nullptr);
}

inline bool VerifySizePrefixedNetBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MNN::Net>(nullptr);
}

inline void FinishNetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MNN::Net> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedNetBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MNN::Net> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_MNN_MNN_H_
