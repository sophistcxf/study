// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_USERDEFINE_MNN_H_
#define FLATBUFFERS_GENERATED_USERDEFINE_MNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Tensor_generated.h"

namespace MNN {

struct TensorConvertInfo;
struct TensorConvertInfoBuilder;

struct GridSample;
struct GridSampleBuilder;

struct ImageProcessParam;
struct ImageProcessParamBuilder;

enum SampleMode : int8_t {
  SampleMode_BILINEAR = 0,
  SampleMode_NEAREST = 1,
  SampleMode_MIN = SampleMode_BILINEAR,
  SampleMode_MAX = SampleMode_NEAREST
};

inline const SampleMode (&EnumValuesSampleMode())[2] {
  static const SampleMode values[] = {
    SampleMode_BILINEAR,
    SampleMode_NEAREST
  };
  return values;
}

inline const char * const *EnumNamesSampleMode() {
  static const char * const names[3] = {
    "BILINEAR",
    "NEAREST",
    nullptr
  };
  return names;
}

inline const char *EnumNameSampleMode(SampleMode e) {
  if (::flatbuffers::IsOutRange(e, SampleMode_BILINEAR, SampleMode_NEAREST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSampleMode()[index];
}

enum BorderMode : int8_t {
  BorderMode_ZEROS = 0,
  BorderMode_CLAMP = 1,
  BorderMode_REFLECTION = 2,
  BorderMode_CUBE = 3,
  BorderMode_MIN = BorderMode_ZEROS,
  BorderMode_MAX = BorderMode_CUBE
};

inline const BorderMode (&EnumValuesBorderMode())[4] {
  static const BorderMode values[] = {
    BorderMode_ZEROS,
    BorderMode_CLAMP,
    BorderMode_REFLECTION,
    BorderMode_CUBE
  };
  return values;
}

inline const char * const *EnumNamesBorderMode() {
  static const char * const names[5] = {
    "ZEROS",
    "CLAMP",
    "REFLECTION",
    "CUBE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBorderMode(BorderMode e) {
  if (::flatbuffers::IsOutRange(e, BorderMode_ZEROS, BorderMode_CUBE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBorderMode()[index];
}

enum ImageFormatType : int32_t {
  ImageFormatType_RGBA = 0,
  ImageFormatType_RGB = 1,
  ImageFormatType_BGR = 2,
  ImageFormatType_GRAY = 3,
  ImageFormatType_BGRA = 4,
  ImageFormatType_YCrCb = 5,
  ImageFormatType_YUV = 6,
  ImageFormatType_HSV = 7,
  ImageFormatType_XYZ = 8,
  ImageFormatType_BGR555 = 9,
  ImageFormatType_BGR565 = 10,
  ImageFormatType_YUV_NV21 = 11,
  ImageFormatType_YUV_NV12 = 12,
  ImageFormatType_YUV_I420 = 13,
  ImageFormatType_HSV_FULL = 14,
  ImageFormatType_MIN = ImageFormatType_RGBA,
  ImageFormatType_MAX = ImageFormatType_HSV_FULL
};

inline const ImageFormatType (&EnumValuesImageFormatType())[15] {
  static const ImageFormatType values[] = {
    ImageFormatType_RGBA,
    ImageFormatType_RGB,
    ImageFormatType_BGR,
    ImageFormatType_GRAY,
    ImageFormatType_BGRA,
    ImageFormatType_YCrCb,
    ImageFormatType_YUV,
    ImageFormatType_HSV,
    ImageFormatType_XYZ,
    ImageFormatType_BGR555,
    ImageFormatType_BGR565,
    ImageFormatType_YUV_NV21,
    ImageFormatType_YUV_NV12,
    ImageFormatType_YUV_I420,
    ImageFormatType_HSV_FULL
  };
  return values;
}

inline const char * const *EnumNamesImageFormatType() {
  static const char * const names[16] = {
    "RGBA",
    "RGB",
    "BGR",
    "GRAY",
    "BGRA",
    "YCrCb",
    "YUV",
    "HSV",
    "XYZ",
    "BGR555",
    "BGR565",
    "YUV_NV21",
    "YUV_NV12",
    "YUV_I420",
    "HSV_FULL",
    nullptr
  };
  return names;
}

inline const char *EnumNameImageFormatType(ImageFormatType e) {
  if (::flatbuffers::IsOutRange(e, ImageFormatType_RGBA, ImageFormatType_HSV_FULL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesImageFormatType()[index];
}

enum FilterType : int8_t {
  FilterType_NEAREST = 0,
  FilterType_BILINEAR = 1,
  FilterType_BICUBIC = 2,
  FilterType_MIN = FilterType_NEAREST,
  FilterType_MAX = FilterType_BICUBIC
};

inline const FilterType (&EnumValuesFilterType())[3] {
  static const FilterType values[] = {
    FilterType_NEAREST,
    FilterType_BILINEAR,
    FilterType_BICUBIC
  };
  return values;
}

inline const char * const *EnumNamesFilterType() {
  static const char * const names[4] = {
    "NEAREST",
    "BILINEAR",
    "BICUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameFilterType(FilterType e) {
  if (::flatbuffers::IsOutRange(e, FilterType_NEAREST, FilterType_BICUBIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFilterType()[index];
}

enum WrapType : int8_t {
  WrapType_CLAMP_TO_EDGE = 0,
  WrapType_ZERO = 1,
  WrapType_REPEAT = 2,
  WrapType_MIN = WrapType_CLAMP_TO_EDGE,
  WrapType_MAX = WrapType_REPEAT
};

inline const WrapType (&EnumValuesWrapType())[3] {
  static const WrapType values[] = {
    WrapType_CLAMP_TO_EDGE,
    WrapType_ZERO,
    WrapType_REPEAT
  };
  return values;
}

inline const char * const *EnumNamesWrapType() {
  static const char * const names[4] = {
    "CLAMP_TO_EDGE",
    "ZERO",
    "REPEAT",
    nullptr
  };
  return names;
}

inline const char *EnumNameWrapType(WrapType e) {
  if (::flatbuffers::IsOutRange(e, WrapType_CLAMP_TO_EDGE, WrapType_REPEAT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesWrapType()[index];
}

struct TensorConvertInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorConvertInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_DEST = 6
  };
  MNN::MNN_DATA_FORMAT source() const {
    return static_cast<MNN::MNN_DATA_FORMAT>(GetField<int8_t>(VT_SOURCE, 0));
  }
  MNN::MNN_DATA_FORMAT dest() const {
    return static_cast<MNN::MNN_DATA_FORMAT>(GetField<int8_t>(VT_DEST, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_SOURCE, 1) &&
           VerifyField<int8_t>(verifier, VT_DEST, 1) &&
           verifier.EndTable();
  }
};

struct TensorConvertInfoBuilder {
  typedef TensorConvertInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_source(MNN::MNN_DATA_FORMAT source) {
    fbb_.AddElement<int8_t>(TensorConvertInfo::VT_SOURCE, static_cast<int8_t>(source), 0);
  }
  void add_dest(MNN::MNN_DATA_FORMAT dest) {
    fbb_.AddElement<int8_t>(TensorConvertInfo::VT_DEST, static_cast<int8_t>(dest), 0);
  }
  explicit TensorConvertInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorConvertInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorConvertInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorConvertInfo> CreateTensorConvertInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::MNN_DATA_FORMAT source = MNN::MNN_DATA_FORMAT_NCHW,
    MNN::MNN_DATA_FORMAT dest = MNN::MNN_DATA_FORMAT_NCHW) {
  TensorConvertInfoBuilder builder_(_fbb);
  builder_.add_dest(dest);
  builder_.add_source(source);
  return builder_.Finish();
}

struct GridSample FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GridSampleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_PADDINGMODE = 6,
    VT_ALIGNCORNERS = 8,
    VT_BACKWARD = 10
  };
  MNN::SampleMode mode() const {
    return static_cast<MNN::SampleMode>(GetField<int8_t>(VT_MODE, 0));
  }
  MNN::BorderMode paddingMode() const {
    return static_cast<MNN::BorderMode>(GetField<int8_t>(VT_PADDINGMODE, 0));
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool backward() const {
    return GetField<uint8_t>(VT_BACKWARD, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           VerifyField<int8_t>(verifier, VT_PADDINGMODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_BACKWARD, 1) &&
           verifier.EndTable();
  }
};

struct GridSampleBuilder {
  typedef GridSample Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(MNN::SampleMode mode) {
    fbb_.AddElement<int8_t>(GridSample::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_paddingMode(MNN::BorderMode paddingMode) {
    fbb_.AddElement<int8_t>(GridSample::VT_PADDINGMODE, static_cast<int8_t>(paddingMode), 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(GridSample::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_backward(bool backward) {
    fbb_.AddElement<uint8_t>(GridSample::VT_BACKWARD, static_cast<uint8_t>(backward), 0);
  }
  explicit GridSampleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GridSample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GridSample>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GridSample> CreateGridSample(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::SampleMode mode = MNN::SampleMode_BILINEAR,
    MNN::BorderMode paddingMode = MNN::BorderMode_ZEROS,
    bool alignCorners = false,
    bool backward = false) {
  GridSampleBuilder builder_(_fbb);
  builder_.add_backward(backward);
  builder_.add_alignCorners(alignCorners);
  builder_.add_paddingMode(paddingMode);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct ImageProcessParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageProcessParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FILTERTYPE = 4,
    VT_SOURCEFORMAT = 6,
    VT_DESTFORMAT = 8,
    VT_WRAP = 10,
    VT_MEAN = 12,
    VT_NORMAL = 14,
    VT_TRANSFORM = 16,
    VT_PADDINGVALUE = 18,
    VT_SHAPE = 20,
    VT_OUTPUTTYPE = 22,
    VT_DRAW = 24
  };
  MNN::FilterType filterType() const {
    return static_cast<MNN::FilterType>(GetField<int8_t>(VT_FILTERTYPE, 0));
  }
  MNN::ImageFormatType sourceFormat() const {
    return static_cast<MNN::ImageFormatType>(GetField<int32_t>(VT_SOURCEFORMAT, 0));
  }
  MNN::ImageFormatType destFormat() const {
    return static_cast<MNN::ImageFormatType>(GetField<int32_t>(VT_DESTFORMAT, 0));
  }
  MNN::WrapType wrap() const {
    return static_cast<MNN::WrapType>(GetField<int8_t>(VT_WRAP, 0));
  }
  const ::flatbuffers::Vector<float> *mean() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MEAN);
  }
  const ::flatbuffers::Vector<float> *normal() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_NORMAL);
  }
  const ::flatbuffers::Vector<float> *transform() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TRANSFORM);
  }
  int8_t paddingValue() const {
    return GetField<int8_t>(VT_PADDINGVALUE, 0);
  }
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  MNN::DataType outputType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_OUTPUTTYPE, 0));
  }
  bool draw() const {
    return GetField<uint8_t>(VT_DRAW, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FILTERTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_SOURCEFORMAT, 4) &&
           VerifyField<int32_t>(verifier, VT_DESTFORMAT, 4) &&
           VerifyField<int8_t>(verifier, VT_WRAP, 1) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyVector(mean()) &&
           VerifyOffset(verifier, VT_NORMAL) &&
           verifier.VerifyVector(normal()) &&
           VerifyOffset(verifier, VT_TRANSFORM) &&
           verifier.VerifyVector(transform()) &&
           VerifyField<int8_t>(verifier, VT_PADDINGVALUE, 1) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DRAW, 1) &&
           verifier.EndTable();
  }
};

struct ImageProcessParamBuilder {
  typedef ImageProcessParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_filterType(MNN::FilterType filterType) {
    fbb_.AddElement<int8_t>(ImageProcessParam::VT_FILTERTYPE, static_cast<int8_t>(filterType), 0);
  }
  void add_sourceFormat(MNN::ImageFormatType sourceFormat) {
    fbb_.AddElement<int32_t>(ImageProcessParam::VT_SOURCEFORMAT, static_cast<int32_t>(sourceFormat), 0);
  }
  void add_destFormat(MNN::ImageFormatType destFormat) {
    fbb_.AddElement<int32_t>(ImageProcessParam::VT_DESTFORMAT, static_cast<int32_t>(destFormat), 0);
  }
  void add_wrap(MNN::WrapType wrap) {
    fbb_.AddElement<int8_t>(ImageProcessParam::VT_WRAP, static_cast<int8_t>(wrap), 0);
  }
  void add_mean(::flatbuffers::Offset<::flatbuffers::Vector<float>> mean) {
    fbb_.AddOffset(ImageProcessParam::VT_MEAN, mean);
  }
  void add_normal(::flatbuffers::Offset<::flatbuffers::Vector<float>> normal) {
    fbb_.AddOffset(ImageProcessParam::VT_NORMAL, normal);
  }
  void add_transform(::flatbuffers::Offset<::flatbuffers::Vector<float>> transform) {
    fbb_.AddOffset(ImageProcessParam::VT_TRANSFORM, transform);
  }
  void add_paddingValue(int8_t paddingValue) {
    fbb_.AddElement<int8_t>(ImageProcessParam::VT_PADDINGVALUE, paddingValue, 0);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(ImageProcessParam::VT_SHAPE, shape);
  }
  void add_outputType(MNN::DataType outputType) {
    fbb_.AddElement<int32_t>(ImageProcessParam::VT_OUTPUTTYPE, static_cast<int32_t>(outputType), 0);
  }
  void add_draw(bool draw) {
    fbb_.AddElement<uint8_t>(ImageProcessParam::VT_DRAW, static_cast<uint8_t>(draw), 0);
  }
  explicit ImageProcessParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageProcessParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageProcessParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageProcessParam> CreateImageProcessParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::FilterType filterType = MNN::FilterType_NEAREST,
    MNN::ImageFormatType sourceFormat = MNN::ImageFormatType_RGBA,
    MNN::ImageFormatType destFormat = MNN::ImageFormatType_RGBA,
    MNN::WrapType wrap = MNN::WrapType_CLAMP_TO_EDGE,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> mean = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> normal = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> transform = 0,
    int8_t paddingValue = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    MNN::DataType outputType = MNN::DataType_DT_INVALID,
    bool draw = false) {
  ImageProcessParamBuilder builder_(_fbb);
  builder_.add_outputType(outputType);
  builder_.add_shape(shape);
  builder_.add_transform(transform);
  builder_.add_normal(normal);
  builder_.add_mean(mean);
  builder_.add_destFormat(destFormat);
  builder_.add_sourceFormat(sourceFormat);
  builder_.add_draw(draw);
  builder_.add_paddingValue(paddingValue);
  builder_.add_wrap(wrap);
  builder_.add_filterType(filterType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ImageProcessParam> CreateImageProcessParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::FilterType filterType = MNN::FilterType_NEAREST,
    MNN::ImageFormatType sourceFormat = MNN::ImageFormatType_RGBA,
    MNN::ImageFormatType destFormat = MNN::ImageFormatType_RGBA,
    MNN::WrapType wrap = MNN::WrapType_CLAMP_TO_EDGE,
    const std::vector<float> *mean = nullptr,
    const std::vector<float> *normal = nullptr,
    const std::vector<float> *transform = nullptr,
    int8_t paddingValue = 0,
    const std::vector<int32_t> *shape = nullptr,
    MNN::DataType outputType = MNN::DataType_DT_INVALID,
    bool draw = false) {
  auto mean__ = mean ? _fbb.CreateVector<float>(*mean) : 0;
  auto normal__ = normal ? _fbb.CreateVector<float>(*normal) : 0;
  auto transform__ = transform ? _fbb.CreateVector<float>(*transform) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return MNN::CreateImageProcessParam(
      _fbb,
      filterType,
      sourceFormat,
      destFormat,
      wrap,
      mean__,
      normal__,
      transform__,
      paddingValue,
      shape__,
      outputType,
      draw);
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_USERDEFINE_MNN_H_
