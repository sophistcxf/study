// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_
#define FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Tensor_generated.h"

namespace MNN {

struct Convolution2DCommon;
struct Convolution2DCommonBuilder;

struct Convolution3DCommon;
struct Convolution3DCommonBuilder;

struct SparseCommon;
struct SparseCommonBuilder;

struct IDSTQuan;
struct IDSTQuanBuilder;

struct QuantizedFloatParam;
struct QuantizedFloatParamBuilder;

struct Convolution2D;
struct Convolution2DBuilder;

struct Convolution3D;
struct Convolution3DBuilder;

struct InnerProduct;
struct InnerProductBuilder;

struct Pool;
struct PoolBuilder;

struct Pool3D;
struct Pool3DBuilder;

struct Relu;
struct ReluBuilder;

struct Relu6;
struct Relu6Builder;

struct PRelu;
struct PReluBuilder;

struct ELU;
struct ELUBuilder;

struct LRN;
struct LRNBuilder;

struct ArgMax;
struct ArgMaxBuilder;

struct Axis;
struct AxisBuilder;

struct Input;
struct InputBuilder;

struct LSTM;
struct LSTMBuilder;

struct Slice;
struct SliceBuilder;

struct BatchNorm;
struct BatchNormBuilder;

struct Scale;
struct ScaleBuilder;

struct Eltwise;
struct EltwiseBuilder;

struct Flatten;
struct FlattenBuilder;

struct Permute;
struct PermuteBuilder;

struct Reshape;
struct ReshapeBuilder;

struct DetectionOutput;
struct DetectionOutputBuilder;

struct RoiParameters;
struct RoiParametersBuilder;

struct Proposal;
struct ProposalBuilder;

struct Interp;
struct InterpBuilder;

struct Resize;
struct ResizeBuilder;

struct PriorBox;
struct PriorBoxBuilder;

struct Normalize;
struct NormalizeBuilder;

struct EltwiseInt8;
struct EltwiseInt8Builder;

struct CumSum;
struct CumSumBuilder;

enum PadMode : int8_t {
  PadMode_CAFFE = 0,
  PadMode_VALID = 1,
  PadMode_SAME = 2,
  PadMode_MIN = PadMode_CAFFE,
  PadMode_MAX = PadMode_SAME
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_CAFFE,
    PadMode_VALID,
    PadMode_SAME
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (::flatbuffers::IsOutRange(e, PadMode_CAFFE, PadMode_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum SparseAlgo : int8_t {
  SparseAlgo_RANDOM = 0,
  SparseAlgo_SIMD_OC = 1,
  SparseAlgo_MIN = SparseAlgo_RANDOM,
  SparseAlgo_MAX = SparseAlgo_SIMD_OC
};

inline const SparseAlgo (&EnumValuesSparseAlgo())[2] {
  static const SparseAlgo values[] = {
    SparseAlgo_RANDOM,
    SparseAlgo_SIMD_OC
  };
  return values;
}

inline const char * const *EnumNamesSparseAlgo() {
  static const char * const names[3] = {
    "RANDOM",
    "SIMD_OC",
    nullptr
  };
  return names;
}

inline const char *EnumNameSparseAlgo(SparseAlgo e) {
  if (::flatbuffers::IsOutRange(e, SparseAlgo_RANDOM, SparseAlgo_SIMD_OC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSparseAlgo()[index];
}

enum QuantizeAlgo : int8_t {
  QuantizeAlgo_DEFAULT = 0,
  QuantizeAlgo_OVERFLOW_AWARE = 1,
  QuantizeAlgo_WINOGRAD_AWARE = 2,
  QuantizeAlgo_MIN = QuantizeAlgo_DEFAULT,
  QuantizeAlgo_MAX = QuantizeAlgo_WINOGRAD_AWARE
};

inline const QuantizeAlgo (&EnumValuesQuantizeAlgo())[3] {
  static const QuantizeAlgo values[] = {
    QuantizeAlgo_DEFAULT,
    QuantizeAlgo_OVERFLOW_AWARE,
    QuantizeAlgo_WINOGRAD_AWARE
  };
  return values;
}

inline const char * const *EnumNamesQuantizeAlgo() {
  static const char * const names[4] = {
    "DEFAULT",
    "OVERFLOW_AWARE",
    "WINOGRAD_AWARE",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizeAlgo(QuantizeAlgo e) {
  if (::flatbuffers::IsOutRange(e, QuantizeAlgo_DEFAULT, QuantizeAlgo_WINOGRAD_AWARE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizeAlgo()[index];
}

enum PoolType : int8_t {
  PoolType_MAXPOOL = 0,
  PoolType_AVEPOOL = 1,
  PoolType_MIN = PoolType_MAXPOOL,
  PoolType_MAX = PoolType_AVEPOOL
};

inline const PoolType (&EnumValuesPoolType())[2] {
  static const PoolType values[] = {
    PoolType_MAXPOOL,
    PoolType_AVEPOOL
  };
  return values;
}

inline const char * const *EnumNamesPoolType() {
  static const char * const names[3] = {
    "MAXPOOL",
    "AVEPOOL",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolType(PoolType e) {
  if (::flatbuffers::IsOutRange(e, PoolType_MAXPOOL, PoolType_AVEPOOL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolType()[index];
}

enum PoolPadType : int8_t {
  PoolPadType_CAFFE = 0,
  PoolPadType_VALID = 1,
  PoolPadType_SAME = 2,
  PoolPadType_MIN = PoolPadType_CAFFE,
  PoolPadType_MAX = PoolPadType_SAME
};

inline const PoolPadType (&EnumValuesPoolPadType())[3] {
  static const PoolPadType values[] = {
    PoolPadType_CAFFE,
    PoolPadType_VALID,
    PoolPadType_SAME
  };
  return values;
}

inline const char * const *EnumNamesPoolPadType() {
  static const char * const names[4] = {
    "CAFFE",
    "VALID",
    "SAME",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolPadType(PoolPadType e) {
  if (::flatbuffers::IsOutRange(e, PoolPadType_CAFFE, PoolPadType_SAME)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolPadType()[index];
}

enum AvgPoolCountType : int8_t {
  AvgPoolCountType_DEFAULT = 0,
  AvgPoolCountType_INCLUDE_PADDING = 1,
  AvgPoolCountType_EXCLUDE_PADDING = 2,
  AvgPoolCountType_MIN = AvgPoolCountType_DEFAULT,
  AvgPoolCountType_MAX = AvgPoolCountType_EXCLUDE_PADDING
};

inline const AvgPoolCountType (&EnumValuesAvgPoolCountType())[3] {
  static const AvgPoolCountType values[] = {
    AvgPoolCountType_DEFAULT,
    AvgPoolCountType_INCLUDE_PADDING,
    AvgPoolCountType_EXCLUDE_PADDING
  };
  return values;
}

inline const char * const *EnumNamesAvgPoolCountType() {
  static const char * const names[4] = {
    "DEFAULT",
    "INCLUDE_PADDING",
    "EXCLUDE_PADDING",
    nullptr
  };
  return names;
}

inline const char *EnumNameAvgPoolCountType(AvgPoolCountType e) {
  if (::flatbuffers::IsOutRange(e, AvgPoolCountType_DEFAULT, AvgPoolCountType_EXCLUDE_PADDING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAvgPoolCountType()[index];
}

enum EltwiseType : int8_t {
  EltwiseType_PROD = 0,
  EltwiseType_SUM = 1,
  EltwiseType_MAXIMUM = 2,
  EltwiseType_SUB = 3,
  EltwiseType_MIN = EltwiseType_PROD,
  EltwiseType_MAX = EltwiseType_SUB
};

inline const EltwiseType (&EnumValuesEltwiseType())[4] {
  static const EltwiseType values[] = {
    EltwiseType_PROD,
    EltwiseType_SUM,
    EltwiseType_MAXIMUM,
    EltwiseType_SUB
  };
  return values;
}

inline const char * const *EnumNamesEltwiseType() {
  static const char * const names[5] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "SUB",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseType(EltwiseType e) {
  if (::flatbuffers::IsOutRange(e, EltwiseType_PROD, EltwiseType_SUB)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseType()[index];
}

enum CoordinateTransformationMode : int8_t {
  CoordinateTransformationMode_NotSet = 0,
  CoordinateTransformationMode_AlignCorners = 1,
  CoordinateTransformationMode_HalfPixels = 2,
  CoordinateTransformationMode_PytorchHalfPixels = 3,
  CoordinateTransformationMode_Asymmetric = 4,
  CoordinateTransformationMode_TensorflowHalfPixels = 5,
  CoordinateTransformationMode_TensorflowCropAndResize = 6,
  CoordinateTransformationMode_MIN = CoordinateTransformationMode_NotSet,
  CoordinateTransformationMode_MAX = CoordinateTransformationMode_TensorflowCropAndResize
};

inline const CoordinateTransformationMode (&EnumValuesCoordinateTransformationMode())[7] {
  static const CoordinateTransformationMode values[] = {
    CoordinateTransformationMode_NotSet,
    CoordinateTransformationMode_AlignCorners,
    CoordinateTransformationMode_HalfPixels,
    CoordinateTransformationMode_PytorchHalfPixels,
    CoordinateTransformationMode_Asymmetric,
    CoordinateTransformationMode_TensorflowHalfPixels,
    CoordinateTransformationMode_TensorflowCropAndResize
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformationMode() {
  static const char * const names[8] = {
    "NotSet",
    "AlignCorners",
    "HalfPixels",
    "PytorchHalfPixels",
    "Asymmetric",
    "TensorflowHalfPixels",
    "TensorflowCropAndResize",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformationMode(CoordinateTransformationMode e) {
  if (::flatbuffers::IsOutRange(e, CoordinateTransformationMode_NotSet, CoordinateTransformationMode_TensorflowCropAndResize)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateTransformationMode()[index];
}

struct Convolution2DCommon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Convolution2DCommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_KERNELX = 8,
    VT_KERNELY = 10,
    VT_STRIDEX = 12,
    VT_STRIDEY = 14,
    VT_DILATEX = 16,
    VT_DILATEY = 18,
    VT_PADMODE = 20,
    VT_GROUP = 22,
    VT_OUTPUTCOUNT = 24,
    VT_INPUTCOUNT = 26,
    VT_RELU = 28,
    VT_RELU6 = 30,
    VT_PADS = 32,
    VT_OUTPADS = 34,
    VT_HASOUTPUTSHAPE = 36
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 1);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 1);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 1);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 1);
  }
  int32_t dilateX() const {
    return GetField<int32_t>(VT_DILATEX, 1);
  }
  int32_t dilateY() const {
    return GetField<int32_t>(VT_DILATEY, 1);
  }
  MNN::PadMode padMode() const {
    return static_cast<MNN::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  const ::flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  const ::flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPADS);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(VT_HASOUTPUTSHAPE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX, 4) &&
           VerifyField<int32_t>(verifier, VT_PADY, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELX, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELY, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATEX, 4) &&
           VerifyField<int32_t>(verifier, VT_DILATEY, 4) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyOffset(verifier, VT_OUTPADS) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, VT_HASOUTPUTSHAPE, 1) &&
           verifier.EndTable();
  }
};

struct Convolution2DCommonBuilder {
  typedef Convolution2DCommon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_PADY, padY, 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELX, kernelX, 1);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_KERNELY, kernelY, 1);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEX, strideX, 1);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_STRIDEY, strideY, 1);
  }
  void add_dilateX(int32_t dilateX) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEX, dilateX, 1);
  }
  void add_dilateY(int32_t dilateY) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_DILATEY, dilateY, 1);
  }
  void add_padMode(MNN::PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution2DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_GROUP, group, 1);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution2DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_pads(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Convolution2DCommon::VT_PADS, pads);
  }
  void add_outPads(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(Convolution2DCommon::VT_OUTPADS, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(Convolution2DCommon::VT_HASOUTPUTSHAPE, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Convolution2DCommonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Convolution2DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Convolution2DCommon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    MNN::PadMode padMode = MNN::PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Convolution2DCommonBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_pads(pads);
  builder_.add_inputCount(inputCount);
  builder_.add_outputCount(outputCount);
  builder_.add_group(group);
  builder_.add_dilateY(dilateY);
  builder_.add_dilateX(dilateX);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Convolution2DCommon> CreateConvolution2DCommonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    int32_t kernelX = 1,
    int32_t kernelY = 1,
    int32_t strideX = 1,
    int32_t strideY = 1,
    int32_t dilateX = 1,
    int32_t dilateY = 1,
    MNN::PadMode padMode = MNN::PadMode_CAFFE,
    int32_t group = 1,
    int32_t outputCount = 0,
    int32_t inputCount = 0,
    bool relu = false,
    bool relu6 = false,
    const std::vector<int32_t> *pads = nullptr,
    const std::vector<int32_t> *outPads = nullptr,
    bool hasOutputShape = false) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto outPads__ = outPads ? _fbb.CreateVector<int32_t>(*outPads) : 0;
  return MNN::CreateConvolution2DCommon(
      _fbb,
      padX,
      padY,
      kernelX,
      kernelY,
      strideX,
      strideY,
      dilateX,
      dilateY,
      padMode,
      group,
      outputCount,
      inputCount,
      relu,
      relu6,
      pads__,
      outPads__,
      hasOutputShape);
}

struct Convolution3DCommon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Convolution3DCommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DILATES = 4,
    VT_STRIDES = 6,
    VT_KERNELS = 8,
    VT_PADS = 10,
    VT_PADMODE = 12,
    VT_INPUTCOUNT = 14,
    VT_OUTPUTCOUNT = 16,
    VT_RELU = 18,
    VT_RELU6 = 20,
    VT_GROUP = 22,
    VT_OUTPADS = 24,
    VT_HASOUTPUTSHAPE = 26
  };
  const ::flatbuffers::Vector<int32_t> *dilates() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DILATES);
  }
  const ::flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const ::flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const ::flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  MNN::PadMode padMode() const {
    return static_cast<MNN::PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t inputCount() const {
    return GetField<int32_t>(VT_INPUTCOUNT, 0);
  }
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  bool relu() const {
    return GetField<uint8_t>(VT_RELU, 0) != 0;
  }
  bool relu6() const {
    return GetField<uint8_t>(VT_RELU6, 0) != 0;
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  const ::flatbuffers::Vector<int32_t> *outPads() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPADS);
  }
  bool hasOutputShape() const {
    return GetField<uint8_t>(VT_HASOUTPUTSHAPE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DILATES) &&
           verifier.VerifyVector(dilates()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_PADMODE, 1) &&
           VerifyField<int32_t>(verifier, VT_INPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_RELU, 1) &&
           VerifyField<uint8_t>(verifier, VT_RELU6, 1) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyOffset(verifier, VT_OUTPADS) &&
           verifier.VerifyVector(outPads()) &&
           VerifyField<uint8_t>(verifier, VT_HASOUTPUTSHAPE, 1) &&
           verifier.EndTable();
  }
};

struct Convolution3DCommonBuilder {
  typedef Convolution3DCommon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dilates(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilates) {
    fbb_.AddOffset(Convolution3DCommon::VT_DILATES, dilates);
  }
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Convolution3DCommon::VT_STRIDES, strides);
  }
  void add_kernels(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Convolution3DCommon::VT_KERNELS, kernels);
  }
  void add_pads(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Convolution3DCommon::VT_PADS, pads);
  }
  void add_padMode(MNN::PadMode padMode) {
    fbb_.AddElement<int8_t>(Convolution3DCommon::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_inputCount(int32_t inputCount) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_INPUTCOUNT, inputCount, 0);
  }
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_relu(bool relu) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_RELU, static_cast<uint8_t>(relu), 0);
  }
  void add_relu6(bool relu6) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_RELU6, static_cast<uint8_t>(relu6), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Convolution3DCommon::VT_GROUP, group, 1);
  }
  void add_outPads(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outPads) {
    fbb_.AddOffset(Convolution3DCommon::VT_OUTPADS, outPads);
  }
  void add_hasOutputShape(bool hasOutputShape) {
    fbb_.AddElement<uint8_t>(Convolution3DCommon::VT_HASOUTPUTSHAPE, static_cast<uint8_t>(hasOutputShape), 0);
  }
  explicit Convolution3DCommonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Convolution3DCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Convolution3DCommon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dilates = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads = 0,
    MNN::PadMode padMode = MNN::PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false,
    int32_t group = 1,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outPads = 0,
    bool hasOutputShape = false) {
  Convolution3DCommonBuilder builder_(_fbb);
  builder_.add_outPads(outPads);
  builder_.add_group(group);
  builder_.add_outputCount(outputCount);
  builder_.add_inputCount(inputCount);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_dilates(dilates);
  builder_.add_hasOutputShape(hasOutputShape);
  builder_.add_relu6(relu6);
  builder_.add_relu(relu);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Convolution3DCommon> CreateConvolution3DCommonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dilates = nullptr,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    MNN::PadMode padMode = MNN::PadMode_CAFFE,
    int32_t inputCount = 0,
    int32_t outputCount = 0,
    bool relu = false,
    bool relu6 = false,
    int32_t group = 1,
    const std::vector<int32_t> *outPads = nullptr,
    bool hasOutputShape = false) {
  auto dilates__ = dilates ? _fbb.CreateVector<int32_t>(*dilates) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  auto outPads__ = outPads ? _fbb.CreateVector<int32_t>(*outPads) : 0;
  return MNN::CreateConvolution3DCommon(
      _fbb,
      dilates__,
      strides__,
      kernels__,
      pads__,
      padMode,
      inputCount,
      outputCount,
      relu,
      relu6,
      group,
      outPads__,
      hasOutputShape);
}

struct SparseCommon FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SparseCommonBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_ARGS = 6
  };
  MNN::SparseAlgo method() const {
    return static_cast<MNN::SparseAlgo>(GetField<int8_t>(VT_METHOD, 0));
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *args() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>> *>(VT_ARGS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_METHOD, 1) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfTables(args()) &&
           verifier.EndTable();
  }
};

struct SparseCommonBuilder {
  typedef SparseCommon Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_method(MNN::SparseAlgo method) {
    fbb_.AddElement<int8_t>(SparseCommon::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_args(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> args) {
    fbb_.AddOffset(SparseCommon::VT_ARGS, args);
  }
  explicit SparseCommonBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SparseCommon> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SparseCommon>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SparseCommon> CreateSparseCommon(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::SparseAlgo method = MNN::SparseAlgo_RANDOM,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MNN::Attribute>>> args = 0) {
  SparseCommonBuilder builder_(_fbb);
  builder_.add_args(args);
  builder_.add_method(method);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SparseCommon> CreateSparseCommonDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::SparseAlgo method = MNN::SparseAlgo_RANDOM,
    std::vector<::flatbuffers::Offset<MNN::Attribute>> *args = nullptr) {
  auto args__ = args ? _fbb.CreateVectorOfSortedTables<MNN::Attribute>(args) : 0;
  return MNN::CreateSparseCommon(
      _fbb,
      method,
      args__);
}

struct IDSTQuan FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IDSTQuanBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_ALPHA = 6,
    VT_TYPE = 8,
    VT_USEINT32 = 10,
    VT_QUANTSCALE = 12,
    VT_SCALEIN = 14,
    VT_SCALEOUT = 16,
    VT_AMAX = 18,
    VT_AMIN = 20,
    VT_READTYPE = 22,
    VT_HAS_SCALEINT = 24,
    VT_SHAPEINT32 = 26,
    VT_WEIGHTSIZE = 28,
    VT_INDEX = 30
  };
  const ::flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  const ::flatbuffers::Vector<float> *alpha() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ALPHA);
  }
  int32_t type() const {
    return GetField<int32_t>(VT_TYPE, 0);
  }
  bool useInt32() const {
    return GetField<uint8_t>(VT_USEINT32, 0) != 0;
  }
  float quantScale() const {
    return GetField<float>(VT_QUANTSCALE, 0.0f);
  }
  float scaleIn() const {
    return GetField<float>(VT_SCALEIN, 0.0f);
  }
  float scaleOut() const {
    return GetField<float>(VT_SCALEOUT, 0.0f);
  }
  int32_t aMax() const {
    return GetField<int32_t>(VT_AMAX, 0);
  }
  int32_t aMin() const {
    return GetField<int32_t>(VT_AMIN, 0);
  }
  int32_t readType() const {
    return GetField<int32_t>(VT_READTYPE, 0);
  }
  bool has_scaleInt() const {
    return GetField<uint8_t>(VT_HAS_SCALEINT, 0) != 0;
  }
  bool shapeInt32() const {
    return GetField<uint8_t>(VT_SHAPEINT32, 0) != 0;
  }
  uint32_t weightSize() const {
    return GetField<uint32_t>(VT_WEIGHTSIZE, 0);
  }
  const ::flatbuffers::Vector<uint32_t> *index() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INDEX);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyVector(alpha()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_USEINT32, 1) &&
           VerifyField<float>(verifier, VT_QUANTSCALE, 4) &&
           VerifyField<float>(verifier, VT_SCALEIN, 4) &&
           VerifyField<float>(verifier, VT_SCALEOUT, 4) &&
           VerifyField<int32_t>(verifier, VT_AMAX, 4) &&
           VerifyField<int32_t>(verifier, VT_AMIN, 4) &&
           VerifyField<int32_t>(verifier, VT_READTYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SCALEINT, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHAPEINT32, 1) &&
           VerifyField<uint32_t>(verifier, VT_WEIGHTSIZE, 4) &&
           VerifyOffset(verifier, VT_INDEX) &&
           verifier.VerifyVector(index()) &&
           verifier.EndTable();
  }
};

struct IDSTQuanBuilder {
  typedef IDSTQuan Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_buffer(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(IDSTQuan::VT_BUFFER, buffer);
  }
  void add_alpha(::flatbuffers::Offset<::flatbuffers::Vector<float>> alpha) {
    fbb_.AddOffset(IDSTQuan::VT_ALPHA, alpha);
  }
  void add_type(int32_t type) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_TYPE, type, 0);
  }
  void add_useInt32(bool useInt32) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_USEINT32, static_cast<uint8_t>(useInt32), 0);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(IDSTQuan::VT_QUANTSCALE, quantScale, 0.0f);
  }
  void add_scaleIn(float scaleIn) {
    fbb_.AddElement<float>(IDSTQuan::VT_SCALEIN, scaleIn, 0.0f);
  }
  void add_scaleOut(float scaleOut) {
    fbb_.AddElement<float>(IDSTQuan::VT_SCALEOUT, scaleOut, 0.0f);
  }
  void add_aMax(int32_t aMax) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_AMAX, aMax, 0);
  }
  void add_aMin(int32_t aMin) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_AMIN, aMin, 0);
  }
  void add_readType(int32_t readType) {
    fbb_.AddElement<int32_t>(IDSTQuan::VT_READTYPE, readType, 0);
  }
  void add_has_scaleInt(bool has_scaleInt) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_HAS_SCALEINT, static_cast<uint8_t>(has_scaleInt), 0);
  }
  void add_shapeInt32(bool shapeInt32) {
    fbb_.AddElement<uint8_t>(IDSTQuan::VT_SHAPEINT32, static_cast<uint8_t>(shapeInt32), 0);
  }
  void add_weightSize(uint32_t weightSize) {
    fbb_.AddElement<uint32_t>(IDSTQuan::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_index(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> index) {
    fbb_.AddOffset(IDSTQuan::VT_INDEX, index);
  }
  explicit IDSTQuanBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IDSTQuan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IDSTQuan>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<IDSTQuan> CreateIDSTQuan(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> buffer = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> alpha = 0,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false,
    bool shapeInt32 = false,
    uint32_t weightSize = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> index = 0) {
  IDSTQuanBuilder builder_(_fbb);
  builder_.add_index(index);
  builder_.add_weightSize(weightSize);
  builder_.add_readType(readType);
  builder_.add_aMin(aMin);
  builder_.add_aMax(aMax);
  builder_.add_scaleOut(scaleOut);
  builder_.add_scaleIn(scaleIn);
  builder_.add_quantScale(quantScale);
  builder_.add_type(type);
  builder_.add_alpha(alpha);
  builder_.add_buffer(buffer);
  builder_.add_shapeInt32(shapeInt32);
  builder_.add_has_scaleInt(has_scaleInt);
  builder_.add_useInt32(useInt32);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IDSTQuan> CreateIDSTQuanDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr,
    const std::vector<float> *alpha = nullptr,
    int32_t type = 0,
    bool useInt32 = false,
    float quantScale = 0.0f,
    float scaleIn = 0.0f,
    float scaleOut = 0.0f,
    int32_t aMax = 0,
    int32_t aMin = 0,
    int32_t readType = 0,
    bool has_scaleInt = false,
    bool shapeInt32 = false,
    uint32_t weightSize = 0,
    const std::vector<uint32_t> *index = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  auto alpha__ = alpha ? _fbb.CreateVector<float>(*alpha) : 0;
  auto index__ = index ? _fbb.CreateVector<uint32_t>(*index) : 0;
  return MNN::CreateIDSTQuan(
      _fbb,
      buffer__,
      alpha__,
      type,
      useInt32,
      quantScale,
      scaleIn,
      scaleOut,
      aMax,
      aMin,
      readType,
      has_scaleInt,
      shapeInt32,
      weightSize,
      index__);
}

struct QuantizedFloatParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizedFloatParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHT = 4,
    VT_BIAS = 6,
    VT_SCALE = 8,
    VT_TENSORSCALE = 10,
    VT_METHOD = 12,
    VT_NBITS = 14,
    VT_ZEROPOINT = 16,
    VT_OUTPUTZEROPOINT = 18,
    VT_CLAMPMIN = 20,
    VT_CLAMPMAX = 22,
    VT_WINOGRADATTR = 24,
    VT_OUTPUTDATATYPE = 26,
    VT_FLOATZEROS = 28
  };
  const ::flatbuffers::Vector<int8_t> *weight() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_WEIGHT);
  }
  const ::flatbuffers::Vector<int32_t> *bias() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_BIAS);
  }
  const ::flatbuffers::Vector<float> *scale() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const ::flatbuffers::Vector<float> *tensorScale() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_TENSORSCALE);
  }
  MNN::QuantizeAlgo method() const {
    return static_cast<MNN::QuantizeAlgo>(GetField<int8_t>(VT_METHOD, 0));
  }
  int32_t nbits() const {
    return GetField<int32_t>(VT_NBITS, 8);
  }
  int8_t zeroPoint() const {
    return GetField<int8_t>(VT_ZEROPOINT, 0);
  }
  int8_t outputZeroPoint() const {
    return GetField<int8_t>(VT_OUTPUTZEROPOINT, 0);
  }
  int8_t clampMin() const {
    return GetField<int8_t>(VT_CLAMPMIN, -128);
  }
  int8_t clampMax() const {
    return GetField<int8_t>(VT_CLAMPMAX, 127);
  }
  const ::flatbuffers::Vector<int32_t> *winogradAttr() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_WINOGRADATTR);
  }
  MNN::DataType outputDataType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_OUTPUTDATATYPE, 6));
  }
  const ::flatbuffers::Vector<float> *floatzeros() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_FLOATZEROS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_TENSORSCALE) &&
           verifier.VerifyVector(tensorScale()) &&
           VerifyField<int8_t>(verifier, VT_METHOD, 1) &&
           VerifyField<int32_t>(verifier, VT_NBITS, 4) &&
           VerifyField<int8_t>(verifier, VT_ZEROPOINT, 1) &&
           VerifyField<int8_t>(verifier, VT_OUTPUTZEROPOINT, 1) &&
           VerifyField<int8_t>(verifier, VT_CLAMPMIN, 1) &&
           VerifyField<int8_t>(verifier, VT_CLAMPMAX, 1) &&
           VerifyOffset(verifier, VT_WINOGRADATTR) &&
           verifier.VerifyVector(winogradAttr()) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTDATATYPE, 4) &&
           VerifyOffset(verifier, VT_FLOATZEROS) &&
           verifier.VerifyVector(floatzeros()) &&
           verifier.EndTable();
  }
};

struct QuantizedFloatParamBuilder {
  typedef QuantizedFloatParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_weight(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> weight) {
    fbb_.AddOffset(QuantizedFloatParam::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> bias) {
    fbb_.AddOffset(QuantizedFloatParam::VT_BIAS, bias);
  }
  void add_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizedFloatParam::VT_SCALE, scale);
  }
  void add_tensorScale(::flatbuffers::Offset<::flatbuffers::Vector<float>> tensorScale) {
    fbb_.AddOffset(QuantizedFloatParam::VT_TENSORSCALE, tensorScale);
  }
  void add_method(MNN::QuantizeAlgo method) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_nbits(int32_t nbits) {
    fbb_.AddElement<int32_t>(QuantizedFloatParam::VT_NBITS, nbits, 8);
  }
  void add_zeroPoint(int8_t zeroPoint) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_ZEROPOINT, zeroPoint, 0);
  }
  void add_outputZeroPoint(int8_t outputZeroPoint) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_OUTPUTZEROPOINT, outputZeroPoint, 0);
  }
  void add_clampMin(int8_t clampMin) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_CLAMPMIN, clampMin, -128);
  }
  void add_clampMax(int8_t clampMax) {
    fbb_.AddElement<int8_t>(QuantizedFloatParam::VT_CLAMPMAX, clampMax, 127);
  }
  void add_winogradAttr(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> winogradAttr) {
    fbb_.AddOffset(QuantizedFloatParam::VT_WINOGRADATTR, winogradAttr);
  }
  void add_outputDataType(MNN::DataType outputDataType) {
    fbb_.AddElement<int32_t>(QuantizedFloatParam::VT_OUTPUTDATATYPE, static_cast<int32_t>(outputDataType), 6);
  }
  void add_floatzeros(::flatbuffers::Offset<::flatbuffers::Vector<float>> floatzeros) {
    fbb_.AddOffset(QuantizedFloatParam::VT_FLOATZEROS, floatzeros);
  }
  explicit QuantizedFloatParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizedFloatParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizedFloatParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> bias = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> scale = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> tensorScale = 0,
    MNN::QuantizeAlgo method = MNN::QuantizeAlgo_DEFAULT,
    int32_t nbits = 8,
    int8_t zeroPoint = 0,
    int8_t outputZeroPoint = 0,
    int8_t clampMin = -128,
    int8_t clampMax = 127,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> winogradAttr = 0,
    MNN::DataType outputDataType = MNN::DataType_DT_INT8,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> floatzeros = 0) {
  QuantizedFloatParamBuilder builder_(_fbb);
  builder_.add_floatzeros(floatzeros);
  builder_.add_outputDataType(outputDataType);
  builder_.add_winogradAttr(winogradAttr);
  builder_.add_nbits(nbits);
  builder_.add_tensorScale(tensorScale);
  builder_.add_scale(scale);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_clampMax(clampMax);
  builder_.add_clampMin(clampMin);
  builder_.add_outputZeroPoint(outputZeroPoint);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_method(method);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizedFloatParam> CreateQuantizedFloatParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *weight = nullptr,
    const std::vector<int32_t> *bias = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<float> *tensorScale = nullptr,
    MNN::QuantizeAlgo method = MNN::QuantizeAlgo_DEFAULT,
    int32_t nbits = 8,
    int8_t zeroPoint = 0,
    int8_t outputZeroPoint = 0,
    int8_t clampMin = -128,
    int8_t clampMax = 127,
    const std::vector<int32_t> *winogradAttr = nullptr,
    MNN::DataType outputDataType = MNN::DataType_DT_INT8,
    const std::vector<float> *floatzeros = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<int8_t>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<int32_t>(*bias) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  auto tensorScale__ = tensorScale ? _fbb.CreateVector<float>(*tensorScale) : 0;
  auto winogradAttr__ = winogradAttr ? _fbb.CreateVector<int32_t>(*winogradAttr) : 0;
  auto floatzeros__ = floatzeros ? _fbb.CreateVector<float>(*floatzeros) : 0;
  return MNN::CreateQuantizedFloatParam(
      _fbb,
      weight__,
      bias__,
      scale__,
      tensorScale__,
      method,
      nbits,
      zeroPoint,
      outputZeroPoint,
      clampMin,
      clampMax,
      winogradAttr__,
      outputDataType,
      floatzeros__);
}

struct Convolution2D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Convolution2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_QUANPARAMETER = 10,
    VT_SYMMETRICQUAN = 12,
    VT_SPARSEPARAMETER = 14,
    VT_EXTERNAL = 16
  };
  const MNN::Convolution2DCommon *common() const {
    return GetPointer<const MNN::Convolution2DCommon *>(VT_COMMON);
  }
  const ::flatbuffers::Vector<float> *weight() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const ::flatbuffers::Vector<float> *bias() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const MNN::IDSTQuan *quanParameter() const {
    return GetPointer<const MNN::IDSTQuan *>(VT_QUANPARAMETER);
  }
  const MNN::QuantizedFloatParam *symmetricQuan() const {
    return GetPointer<const MNN::QuantizedFloatParam *>(VT_SYMMETRICQUAN);
  }
  const MNN::SparseCommon *sparseParameter() const {
    return GetPointer<const MNN::SparseCommon *>(VT_SPARSEPARAMETER);
  }
  const ::flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_QUANPARAMETER) &&
           verifier.VerifyTable(quanParameter()) &&
           VerifyOffset(verifier, VT_SYMMETRICQUAN) &&
           verifier.VerifyTable(symmetricQuan()) &&
           VerifyOffset(verifier, VT_SPARSEPARAMETER) &&
           verifier.VerifyTable(sparseParameter()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
};

struct Convolution2DBuilder {
  typedef Convolution2D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common(::flatbuffers::Offset<MNN::Convolution2DCommon> common) {
    fbb_.AddOffset(Convolution2D::VT_COMMON, common);
  }
  void add_weight(::flatbuffers::Offset<::flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution2D::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<::flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution2D::VT_BIAS, bias);
  }
  void add_quanParameter(::flatbuffers::Offset<MNN::IDSTQuan> quanParameter) {
    fbb_.AddOffset(Convolution2D::VT_QUANPARAMETER, quanParameter);
  }
  void add_symmetricQuan(::flatbuffers::Offset<MNN::QuantizedFloatParam> symmetricQuan) {
    fbb_.AddOffset(Convolution2D::VT_SYMMETRICQUAN, symmetricQuan);
  }
  void add_sparseParameter(::flatbuffers::Offset<MNN::SparseCommon> sparseParameter) {
    fbb_.AddOffset(Convolution2D::VT_SPARSEPARAMETER, sparseParameter);
  }
  void add_external(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Convolution2D::VT_EXTERNAL, external);
  }
  explicit Convolution2DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Convolution2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Convolution2D>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Convolution2D> CreateConvolution2D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Convolution2DCommon> common = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> bias = 0,
    ::flatbuffers::Offset<MNN::IDSTQuan> quanParameter = 0,
    ::flatbuffers::Offset<MNN::QuantizedFloatParam> symmetricQuan = 0,
    ::flatbuffers::Offset<MNN::SparseCommon> sparseParameter = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external = 0) {
  Convolution2DBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_sparseParameter(sparseParameter);
  builder_.add_symmetricQuan(symmetricQuan);
  builder_.add_quanParameter(quanParameter);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Convolution2D> CreateConvolution2DDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Convolution2DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    ::flatbuffers::Offset<MNN::IDSTQuan> quanParameter = 0,
    ::flatbuffers::Offset<MNN::QuantizedFloatParam> symmetricQuan = 0,
    ::flatbuffers::Offset<MNN::SparseCommon> sparseParameter = 0,
    const std::vector<int64_t> *external = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return MNN::CreateConvolution2D(
      _fbb,
      common,
      weight__,
      bias__,
      quanParameter,
      symmetricQuan,
      sparseParameter,
      external__);
}

struct Convolution3D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Convolution3DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMON = 4,
    VT_WEIGHT = 6,
    VT_BIAS = 8,
    VT_EXTERNAL = 10
  };
  const MNN::Convolution3DCommon *common() const {
    return GetPointer<const MNN::Convolution3DCommon *>(VT_COMMON);
  }
  const ::flatbuffers::Vector<float> *weight() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const ::flatbuffers::Vector<float> *bias() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BIAS);
  }
  const ::flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMMON) &&
           verifier.VerifyTable(common()) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
};

struct Convolution3DBuilder {
  typedef Convolution3D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_common(::flatbuffers::Offset<MNN::Convolution3DCommon> common) {
    fbb_.AddOffset(Convolution3D::VT_COMMON, common);
  }
  void add_weight(::flatbuffers::Offset<::flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(Convolution3D::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<::flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(Convolution3D::VT_BIAS, bias);
  }
  void add_external(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Convolution3D::VT_EXTERNAL, external);
  }
  explicit Convolution3DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Convolution3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Convolution3D>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Convolution3D> CreateConvolution3D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Convolution3DCommon> common = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> bias = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external = 0) {
  Convolution3DBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_common(common);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Convolution3D> CreateConvolution3DDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Convolution3DCommon> common = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    const std::vector<int64_t> *external = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return MNN::CreateConvolution3D(
      _fbb,
      common,
      weight__,
      bias__,
      external__);
}

struct InnerProduct FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InnerProductBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_BIASTERM = 6,
    VT_WEIGHTSIZE = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12,
    VT_AXIS = 14,
    VT_TRANSPOSE = 16,
    VT_QUANPARAMETER = 18
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t biasTerm() const {
    return GetField<int32_t>(VT_BIASTERM, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  const ::flatbuffers::Vector<float> *weight() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const ::flatbuffers::Vector<float> *bias() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BIAS);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool transpose() const {
    return GetField<uint8_t>(VT_TRANSPOSE, 0) != 0;
  }
  const MNN::IDSTQuan *quanParameter() const {
    return GetPointer<const MNN::IDSTQuan *>(VT_QUANPARAMETER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_BIASTERM, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE, 4) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE, 1) &&
           VerifyOffset(verifier, VT_QUANPARAMETER) &&
           verifier.VerifyTable(quanParameter()) &&
           verifier.EndTable();
  }
};

struct InnerProductBuilder {
  typedef InnerProduct Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_biasTerm(int32_t biasTerm) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_BIASTERM, biasTerm, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_weight(::flatbuffers::Offset<::flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(InnerProduct::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<::flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(InnerProduct::VT_BIAS, bias);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(InnerProduct::VT_AXIS, axis, 0);
  }
  void add_transpose(bool transpose) {
    fbb_.AddElement<uint8_t>(InnerProduct::VT_TRANSPOSE, static_cast<uint8_t>(transpose), 0);
  }
  void add_quanParameter(::flatbuffers::Offset<MNN::IDSTQuan> quanParameter) {
    fbb_.AddOffset(InnerProduct::VT_QUANPARAMETER, quanParameter);
  }
  explicit InnerProductBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InnerProduct> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InnerProduct>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<InnerProduct> CreateInnerProduct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> bias = 0,
    int32_t axis = 0,
    bool transpose = false,
    ::flatbuffers::Offset<MNN::IDSTQuan> quanParameter = 0) {
  InnerProductBuilder builder_(_fbb);
  builder_.add_quanParameter(quanParameter);
  builder_.add_axis(axis);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_weightSize(weightSize);
  builder_.add_biasTerm(biasTerm);
  builder_.add_outputCount(outputCount);
  builder_.add_transpose(transpose);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InnerProduct> CreateInnerProductDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t biasTerm = 0,
    int32_t weightSize = 0,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr,
    int32_t axis = 0,
    bool transpose = false,
    ::flatbuffers::Offset<MNN::IDSTQuan> quanParameter = 0) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return MNN::CreateInnerProduct(
      _fbb,
      outputCount,
      biasTerm,
      weightSize,
      weight__,
      bias__,
      axis,
      transpose,
      quanParameter);
}

struct Pool FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PoolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADX = 4,
    VT_PADY = 6,
    VT_ISGLOBAL = 8,
    VT_KERNELX = 10,
    VT_KERNELY = 12,
    VT_STRIDEX = 14,
    VT_STRIDEY = 16,
    VT_TYPE = 18,
    VT_PADTYPE = 20,
    VT_DATATYPE = 22,
    VT_CEILMODEL = 24,
    VT_PADS = 26,
    VT_COUNTTYPE = 28
  };
  int32_t padX() const {
    return GetField<int32_t>(VT_PADX, 0);
  }
  int32_t padY() const {
    return GetField<int32_t>(VT_PADY, 0);
  }
  bool isGlobal() const {
    return GetField<uint8_t>(VT_ISGLOBAL, 0) != 0;
  }
  int32_t kernelX() const {
    return GetField<int32_t>(VT_KERNELX, 0);
  }
  int32_t kernelY() const {
    return GetField<int32_t>(VT_KERNELY, 0);
  }
  int32_t strideX() const {
    return GetField<int32_t>(VT_STRIDEX, 0);
  }
  int32_t strideY() const {
    return GetField<int32_t>(VT_STRIDEY, 0);
  }
  MNN::PoolType type() const {
    return static_cast<MNN::PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  MNN::PoolPadType padType() const {
    return static_cast<MNN::PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  MNN::DataType dataType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DATATYPE, 1));
  }
  bool ceilModel() const {
    return GetField<uint8_t>(VT_CEILMODEL, 1) != 0;
  }
  const ::flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  MNN::AvgPoolCountType countType() const {
    return static_cast<MNN::AvgPoolCountType>(GetField<int8_t>(VT_COUNTTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PADX, 4) &&
           VerifyField<int32_t>(verifier, VT_PADY, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISGLOBAL, 1) &&
           VerifyField<int32_t>(verifier, VT_KERNELX, 4) &&
           VerifyField<int32_t>(verifier, VT_KERNELY, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_STRIDEY, 4) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE, 1) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_CEILMODEL, 1) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_COUNTTYPE, 1) &&
           verifier.EndTable();
  }
};

struct PoolBuilder {
  typedef Pool Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_padX(int32_t padX) {
    fbb_.AddElement<int32_t>(Pool::VT_PADX, padX, 0);
  }
  void add_padY(int32_t padY) {
    fbb_.AddElement<int32_t>(Pool::VT_PADY, padY, 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(Pool::VT_ISGLOBAL, static_cast<uint8_t>(isGlobal), 0);
  }
  void add_kernelX(int32_t kernelX) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNELX, kernelX, 0);
  }
  void add_kernelY(int32_t kernelY) {
    fbb_.AddElement<int32_t>(Pool::VT_KERNELY, kernelY, 0);
  }
  void add_strideX(int32_t strideX) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDEX, strideX, 0);
  }
  void add_strideY(int32_t strideY) {
    fbb_.AddElement<int32_t>(Pool::VT_STRIDEY, strideY, 0);
  }
  void add_type(MNN::PoolType type) {
    fbb_.AddElement<int8_t>(Pool::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(MNN::PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pool::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  void add_dataType(MNN::DataType dataType) {
    fbb_.AddElement<int32_t>(Pool::VT_DATATYPE, static_cast<int32_t>(dataType), 1);
  }
  void add_ceilModel(bool ceilModel) {
    fbb_.AddElement<uint8_t>(Pool::VT_CEILMODEL, static_cast<uint8_t>(ceilModel), 1);
  }
  void add_pads(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pool::VT_PADS, pads);
  }
  void add_countType(MNN::AvgPoolCountType countType) {
    fbb_.AddElement<int8_t>(Pool::VT_COUNTTYPE, static_cast<int8_t>(countType), 0);
  }
  explicit PoolBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pool> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pool>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pool> CreatePool(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    MNN::PoolType type = MNN::PoolType_MAXPOOL,
    MNN::PoolPadType padType = MNN::PoolPadType_CAFFE,
    MNN::DataType dataType = MNN::DataType_DT_FLOAT,
    bool ceilModel = true,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads = 0,
    MNN::AvgPoolCountType countType = MNN::AvgPoolCountType_DEFAULT) {
  PoolBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_dataType(dataType);
  builder_.add_strideY(strideY);
  builder_.add_strideX(strideX);
  builder_.add_kernelY(kernelY);
  builder_.add_kernelX(kernelX);
  builder_.add_padY(padY);
  builder_.add_padX(padX);
  builder_.add_countType(countType);
  builder_.add_ceilModel(ceilModel);
  builder_.add_padType(padType);
  builder_.add_type(type);
  builder_.add_isGlobal(isGlobal);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pool> CreatePoolDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t padX = 0,
    int32_t padY = 0,
    bool isGlobal = false,
    int32_t kernelX = 0,
    int32_t kernelY = 0,
    int32_t strideX = 0,
    int32_t strideY = 0,
    MNN::PoolType type = MNN::PoolType_MAXPOOL,
    MNN::PoolPadType padType = MNN::PoolPadType_CAFFE,
    MNN::DataType dataType = MNN::DataType_DT_FLOAT,
    bool ceilModel = true,
    const std::vector<int32_t> *pads = nullptr,
    MNN::AvgPoolCountType countType = MNN::AvgPoolCountType_DEFAULT) {
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return MNN::CreatePool(
      _fbb,
      padX,
      padY,
      isGlobal,
      kernelX,
      kernelY,
      strideX,
      strideY,
      type,
      padType,
      dataType,
      ceilModel,
      pads__,
      countType);
}

struct Pool3D FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Pool3DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STRIDES = 4,
    VT_KERNELS = 6,
    VT_PADS = 8,
    VT_TYPE = 10,
    VT_PADTYPE = 12,
    VT_ISGLOBAL = 14
  };
  const ::flatbuffers::Vector<int32_t> *strides() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_STRIDES);
  }
  const ::flatbuffers::Vector<int32_t> *kernels() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_KERNELS);
  }
  const ::flatbuffers::Vector<int32_t> *pads() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_PADS);
  }
  MNN::PoolType type() const {
    return static_cast<MNN::PoolType>(GetField<int8_t>(VT_TYPE, 0));
  }
  MNN::PoolPadType padType() const {
    return static_cast<MNN::PoolPadType>(GetField<int8_t>(VT_PADTYPE, 0));
  }
  bool isGlobal() const {
    return GetField<uint8_t>(VT_ISGLOBAL, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_KERNELS) &&
           verifier.VerifyVector(kernels()) &&
           VerifyOffset(verifier, VT_PADS) &&
           verifier.VerifyVector(pads()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_PADTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ISGLOBAL, 1) &&
           verifier.EndTable();
  }
};

struct Pool3DBuilder {
  typedef Pool3D Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_strides(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides) {
    fbb_.AddOffset(Pool3D::VT_STRIDES, strides);
  }
  void add_kernels(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernels) {
    fbb_.AddOffset(Pool3D::VT_KERNELS, kernels);
  }
  void add_pads(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads) {
    fbb_.AddOffset(Pool3D::VT_PADS, pads);
  }
  void add_type(MNN::PoolType type) {
    fbb_.AddElement<int8_t>(Pool3D::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_padType(MNN::PoolPadType padType) {
    fbb_.AddElement<int8_t>(Pool3D::VT_PADTYPE, static_cast<int8_t>(padType), 0);
  }
  void add_isGlobal(bool isGlobal) {
    fbb_.AddElement<uint8_t>(Pool3D::VT_ISGLOBAL, static_cast<uint8_t>(isGlobal), 0);
  }
  explicit Pool3DBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Pool3D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Pool3D>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Pool3D> CreatePool3D(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> strides = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> kernels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> pads = 0,
    MNN::PoolType type = MNN::PoolType_MAXPOOL,
    MNN::PoolPadType padType = MNN::PoolPadType_CAFFE,
    bool isGlobal = false) {
  Pool3DBuilder builder_(_fbb);
  builder_.add_pads(pads);
  builder_.add_kernels(kernels);
  builder_.add_strides(strides);
  builder_.add_isGlobal(isGlobal);
  builder_.add_padType(padType);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Pool3D> CreatePool3DDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *strides = nullptr,
    const std::vector<int32_t> *kernels = nullptr,
    const std::vector<int32_t> *pads = nullptr,
    MNN::PoolType type = MNN::PoolType_MAXPOOL,
    MNN::PoolPadType padType = MNN::PoolPadType_CAFFE,
    bool isGlobal = false) {
  auto strides__ = strides ? _fbb.CreateVector<int32_t>(*strides) : 0;
  auto kernels__ = kernels ? _fbb.CreateVector<int32_t>(*kernels) : 0;
  auto pads__ = pads ? _fbb.CreateVector<int32_t>(*pads) : 0;
  return MNN::CreatePool3D(
      _fbb,
      strides__,
      kernels__,
      pads__,
      type,
      padType,
      isGlobal);
}

struct Relu FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReluBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPE = 4
  };
  float slope() const {
    return GetField<float>(VT_SLOPE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SLOPE, 4) &&
           verifier.EndTable();
  }
};

struct ReluBuilder {
  typedef Relu Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slope(float slope) {
    fbb_.AddElement<float>(Relu::VT_SLOPE, slope, 0.0f);
  }
  explicit ReluBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Relu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Relu>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Relu> CreateRelu(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float slope = 0.0f) {
  ReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  return builder_.Finish();
}

struct Relu6 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef Relu6Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINVALUE = 4,
    VT_MAXVALUE = 6
  };
  float minValue() const {
    return GetField<float>(VT_MINVALUE, 0.0f);
  }
  float maxValue() const {
    return GetField<float>(VT_MAXVALUE, 6.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MINVALUE, 4) &&
           VerifyField<float>(verifier, VT_MAXVALUE, 4) &&
           verifier.EndTable();
  }
};

struct Relu6Builder {
  typedef Relu6 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_minValue(float minValue) {
    fbb_.AddElement<float>(Relu6::VT_MINVALUE, minValue, 0.0f);
  }
  void add_maxValue(float maxValue) {
    fbb_.AddElement<float>(Relu6::VT_MAXVALUE, maxValue, 6.0f);
  }
  explicit Relu6Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Relu6> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Relu6>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Relu6> CreateRelu6(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float minValue = 0.0f,
    float maxValue = 6.0f) {
  Relu6Builder builder_(_fbb);
  builder_.add_maxValue(maxValue);
  builder_.add_minValue(minValue);
  return builder_.Finish();
}

struct PRelu FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PReluBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SLOPECOUNT = 4,
    VT_SLOPE = 6
  };
  int32_t slopeCount() const {
    return GetField<int32_t>(VT_SLOPECOUNT, 0);
  }
  const ::flatbuffers::Vector<float> *slope() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SLOPECOUNT, 4) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
};

struct PReluBuilder {
  typedef PRelu Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_slopeCount(int32_t slopeCount) {
    fbb_.AddElement<int32_t>(PRelu::VT_SLOPECOUNT, slopeCount, 0);
  }
  void add_slope(::flatbuffers::Offset<::flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PRelu::VT_SLOPE, slope);
  }
  explicit PReluBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PRelu>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PRelu> CreatePRelu(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> slope = 0) {
  PReluBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_slopeCount(slopeCount);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PRelu> CreatePReluDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t slopeCount = 0,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return MNN::CreatePRelu(
      _fbb,
      slopeCount,
      slope__);
}

struct ELU FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ELUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct ELUBuilder {
  typedef ELU Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ELU::VT_ALPHA, alpha, 0.0f);
  }
  explicit ELUBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ELU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ELU>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ELU> CreateELU(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  ELUBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct LRN FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LRNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGIONTYPE = 4,
    VT_LOCALSIZE = 6,
    VT_ALPHA = 8,
    VT_BETA = 10,
    VT_BIAS = 12
  };
  int32_t regionType() const {
    return GetField<int32_t>(VT_REGIONTYPE, 0);
  }
  int32_t localSize() const {
    return GetField<int32_t>(VT_LOCALSIZE, 0);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REGIONTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_LOCALSIZE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           VerifyField<float>(verifier, VT_BETA, 4) &&
           VerifyField<float>(verifier, VT_BIAS, 4) &&
           verifier.EndTable();
  }
};

struct LRNBuilder {
  typedef LRN Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_regionType(int32_t regionType) {
    fbb_.AddElement<int32_t>(LRN::VT_REGIONTYPE, regionType, 0);
  }
  void add_localSize(int32_t localSize) {
    fbb_.AddElement<int32_t>(LRN::VT_LOCALSIZE, localSize, 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 1.0f);
  }
  explicit LRNBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LRN> CreateLRN(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t regionType = 0,
    int32_t localSize = 0,
    float alpha = 0.0f,
    float beta = 0.0f,
    float bias = 1.0f) {
  LRNBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_localSize(localSize);
  builder_.add_regionType(regionType);
  return builder_.Finish();
}

struct ArgMax FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArgMaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTMAXVAL = 4,
    VT_TOPK = 6,
    VT_AXIS = 8,
    VT_SOFTMAXTHRESHOLD = 10
  };
  int32_t outMaxVal() const {
    return GetField<int32_t>(VT_OUTMAXVAL, 0);
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t softmaxThreshold() const {
    return GetField<int32_t>(VT_SOFTMAXTHRESHOLD, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTMAXVAL, 4) &&
           VerifyField<int32_t>(verifier, VT_TOPK, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_SOFTMAXTHRESHOLD, 4) &&
           verifier.EndTable();
  }
};

struct ArgMaxBuilder {
  typedef ArgMax Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_outMaxVal(int32_t outMaxVal) {
    fbb_.AddElement<int32_t>(ArgMax::VT_OUTMAXVAL, outMaxVal, 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOPK, topK, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_softmaxThreshold(int32_t softmaxThreshold) {
    fbb_.AddElement<int32_t>(ArgMax::VT_SOFTMAXTHRESHOLD, softmaxThreshold, 0);
  }
  explicit ArgMaxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ArgMax> CreateArgMax(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outMaxVal = 0,
    int32_t topK = 0,
    int32_t axis = 0,
    int32_t softmaxThreshold = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_softmaxThreshold(softmaxThreshold);
  builder_.add_axis(axis);
  builder_.add_topK(topK);
  builder_.add_outMaxVal(outMaxVal);
  return builder_.Finish();
}

struct Axis FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AxisBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct AxisBuilder {
  typedef Axis Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Axis::VT_AXIS, axis, 0);
  }
  explicit AxisBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Axis> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Axis>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Axis> CreateAxis(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  AxisBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Input FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DTYPE = 6,
    VT_DFORMAT = 8
  };
  const ::flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  MNN::DataType dtype() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  MNN::MNN_DATA_FORMAT dformat() const {
    return static_cast<MNN::MNN_DATA_FORMAT>(GetField<int8_t>(VT_DFORMAT, 2));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           VerifyField<int8_t>(verifier, VT_DFORMAT, 1) &&
           verifier.EndTable();
  }
};

struct InputBuilder {
  typedef Input Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Input::VT_DIMS, dims);
  }
  void add_dtype(MNN::DataType dtype) {
    fbb_.AddElement<int32_t>(Input::VT_DTYPE, static_cast<int32_t>(dtype), 1);
  }
  void add_dformat(MNN::MNN_DATA_FORMAT dformat) {
    fbb_.AddElement<int8_t>(Input::VT_DFORMAT, static_cast<int8_t>(dformat), 2);
  }
  explicit InputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Input> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Input>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Input> CreateInput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims = 0,
    MNN::DataType dtype = MNN::DataType_DT_FLOAT,
    MNN::MNN_DATA_FORMAT dformat = MNN::MNN_DATA_FORMAT_NC4HW4) {
  InputBuilder builder_(_fbb);
  builder_.add_dtype(dtype);
  builder_.add_dims(dims);
  builder_.add_dformat(dformat);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Input> CreateInputDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    MNN::DataType dtype = MNN::DataType_DT_FLOAT,
    MNN::MNN_DATA_FORMAT dformat = MNN::MNN_DATA_FORMAT_NC4HW4) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return MNN::CreateInput(
      _fbb,
      dims__,
      dtype,
      dformat);
}

struct LSTM FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LSTMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTCOUNT = 4,
    VT_WEIGHTSIZE = 6,
    VT_CLIPPINGTHRESHOLD = 8,
    VT_WEIGHTI = 10,
    VT_WEIGHTH = 12,
    VT_BIAS = 14,
    VT_WEIGHTIQ = 16,
    VT_WEIGHTIA = 18,
    VT_QUANTSCALE = 20
  };
  int32_t outputCount() const {
    return GetField<int32_t>(VT_OUTPUTCOUNT, 0);
  }
  int32_t weightSize() const {
    return GetField<int32_t>(VT_WEIGHTSIZE, 0);
  }
  float clippingThreshold() const {
    return GetField<float>(VT_CLIPPINGTHRESHOLD, 0.0f);
  }
  const MNN::Blob *weightI() const {
    return GetPointer<const MNN::Blob *>(VT_WEIGHTI);
  }
  const MNN::Blob *weightH() const {
    return GetPointer<const MNN::Blob *>(VT_WEIGHTH);
  }
  const MNN::Blob *bias() const {
    return GetPointer<const MNN::Blob *>(VT_BIAS);
  }
  const MNN::Blob *weightIQ() const {
    return GetPointer<const MNN::Blob *>(VT_WEIGHTIQ);
  }
  const MNN::Blob *weightIA() const {
    return GetPointer<const MNN::Blob *>(VT_WEIGHTIA);
  }
  float quantScale() const {
    return GetField<float>(VT_QUANTSCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTCOUNT, 4) &&
           VerifyField<int32_t>(verifier, VT_WEIGHTSIZE, 4) &&
           VerifyField<float>(verifier, VT_CLIPPINGTHRESHOLD, 4) &&
           VerifyOffset(verifier, VT_WEIGHTI) &&
           verifier.VerifyTable(weightI()) &&
           VerifyOffset(verifier, VT_WEIGHTH) &&
           verifier.VerifyTable(weightH()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyTable(bias()) &&
           VerifyOffset(verifier, VT_WEIGHTIQ) &&
           verifier.VerifyTable(weightIQ()) &&
           VerifyOffset(verifier, VT_WEIGHTIA) &&
           verifier.VerifyTable(weightIA()) &&
           VerifyField<float>(verifier, VT_QUANTSCALE, 4) &&
           verifier.EndTable();
  }
};

struct LSTMBuilder {
  typedef LSTM Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_outputCount(int32_t outputCount) {
    fbb_.AddElement<int32_t>(LSTM::VT_OUTPUTCOUNT, outputCount, 0);
  }
  void add_weightSize(int32_t weightSize) {
    fbb_.AddElement<int32_t>(LSTM::VT_WEIGHTSIZE, weightSize, 0);
  }
  void add_clippingThreshold(float clippingThreshold) {
    fbb_.AddElement<float>(LSTM::VT_CLIPPINGTHRESHOLD, clippingThreshold, 0.0f);
  }
  void add_weightI(::flatbuffers::Offset<MNN::Blob> weightI) {
    fbb_.AddOffset(LSTM::VT_WEIGHTI, weightI);
  }
  void add_weightH(::flatbuffers::Offset<MNN::Blob> weightH) {
    fbb_.AddOffset(LSTM::VT_WEIGHTH, weightH);
  }
  void add_bias(::flatbuffers::Offset<MNN::Blob> bias) {
    fbb_.AddOffset(LSTM::VT_BIAS, bias);
  }
  void add_weightIQ(::flatbuffers::Offset<MNN::Blob> weightIQ) {
    fbb_.AddOffset(LSTM::VT_WEIGHTIQ, weightIQ);
  }
  void add_weightIA(::flatbuffers::Offset<MNN::Blob> weightIA) {
    fbb_.AddOffset(LSTM::VT_WEIGHTIA, weightIA);
  }
  void add_quantScale(float quantScale) {
    fbb_.AddElement<float>(LSTM::VT_QUANTSCALE, quantScale, 0.0f);
  }
  explicit LSTMBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSTM>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSTM> CreateLSTM(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputCount = 0,
    int32_t weightSize = 0,
    float clippingThreshold = 0.0f,
    ::flatbuffers::Offset<MNN::Blob> weightI = 0,
    ::flatbuffers::Offset<MNN::Blob> weightH = 0,
    ::flatbuffers::Offset<MNN::Blob> bias = 0,
    ::flatbuffers::Offset<MNN::Blob> weightIQ = 0,
    ::flatbuffers::Offset<MNN::Blob> weightIA = 0,
    float quantScale = 0.0f) {
  LSTMBuilder builder_(_fbb);
  builder_.add_quantScale(quantScale);
  builder_.add_weightIA(weightIA);
  builder_.add_weightIQ(weightIQ);
  builder_.add_bias(bias);
  builder_.add_weightH(weightH);
  builder_.add_weightI(weightI);
  builder_.add_clippingThreshold(clippingThreshold);
  builder_.add_weightSize(weightSize);
  builder_.add_outputCount(outputCount);
  return builder_.Finish();
}

struct Slice FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_SLICEPOINTS = 6,
    VT_SOURCETYPE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const ::flatbuffers::Vector<int32_t> *slicePoints() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SLICEPOINTS);
  }
  MNN::NetSource sourceType() const {
    return static_cast<MNN::NetSource>(GetField<int8_t>(VT_SOURCETYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyOffset(verifier, VT_SLICEPOINTS) &&
           verifier.VerifyVector(slicePoints()) &&
           VerifyField<int8_t>(verifier, VT_SOURCETYPE, 1) &&
           verifier.EndTable();
  }
};

struct SliceBuilder {
  typedef Slice Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Slice::VT_AXIS, axis, 0);
  }
  void add_slicePoints(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> slicePoints) {
    fbb_.AddOffset(Slice::VT_SLICEPOINTS, slicePoints);
  }
  void add_sourceType(MNN::NetSource sourceType) {
    fbb_.AddElement<int8_t>(Slice::VT_SOURCETYPE, static_cast<int8_t>(sourceType), 0);
  }
  explicit SliceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Slice> CreateSlice(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> slicePoints = 0,
    MNN::NetSource sourceType = MNN::NetSource_CAFFE) {
  SliceBuilder builder_(_fbb);
  builder_.add_slicePoints(slicePoints);
  builder_.add_axis(axis);
  builder_.add_sourceType(sourceType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Slice> CreateSliceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    const std::vector<int32_t> *slicePoints = nullptr,
    MNN::NetSource sourceType = MNN::NetSource_CAFFE) {
  auto slicePoints__ = slicePoints ? _fbb.CreateVector<int32_t>(*slicePoints) : 0;
  return MNN::CreateSlice(
      _fbb,
      axis,
      slicePoints__,
      sourceType);
}

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SLOPEDATA = 6,
    VT_MEANDATA = 8,
    VT_VARDATA = 10,
    VT_BIASDATA = 12,
    VT_ADATA = 14,
    VT_BDATA = 16,
    VT_EPSILON = 18
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const ::flatbuffers::Vector<float> *slopeData() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SLOPEDATA);
  }
  const ::flatbuffers::Vector<float> *meanData() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MEANDATA);
  }
  const ::flatbuffers::Vector<float> *varData() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VARDATA);
  }
  const ::flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  const ::flatbuffers::Vector<float> *Adata() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ADATA);
  }
  const ::flatbuffers::Vector<float> *Bdata() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BDATA);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.001f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SLOPEDATA) &&
           verifier.VerifyVector(slopeData()) &&
           VerifyOffset(verifier, VT_MEANDATA) &&
           verifier.VerifyVector(meanData()) &&
           VerifyOffset(verifier, VT_VARDATA) &&
           verifier.VerifyVector(varData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, VT_ADATA) &&
           verifier.VerifyVector(Adata()) &&
           VerifyOffset(verifier, VT_BDATA) &&
           verifier.VerifyVector(Bdata()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           verifier.EndTable();
  }
};

struct BatchNormBuilder {
  typedef BatchNorm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(BatchNorm::VT_CHANNELS, channels, 0);
  }
  void add_slopeData(::flatbuffers::Offset<::flatbuffers::Vector<float>> slopeData) {
    fbb_.AddOffset(BatchNorm::VT_SLOPEDATA, slopeData);
  }
  void add_meanData(::flatbuffers::Offset<::flatbuffers::Vector<float>> meanData) {
    fbb_.AddOffset(BatchNorm::VT_MEANDATA, meanData);
  }
  void add_varData(::flatbuffers::Offset<::flatbuffers::Vector<float>> varData) {
    fbb_.AddOffset(BatchNorm::VT_VARDATA, varData);
  }
  void add_biasData(::flatbuffers::Offset<::flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(BatchNorm::VT_BIASDATA, biasData);
  }
  void add_Adata(::flatbuffers::Offset<::flatbuffers::Vector<float>> Adata) {
    fbb_.AddOffset(BatchNorm::VT_ADATA, Adata);
  }
  void add_Bdata(::flatbuffers::Offset<::flatbuffers::Vector<float>> Bdata) {
    fbb_.AddOffset(BatchNorm::VT_BDATA, Bdata);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.001f);
  }
  explicit BatchNormBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> slopeData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> meanData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> varData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> biasData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> Adata = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> Bdata = 0,
    float epsilon = 0.001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_Bdata(Bdata);
  builder_.add_Adata(Adata);
  builder_.add_biasData(biasData);
  builder_.add_varData(varData);
  builder_.add_meanData(meanData);
  builder_.add_slopeData(slopeData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<BatchNorm> CreateBatchNormDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *slopeData = nullptr,
    const std::vector<float> *meanData = nullptr,
    const std::vector<float> *varData = nullptr,
    const std::vector<float> *biasData = nullptr,
    const std::vector<float> *Adata = nullptr,
    const std::vector<float> *Bdata = nullptr,
    float epsilon = 0.001f) {
  auto slopeData__ = slopeData ? _fbb.CreateVector<float>(*slopeData) : 0;
  auto meanData__ = meanData ? _fbb.CreateVector<float>(*meanData) : 0;
  auto varData__ = varData ? _fbb.CreateVector<float>(*varData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  auto Adata__ = Adata ? _fbb.CreateVector<float>(*Adata) : 0;
  auto Bdata__ = Bdata ? _fbb.CreateVector<float>(*Bdata) : 0;
  return MNN::CreateBatchNorm(
      _fbb,
      channels,
      slopeData__,
      meanData__,
      varData__,
      biasData__,
      Adata__,
      Bdata__,
      epsilon);
}

struct Scale FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ScaleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELS = 4,
    VT_SCALEDATA = 6,
    VT_BIASDATA = 8,
    VT_EXTERNAL = 10
  };
  int32_t channels() const {
    return GetField<int32_t>(VT_CHANNELS, 0);
  }
  const ::flatbuffers::Vector<float> *scaleData() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALEDATA);
  }
  const ::flatbuffers::Vector<float> *biasData() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BIASDATA);
  }
  const ::flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CHANNELS, 4) &&
           VerifyOffset(verifier, VT_SCALEDATA) &&
           verifier.VerifyVector(scaleData()) &&
           VerifyOffset(verifier, VT_BIASDATA) &&
           verifier.VerifyVector(biasData()) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
};

struct ScaleBuilder {
  typedef Scale Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_channels(int32_t channels) {
    fbb_.AddElement<int32_t>(Scale::VT_CHANNELS, channels, 0);
  }
  void add_scaleData(::flatbuffers::Offset<::flatbuffers::Vector<float>> scaleData) {
    fbb_.AddOffset(Scale::VT_SCALEDATA, scaleData);
  }
  void add_biasData(::flatbuffers::Offset<::flatbuffers::Vector<float>> biasData) {
    fbb_.AddOffset(Scale::VT_BIASDATA, biasData);
  }
  void add_external(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(Scale::VT_EXTERNAL, external);
  }
  explicit ScaleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Scale> CreateScale(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> scaleData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> biasData = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external = 0) {
  ScaleBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_biasData(biasData);
  builder_.add_scaleData(scaleData);
  builder_.add_channels(channels);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Scale> CreateScaleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t channels = 0,
    const std::vector<float> *scaleData = nullptr,
    const std::vector<float> *biasData = nullptr,
    const std::vector<int64_t> *external = nullptr) {
  auto scaleData__ = scaleData ? _fbb.CreateVector<float>(*scaleData) : 0;
  auto biasData__ = biasData ? _fbb.CreateVector<float>(*biasData) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return MNN::CreateScale(
      _fbb,
      channels,
      scaleData__,
      biasData__,
      external__);
}

struct Eltwise FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EltwiseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_COEFF = 6
  };
  MNN::EltwiseType type() const {
    return static_cast<MNN::EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<float> *coeff() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_COEFF);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_COEFF) &&
           verifier.VerifyVector(coeff()) &&
           verifier.EndTable();
  }
};

struct EltwiseBuilder {
  typedef Eltwise Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(MNN::EltwiseType type) {
    fbb_.AddElement<int8_t>(Eltwise::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_coeff(::flatbuffers::Offset<::flatbuffers::Vector<float>> coeff) {
    fbb_.AddOffset(Eltwise::VT_COEFF, coeff);
  }
  explicit EltwiseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Eltwise> CreateEltwise(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::EltwiseType type = MNN::EltwiseType_PROD,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> coeff = 0) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Eltwise> CreateEltwiseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::EltwiseType type = MNN::EltwiseType_PROD,
    const std::vector<float> *coeff = nullptr) {
  auto coeff__ = coeff ? _fbb.CreateVector<float>(*coeff) : 0;
  return MNN::CreateEltwise(
      _fbb,
      type,
      coeff__);
}

struct Flatten FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FlattenBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ENDAXIS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t endAxis() const {
    return GetField<int32_t>(VT_ENDAXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDAXIS, 4) &&
           verifier.EndTable();
  }
};

struct FlattenBuilder {
  typedef Flatten Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Flatten::VT_AXIS, axis, 0);
  }
  void add_endAxis(int32_t endAxis) {
    fbb_.AddElement<int32_t>(Flatten::VT_ENDAXIS, endAxis, 0);
  }
  explicit FlattenBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Flatten> CreateFlatten(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t endAxis = 0) {
  FlattenBuilder builder_(_fbb);
  builder_.add_endAxis(endAxis);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Permute FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PermuteBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct PermuteBuilder {
  typedef Permute Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Permute::VT_DIMS, dims);
  }
  explicit PermuteBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Permute> CreatePermute(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Permute> CreatePermuteDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return MNN::CreatePermute(
      _fbb,
      dims__);
}

struct Reshape FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReshapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4,
    VT_DIMTYPE = 6
  };
  const ::flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  MNN::MNN_DATA_FORMAT dimType() const {
    return static_cast<MNN::MNN_DATA_FORMAT>(GetField<int8_t>(VT_DIMTYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int8_t>(verifier, VT_DIMTYPE, 1) &&
           verifier.EndTable();
  }
};

struct ReshapeBuilder {
  typedef Reshape Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Reshape::VT_DIMS, dims);
  }
  void add_dimType(MNN::MNN_DATA_FORMAT dimType) {
    fbb_.AddElement<int8_t>(Reshape::VT_DIMTYPE, static_cast<int8_t>(dimType), 0);
  }
  explicit ReshapeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Reshape> CreateReshape(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dims = 0,
    MNN::MNN_DATA_FORMAT dimType = MNN::MNN_DATA_FORMAT_NCHW) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimType(dimType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Reshape> CreateReshapeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr,
    MNN::MNN_DATA_FORMAT dimType = MNN::MNN_DATA_FORMAT_NCHW) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return MNN::CreateReshape(
      _fbb,
      dims__,
      dimType);
}

struct DetectionOutput FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectionOutputBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLASSCOUNT = 4,
    VT_NMSTHRESHOLDOLD = 6,
    VT_NMSTOPK = 8,
    VT_KEEPTOPK = 10,
    VT_CONFIDENCETHRESHOLD = 12,
    VT_SHARELOCATION = 14,
    VT_BACKGROUNDLABLE = 16,
    VT_VARIANCEENCODEDTARGET = 18,
    VT_CODETYPE = 20,
    VT_OBJECTNESSSCORE = 22
  };
  int32_t classCount() const {
    return GetField<int32_t>(VT_CLASSCOUNT, 0);
  }
  float nmsThresholdold() const {
    return GetField<float>(VT_NMSTHRESHOLDOLD, 0.0f);
  }
  int32_t nmsTopK() const {
    return GetField<int32_t>(VT_NMSTOPK, 0);
  }
  int32_t keepTopK() const {
    return GetField<int32_t>(VT_KEEPTOPK, 0);
  }
  float confidenceThreshold() const {
    return GetField<float>(VT_CONFIDENCETHRESHOLD, 0.0f);
  }
  int32_t shareLocation() const {
    return GetField<int32_t>(VT_SHARELOCATION, 0);
  }
  int32_t backgroundLable() const {
    return GetField<int32_t>(VT_BACKGROUNDLABLE, 0);
  }
  int32_t varianceEncodedTarget() const {
    return GetField<int32_t>(VT_VARIANCEENCODEDTARGET, 0);
  }
  int32_t codeType() const {
    return GetField<int32_t>(VT_CODETYPE, 0);
  }
  float objectnessScore() const {
    return GetField<float>(VT_OBJECTNESSSCORE, 0.01f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CLASSCOUNT, 4) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLDOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_NMSTOPK, 4) &&
           VerifyField<int32_t>(verifier, VT_KEEPTOPK, 4) &&
           VerifyField<float>(verifier, VT_CONFIDENCETHRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_SHARELOCATION, 4) &&
           VerifyField<int32_t>(verifier, VT_BACKGROUNDLABLE, 4) &&
           VerifyField<int32_t>(verifier, VT_VARIANCEENCODEDTARGET, 4) &&
           VerifyField<int32_t>(verifier, VT_CODETYPE, 4) &&
           VerifyField<float>(verifier, VT_OBJECTNESSSCORE, 4) &&
           verifier.EndTable();
  }
};

struct DetectionOutputBuilder {
  typedef DetectionOutput Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_classCount(int32_t classCount) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_CLASSCOUNT, classCount, 0);
  }
  void add_nmsThresholdold(float nmsThresholdold) {
    fbb_.AddElement<float>(DetectionOutput::VT_NMSTHRESHOLDOLD, nmsThresholdold, 0.0f);
  }
  void add_nmsTopK(int32_t nmsTopK) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_NMSTOPK, nmsTopK, 0);
  }
  void add_keepTopK(int32_t keepTopK) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_KEEPTOPK, keepTopK, 0);
  }
  void add_confidenceThreshold(float confidenceThreshold) {
    fbb_.AddElement<float>(DetectionOutput::VT_CONFIDENCETHRESHOLD, confidenceThreshold, 0.0f);
  }
  void add_shareLocation(int32_t shareLocation) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_SHARELOCATION, shareLocation, 0);
  }
  void add_backgroundLable(int32_t backgroundLable) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_BACKGROUNDLABLE, backgroundLable, 0);
  }
  void add_varianceEncodedTarget(int32_t varianceEncodedTarget) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_VARIANCEENCODEDTARGET, varianceEncodedTarget, 0);
  }
  void add_codeType(int32_t codeType) {
    fbb_.AddElement<int32_t>(DetectionOutput::VT_CODETYPE, codeType, 0);
  }
  void add_objectnessScore(float objectnessScore) {
    fbb_.AddElement<float>(DetectionOutput::VT_OBJECTNESSSCORE, objectnessScore, 0.01f);
  }
  explicit DetectionOutputBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DetectionOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DetectionOutput>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DetectionOutput> CreateDetectionOutput(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t classCount = 0,
    float nmsThresholdold = 0.0f,
    int32_t nmsTopK = 0,
    int32_t keepTopK = 0,
    float confidenceThreshold = 0.0f,
    int32_t shareLocation = 0,
    int32_t backgroundLable = 0,
    int32_t varianceEncodedTarget = 0,
    int32_t codeType = 0,
    float objectnessScore = 0.01f) {
  DetectionOutputBuilder builder_(_fbb);
  builder_.add_objectnessScore(objectnessScore);
  builder_.add_codeType(codeType);
  builder_.add_varianceEncodedTarget(varianceEncodedTarget);
  builder_.add_backgroundLable(backgroundLable);
  builder_.add_shareLocation(shareLocation);
  builder_.add_confidenceThreshold(confidenceThreshold);
  builder_.add_keepTopK(keepTopK);
  builder_.add_nmsTopK(nmsTopK);
  builder_.add_nmsThresholdold(nmsThresholdold);
  builder_.add_classCount(classCount);
  return builder_.Finish();
}

struct RoiParameters FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RoiParametersBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLEDWIDTH = 4,
    VT_POOLEDHEIGHT = 6,
    VT_SPATIALSCALE = 8,
    VT_SAMPLINGRATIO = 10,
    VT_ALIGNED = 12,
    VT_POOLTYPE = 14,
    VT_OUTPUTGRAD = 16
  };
  int32_t pooledWidth() const {
    return GetField<int32_t>(VT_POOLEDWIDTH, 0);
  }
  int32_t pooledHeight() const {
    return GetField<int32_t>(VT_POOLEDHEIGHT, 0);
  }
  float spatialScale() const {
    return GetField<float>(VT_SPATIALSCALE, 0.0f);
  }
  int32_t samplingRatio() const {
    return GetField<int32_t>(VT_SAMPLINGRATIO, -1);
  }
  bool aligned() const {
    return GetField<uint8_t>(VT_ALIGNED, 0) != 0;
  }
  MNN::PoolType poolType() const {
    return static_cast<MNN::PoolType>(GetField<int8_t>(VT_POOLTYPE, 1));
  }
  bool outputGrad() const {
    return GetField<uint8_t>(VT_OUTPUTGRAD, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POOLEDWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_POOLEDHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_SPATIALSCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_SAMPLINGRATIO, 4) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNED, 1) &&
           VerifyField<int8_t>(verifier, VT_POOLTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUTGRAD, 1) &&
           verifier.EndTable();
  }
};

struct RoiParametersBuilder {
  typedef RoiParameters Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_pooledWidth(int32_t pooledWidth) {
    fbb_.AddElement<int32_t>(RoiParameters::VT_POOLEDWIDTH, pooledWidth, 0);
  }
  void add_pooledHeight(int32_t pooledHeight) {
    fbb_.AddElement<int32_t>(RoiParameters::VT_POOLEDHEIGHT, pooledHeight, 0);
  }
  void add_spatialScale(float spatialScale) {
    fbb_.AddElement<float>(RoiParameters::VT_SPATIALSCALE, spatialScale, 0.0f);
  }
  void add_samplingRatio(int32_t samplingRatio) {
    fbb_.AddElement<int32_t>(RoiParameters::VT_SAMPLINGRATIO, samplingRatio, -1);
  }
  void add_aligned(bool aligned) {
    fbb_.AddElement<uint8_t>(RoiParameters::VT_ALIGNED, static_cast<uint8_t>(aligned), 0);
  }
  void add_poolType(MNN::PoolType poolType) {
    fbb_.AddElement<int8_t>(RoiParameters::VT_POOLTYPE, static_cast<int8_t>(poolType), 1);
  }
  void add_outputGrad(bool outputGrad) {
    fbb_.AddElement<uint8_t>(RoiParameters::VT_OUTPUTGRAD, static_cast<uint8_t>(outputGrad), 0);
  }
  explicit RoiParametersBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RoiParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RoiParameters>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RoiParameters> CreateRoiParameters(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledWidth = 0,
    int32_t pooledHeight = 0,
    float spatialScale = 0.0f,
    int32_t samplingRatio = -1,
    bool aligned = false,
    MNN::PoolType poolType = MNN::PoolType_AVEPOOL,
    bool outputGrad = false) {
  RoiParametersBuilder builder_(_fbb);
  builder_.add_samplingRatio(samplingRatio);
  builder_.add_spatialScale(spatialScale);
  builder_.add_pooledHeight(pooledHeight);
  builder_.add_pooledWidth(pooledWidth);
  builder_.add_outputGrad(outputGrad);
  builder_.add_poolType(poolType);
  builder_.add_aligned(aligned);
  return builder_.Finish();
}

struct Proposal FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProposalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEATSTRIDE = 4,
    VT_BASESIZE = 6,
    VT_PRENMSTOPN = 8,
    VT_AFTERNMSTOPN = 10,
    VT_NMSTHRESHOLD = 12,
    VT_MINSIZE = 14,
    VT_RATIOS = 16,
    VT_SCALES = 18,
    VT_ANCHORS = 20
  };
  int32_t featStride() const {
    return GetField<int32_t>(VT_FEATSTRIDE, 0);
  }
  int32_t baseSize() const {
    return GetField<int32_t>(VT_BASESIZE, 0);
  }
  int32_t preNmsTopN() const {
    return GetField<int32_t>(VT_PRENMSTOPN, 0);
  }
  int32_t afterNmsTopN() const {
    return GetField<int32_t>(VT_AFTERNMSTOPN, 0);
  }
  float nmsThreshold() const {
    return GetField<float>(VT_NMSTHRESHOLD, 0.0f);
  }
  int32_t minSize() const {
    return GetField<int32_t>(VT_MINSIZE, 0);
  }
  const MNN::Blob *ratios() const {
    return GetPointer<const MNN::Blob *>(VT_RATIOS);
  }
  const MNN::Blob *scales() const {
    return GetPointer<const MNN::Blob *>(VT_SCALES);
  }
  const MNN::Blob *anchors() const {
    return GetPointer<const MNN::Blob *>(VT_ANCHORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FEATSTRIDE, 4) &&
           VerifyField<int32_t>(verifier, VT_BASESIZE, 4) &&
           VerifyField<int32_t>(verifier, VT_PRENMSTOPN, 4) &&
           VerifyField<int32_t>(verifier, VT_AFTERNMSTOPN, 4) &&
           VerifyField<float>(verifier, VT_NMSTHRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_MINSIZE, 4) &&
           VerifyOffset(verifier, VT_RATIOS) &&
           verifier.VerifyTable(ratios()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyTable(scales()) &&
           VerifyOffset(verifier, VT_ANCHORS) &&
           verifier.VerifyTable(anchors()) &&
           verifier.EndTable();
  }
};

struct ProposalBuilder {
  typedef Proposal Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_featStride(int32_t featStride) {
    fbb_.AddElement<int32_t>(Proposal::VT_FEATSTRIDE, featStride, 0);
  }
  void add_baseSize(int32_t baseSize) {
    fbb_.AddElement<int32_t>(Proposal::VT_BASESIZE, baseSize, 0);
  }
  void add_preNmsTopN(int32_t preNmsTopN) {
    fbb_.AddElement<int32_t>(Proposal::VT_PRENMSTOPN, preNmsTopN, 0);
  }
  void add_afterNmsTopN(int32_t afterNmsTopN) {
    fbb_.AddElement<int32_t>(Proposal::VT_AFTERNMSTOPN, afterNmsTopN, 0);
  }
  void add_nmsThreshold(float nmsThreshold) {
    fbb_.AddElement<float>(Proposal::VT_NMSTHRESHOLD, nmsThreshold, 0.0f);
  }
  void add_minSize(int32_t minSize) {
    fbb_.AddElement<int32_t>(Proposal::VT_MINSIZE, minSize, 0);
  }
  void add_ratios(::flatbuffers::Offset<MNN::Blob> ratios) {
    fbb_.AddOffset(Proposal::VT_RATIOS, ratios);
  }
  void add_scales(::flatbuffers::Offset<MNN::Blob> scales) {
    fbb_.AddOffset(Proposal::VT_SCALES, scales);
  }
  void add_anchors(::flatbuffers::Offset<MNN::Blob> anchors) {
    fbb_.AddOffset(Proposal::VT_ANCHORS, anchors);
  }
  explicit ProposalBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Proposal> CreateProposal(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t featStride = 0,
    int32_t baseSize = 0,
    int32_t preNmsTopN = 0,
    int32_t afterNmsTopN = 0,
    float nmsThreshold = 0.0f,
    int32_t minSize = 0,
    ::flatbuffers::Offset<MNN::Blob> ratios = 0,
    ::flatbuffers::Offset<MNN::Blob> scales = 0,
    ::flatbuffers::Offset<MNN::Blob> anchors = 0) {
  ProposalBuilder builder_(_fbb);
  builder_.add_anchors(anchors);
  builder_.add_scales(scales);
  builder_.add_ratios(ratios);
  builder_.add_minSize(minSize);
  builder_.add_nmsThreshold(nmsThreshold);
  builder_.add_afterNmsTopN(afterNmsTopN);
  builder_.add_preNmsTopN(preNmsTopN);
  builder_.add_baseSize(baseSize);
  builder_.add_featStride(featStride);
  return builder_.Finish();
}

struct Interp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InterpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WIDTHSCALE = 4,
    VT_HEIGHTSCALE = 6,
    VT_OUTPUTWIDTH = 8,
    VT_OUTPUTHEIGHT = 10,
    VT_RESIZETYPE = 12,
    VT_ALIGNCORNERS = 14,
    VT_HALFPIXELCENTERS = 16,
    VT_WIDTHOFFSET = 18,
    VT_HEIGHTOFFSET = 20,
    VT_CUBICCOEFFA = 22,
    VT_CTM = 24,
    VT_DEPTHSCALE = 26,
    VT_OUTPUTDEPTH = 28,
    VT_DEPTHOFFSET = 30
  };
  float widthScale() const {
    return GetField<float>(VT_WIDTHSCALE, 0.0f);
  }
  float heightScale() const {
    return GetField<float>(VT_HEIGHTSCALE, 0.0f);
  }
  int32_t outputWidth() const {
    return GetField<int32_t>(VT_OUTPUTWIDTH, 0);
  }
  int32_t outputHeight() const {
    return GetField<int32_t>(VT_OUTPUTHEIGHT, 0);
  }
  int32_t resizeType() const {
    return GetField<int32_t>(VT_RESIZETYPE, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool halfPixelCenters() const {
    return GetField<uint8_t>(VT_HALFPIXELCENTERS, 0) != 0;
  }
  float widthOffset() const {
    return GetField<float>(VT_WIDTHOFFSET, 0.0f);
  }
  float heightOffset() const {
    return GetField<float>(VT_HEIGHTOFFSET, 0.0f);
  }
  float cubicCoeffA() const {
    return GetField<float>(VT_CUBICCOEFFA, -0.75f);
  }
  MNN::CoordinateTransformationMode ctm() const {
    return static_cast<MNN::CoordinateTransformationMode>(GetField<int8_t>(VT_CTM, 0));
  }
  float depthScale() const {
    return GetField<float>(VT_DEPTHSCALE, 0.0f);
  }
  int32_t outputDepth() const {
    return GetField<int32_t>(VT_OUTPUTDEPTH, 0);
  }
  float depthOffset() const {
    return GetField<float>(VT_DEPTHOFFSET, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WIDTHSCALE, 4) &&
           VerifyField<float>(verifier, VT_HEIGHTSCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_RESIZETYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS, 1) &&
           VerifyField<uint8_t>(verifier, VT_HALFPIXELCENTERS, 1) &&
           VerifyField<float>(verifier, VT_WIDTHOFFSET, 4) &&
           VerifyField<float>(verifier, VT_HEIGHTOFFSET, 4) &&
           VerifyField<float>(verifier, VT_CUBICCOEFFA, 4) &&
           VerifyField<int8_t>(verifier, VT_CTM, 1) &&
           VerifyField<float>(verifier, VT_DEPTHSCALE, 4) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTDEPTH, 4) &&
           VerifyField<float>(verifier, VT_DEPTHOFFSET, 4) &&
           verifier.EndTable();
  }
};

struct InterpBuilder {
  typedef Interp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_widthScale(float widthScale) {
    fbb_.AddElement<float>(Interp::VT_WIDTHSCALE, widthScale, 0.0f);
  }
  void add_heightScale(float heightScale) {
    fbb_.AddElement<float>(Interp::VT_HEIGHTSCALE, heightScale, 0.0f);
  }
  void add_outputWidth(int32_t outputWidth) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTWIDTH, outputWidth, 0);
  }
  void add_outputHeight(int32_t outputHeight) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTHEIGHT, outputHeight, 0);
  }
  void add_resizeType(int32_t resizeType) {
    fbb_.AddElement<int32_t>(Interp::VT_RESIZETYPE, resizeType, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(Interp::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_halfPixelCenters(bool halfPixelCenters) {
    fbb_.AddElement<uint8_t>(Interp::VT_HALFPIXELCENTERS, static_cast<uint8_t>(halfPixelCenters), 0);
  }
  void add_widthOffset(float widthOffset) {
    fbb_.AddElement<float>(Interp::VT_WIDTHOFFSET, widthOffset, 0.0f);
  }
  void add_heightOffset(float heightOffset) {
    fbb_.AddElement<float>(Interp::VT_HEIGHTOFFSET, heightOffset, 0.0f);
  }
  void add_cubicCoeffA(float cubicCoeffA) {
    fbb_.AddElement<float>(Interp::VT_CUBICCOEFFA, cubicCoeffA, -0.75f);
  }
  void add_ctm(MNN::CoordinateTransformationMode ctm) {
    fbb_.AddElement<int8_t>(Interp::VT_CTM, static_cast<int8_t>(ctm), 0);
  }
  void add_depthScale(float depthScale) {
    fbb_.AddElement<float>(Interp::VT_DEPTHSCALE, depthScale, 0.0f);
  }
  void add_outputDepth(int32_t outputDepth) {
    fbb_.AddElement<int32_t>(Interp::VT_OUTPUTDEPTH, outputDepth, 0);
  }
  void add_depthOffset(float depthOffset) {
    fbb_.AddElement<float>(Interp::VT_DEPTHOFFSET, depthOffset, 0.0f);
  }
  explicit InterpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Interp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Interp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Interp> CreateInterp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float widthScale = 0.0f,
    float heightScale = 0.0f,
    int32_t outputWidth = 0,
    int32_t outputHeight = 0,
    int32_t resizeType = 0,
    bool alignCorners = false,
    bool halfPixelCenters = false,
    float widthOffset = 0.0f,
    float heightOffset = 0.0f,
    float cubicCoeffA = -0.75f,
    MNN::CoordinateTransformationMode ctm = MNN::CoordinateTransformationMode_NotSet,
    float depthScale = 0.0f,
    int32_t outputDepth = 0,
    float depthOffset = 0.0f) {
  InterpBuilder builder_(_fbb);
  builder_.add_depthOffset(depthOffset);
  builder_.add_outputDepth(outputDepth);
  builder_.add_depthScale(depthScale);
  builder_.add_cubicCoeffA(cubicCoeffA);
  builder_.add_heightOffset(heightOffset);
  builder_.add_widthOffset(widthOffset);
  builder_.add_resizeType(resizeType);
  builder_.add_outputHeight(outputHeight);
  builder_.add_outputWidth(outputWidth);
  builder_.add_heightScale(heightScale);
  builder_.add_widthScale(widthScale);
  builder_.add_ctm(ctm);
  builder_.add_halfPixelCenters(halfPixelCenters);
  builder_.add_alignCorners(alignCorners);
  return builder_.Finish();
}

struct Resize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ResizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_XSCALE = 4,
    VT_YSCALE = 6
  };
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_XSCALE, 4) &&
           VerifyField<float>(verifier, VT_YSCALE, 4) &&
           verifier.EndTable();
  }
};

struct ResizeBuilder {
  typedef Resize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(Resize::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(Resize::VT_YSCALE, yScale, 0.0f);
  }
  explicit ResizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Resize> CreateResize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float xScale = 0.0f,
    float yScale = 0.0f) {
  ResizeBuilder builder_(_fbb);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  return builder_.Finish();
}

struct PriorBox FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PriorBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MINSIZES = 4,
    VT_MAXSIZES = 6,
    VT_ASPECTRATIOS = 8,
    VT_VARIANCES = 10,
    VT_FLIP = 12,
    VT_CLIP = 14,
    VT_IMAGEWIDTH = 16,
    VT_IMAGEHEIGHT = 18,
    VT_STEPWIDTH = 20,
    VT_STEPHEIGHT = 22,
    VT_OFFSET = 24
  };
  const ::flatbuffers::Vector<float> *minSizes() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MINSIZES);
  }
  const ::flatbuffers::Vector<float> *maxSizes() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_MAXSIZES);
  }
  const ::flatbuffers::Vector<float> *aspectRatios() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_ASPECTRATIOS);
  }
  const ::flatbuffers::Vector<float> *variances() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  int32_t imageWidth() const {
    return GetField<int32_t>(VT_IMAGEWIDTH, 0);
  }
  int32_t imageHeight() const {
    return GetField<int32_t>(VT_IMAGEHEIGHT, 0);
  }
  int32_t stepWidth() const {
    return GetField<int32_t>(VT_STEPWIDTH, 0);
  }
  int32_t stepHeight() const {
    return GetField<int32_t>(VT_STEPHEIGHT, 0);
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MINSIZES) &&
           verifier.VerifyVector(minSizes()) &&
           VerifyOffset(verifier, VT_MAXSIZES) &&
           verifier.VerifyVector(maxSizes()) &&
           VerifyOffset(verifier, VT_ASPECTRATIOS) &&
           verifier.VerifyVector(aspectRatios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<uint8_t>(verifier, VT_FLIP, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLIP, 1) &&
           VerifyField<int32_t>(verifier, VT_IMAGEWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_IMAGEHEIGHT, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_STEPHEIGHT, 4) &&
           VerifyField<float>(verifier, VT_OFFSET, 4) &&
           verifier.EndTable();
  }
};

struct PriorBoxBuilder {
  typedef PriorBox Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_minSizes(::flatbuffers::Offset<::flatbuffers::Vector<float>> minSizes) {
    fbb_.AddOffset(PriorBox::VT_MINSIZES, minSizes);
  }
  void add_maxSizes(::flatbuffers::Offset<::flatbuffers::Vector<float>> maxSizes) {
    fbb_.AddOffset(PriorBox::VT_MAXSIZES, maxSizes);
  }
  void add_aspectRatios(::flatbuffers::Offset<::flatbuffers::Vector<float>> aspectRatios) {
    fbb_.AddOffset(PriorBox::VT_ASPECTRATIOS, aspectRatios);
  }
  void add_variances(::flatbuffers::Offset<::flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_imageWidth(int32_t imageWidth) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGEWIDTH, imageWidth, 0);
  }
  void add_imageHeight(int32_t imageHeight) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGEHEIGHT, imageHeight, 0);
  }
  void add_stepWidth(int32_t stepWidth) {
    fbb_.AddElement<int32_t>(PriorBox::VT_STEPWIDTH, stepWidth, 0);
  }
  void add_stepHeight(int32_t stepHeight) {
    fbb_.AddElement<int32_t>(PriorBox::VT_STEPHEIGHT, stepHeight, 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PriorBox> CreatePriorBox(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> minSizes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> maxSizes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> aspectRatios = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> variances = 0,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_stepHeight(stepHeight);
  builder_.add_stepWidth(stepWidth);
  builder_.add_imageHeight(imageHeight);
  builder_.add_imageWidth(imageWidth);
  builder_.add_variances(variances);
  builder_.add_aspectRatios(aspectRatios);
  builder_.add_maxSizes(maxSizes);
  builder_.add_minSizes(minSizes);
  builder_.add_clip(clip);
  builder_.add_flip(flip);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *minSizes = nullptr,
    const std::vector<float> *maxSizes = nullptr,
    const std::vector<float> *aspectRatios = nullptr,
    const std::vector<float> *variances = nullptr,
    bool flip = false,
    bool clip = false,
    int32_t imageWidth = 0,
    int32_t imageHeight = 0,
    int32_t stepWidth = 0,
    int32_t stepHeight = 0,
    float offset = 0.0f) {
  auto minSizes__ = minSizes ? _fbb.CreateVector<float>(*minSizes) : 0;
  auto maxSizes__ = maxSizes ? _fbb.CreateVector<float>(*maxSizes) : 0;
  auto aspectRatios__ = aspectRatios ? _fbb.CreateVector<float>(*aspectRatios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return MNN::CreatePriorBox(
      _fbb,
      minSizes__,
      maxSizes__,
      aspectRatios__,
      variances__,
      flip,
      clip,
      imageWidth,
      imageHeight,
      stepWidth,
      stepHeight,
      offset);
}

struct Normalize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NormalizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACROSSSPATIAL = 4,
    VT_CHANNELSHARED = 6,
    VT_EPS = 8,
    VT_SCALE = 10
  };
  int32_t acrossSpatial() const {
    return GetField<int32_t>(VT_ACROSSSPATIAL, 0);
  }
  int32_t channelShared() const {
    return GetField<int32_t>(VT_CHANNELSHARED, 0);
  }
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  const ::flatbuffers::Vector<float> *scale() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ACROSSSPATIAL, 4) &&
           VerifyField<int32_t>(verifier, VT_CHANNELSHARED, 4) &&
           VerifyField<float>(verifier, VT_EPS, 4) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           verifier.EndTable();
  }
};

struct NormalizeBuilder {
  typedef Normalize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_acrossSpatial(int32_t acrossSpatial) {
    fbb_.AddElement<int32_t>(Normalize::VT_ACROSSSPATIAL, acrossSpatial, 0);
  }
  void add_channelShared(int32_t channelShared) {
    fbb_.AddElement<int32_t>(Normalize::VT_CHANNELSHARED, channelShared, 0);
  }
  void add_eps(float eps) {
    fbb_.AddElement<float>(Normalize::VT_EPS, eps, 0.0f);
  }
  void add_scale(::flatbuffers::Offset<::flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(Normalize::VT_SCALE, scale);
  }
  explicit NormalizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Normalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Normalize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Normalize> CreateNormalize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> scale = 0) {
  NormalizeBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_eps(eps);
  builder_.add_channelShared(channelShared);
  builder_.add_acrossSpatial(acrossSpatial);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Normalize> CreateNormalizeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t acrossSpatial = 0,
    int32_t channelShared = 0,
    float eps = 0.0f,
    const std::vector<float> *scale = nullptr) {
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return MNN::CreateNormalize(
      _fbb,
      acrossSpatial,
      channelShared,
      eps,
      scale__);
}

struct EltwiseInt8 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EltwiseInt8Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_INPUTQUAN0 = 6,
    VT_INPUTQUAN1 = 8,
    VT_OUTPUTQUAN = 10
  };
  MNN::EltwiseType type() const {
    return static_cast<MNN::EltwiseType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const MNN::QuantizedFloatParam *inputQuan0() const {
    return GetPointer<const MNN::QuantizedFloatParam *>(VT_INPUTQUAN0);
  }
  const MNN::QuantizedFloatParam *inputQuan1() const {
    return GetPointer<const MNN::QuantizedFloatParam *>(VT_INPUTQUAN1);
  }
  const MNN::QuantizedFloatParam *outputQuan() const {
    return GetPointer<const MNN::QuantizedFloatParam *>(VT_OUTPUTQUAN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_INPUTQUAN0) &&
           verifier.VerifyTable(inputQuan0()) &&
           VerifyOffset(verifier, VT_INPUTQUAN1) &&
           verifier.VerifyTable(inputQuan1()) &&
           VerifyOffset(verifier, VT_OUTPUTQUAN) &&
           verifier.VerifyTable(outputQuan()) &&
           verifier.EndTable();
  }
};

struct EltwiseInt8Builder {
  typedef EltwiseInt8 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(MNN::EltwiseType type) {
    fbb_.AddElement<int8_t>(EltwiseInt8::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_inputQuan0(::flatbuffers::Offset<MNN::QuantizedFloatParam> inputQuan0) {
    fbb_.AddOffset(EltwiseInt8::VT_INPUTQUAN0, inputQuan0);
  }
  void add_inputQuan1(::flatbuffers::Offset<MNN::QuantizedFloatParam> inputQuan1) {
    fbb_.AddOffset(EltwiseInt8::VT_INPUTQUAN1, inputQuan1);
  }
  void add_outputQuan(::flatbuffers::Offset<MNN::QuantizedFloatParam> outputQuan) {
    fbb_.AddOffset(EltwiseInt8::VT_OUTPUTQUAN, outputQuan);
  }
  explicit EltwiseInt8Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EltwiseInt8> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EltwiseInt8>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EltwiseInt8> CreateEltwiseInt8(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::EltwiseType type = MNN::EltwiseType_PROD,
    ::flatbuffers::Offset<MNN::QuantizedFloatParam> inputQuan0 = 0,
    ::flatbuffers::Offset<MNN::QuantizedFloatParam> inputQuan1 = 0,
    ::flatbuffers::Offset<MNN::QuantizedFloatParam> outputQuan = 0) {
  EltwiseInt8Builder builder_(_fbb);
  builder_.add_outputQuan(outputQuan);
  builder_.add_inputQuan1(inputQuan1);
  builder_.add_inputQuan0(inputQuan0);
  builder_.add_type(type);
  return builder_.Finish();
}

struct CumSum FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CumSumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE, 1) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE, 1) &&
           verifier.EndTable();
  }
};

struct CumSumBuilder {
  typedef CumSum Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumSum::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumSum::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumSumBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CumSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CumSum>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CumSum> CreateCumSum(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumSumBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_CAFFEOP_MNN_H_
