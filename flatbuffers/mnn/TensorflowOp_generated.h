// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_
#define FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "Tensor_generated.h"

namespace MNN {

struct BinaryOp;
struct BinaryOpBuilder;

struct PackParam;
struct PackParamBuilder;

struct StridedSliceParam;
struct StridedSliceParamBuilder;

struct SqueezeParam;
struct SqueezeParamBuilder;

struct CastParam;
struct CastParamBuilder;

struct ReductionParam;
struct ReductionParamBuilder;

struct Gather;
struct GatherBuilder;

struct ExpandDims;
struct ExpandDimsBuilder;

struct Selu;
struct SeluBuilder;

struct AsString;
struct AsStringBuilder;

struct ReduceJoin;
struct ReduceJoinBuilder;

struct UnaryOp;
struct UnaryOpBuilder;

struct TopKV2;
struct TopKV2Builder;

struct CropAndResize;
struct CropAndResizeBuilder;

struct Fill;
struct FillBuilder;

struct GatherV2;
struct GatherV2Builder;

struct NonMaxSuppressionV2;
struct NonMaxSuppressionV2Builder;

struct Range;
struct RangeBuilder;

struct Rank;
struct RankBuilder;

struct Size;
struct SizeBuilder;

struct Transpose;
struct TransposeBuilder;

struct SliceTf;
struct SliceTfBuilder;

struct QuantizeMaxMin;
struct QuantizeMaxMinBuilder;

struct Crop;
struct CropBuilder;

struct SpaceBatch;
struct SpaceBatchBuilder;

struct MatMul;
struct MatMulBuilder;

struct MomentsParam;
struct MomentsParamBuilder;

struct RNNParam;
struct RNNParamBuilder;

struct BatchMatMulParam;
struct BatchMatMulParamBuilder;

struct DepthSpaceParam;
struct DepthSpaceParamBuilder;

struct ReverseSequenceParam;
struct ReverseSequenceParamBuilder;

struct DetectionPostProcessParam;
struct DetectionPostProcessParamBuilder;

struct OneHotParam;
struct OneHotParamBuilder;

struct PadParam;
struct PadParamBuilder;

struct LayerNorm;
struct LayerNormBuilder;

struct GroupNorm;
struct GroupNormBuilder;

struct RandomUniform;
struct RandomUniformBuilder;

struct TensorArray;
struct TensorArrayBuilder;

struct LSTMBlockCell;
struct LSTMBlockCellBuilder;

enum BinaryOpOperation : int8_t {
  BinaryOpOperation_ADD = 0,
  BinaryOpOperation_SUB = 1,
  BinaryOpOperation_MUL = 2,
  BinaryOpOperation_DIV = 3,
  BinaryOpOperation_MAX_TEMP = 4,
  BinaryOpOperation_MIN_TEMP = 5,
  BinaryOpOperation_POW = 6,
  BinaryOpOperation_REALDIV = 7,
  BinaryOpOperation_MINIMUM = 8,
  BinaryOpOperation_MAXIMUM = 9,
  BinaryOpOperation_GREATER = 10,
  BinaryOpOperation_GREATER_EQUAL = 11,
  BinaryOpOperation_LESS = 12,
  BinaryOpOperation_FLOORDIV = 13,
  BinaryOpOperation_SquaredDifference = 14,
  BinaryOpOperation_EQUAL = 15,
  BinaryOpOperation_LESS_EQUAL = 16,
  BinaryOpOperation_FLOORMOD = 17,
  BinaryOpOperation_MOD = 19,
  BinaryOpOperation_ATAN2 = 20,
  BinaryOpOperation_LOGICALOR = 21,
  BinaryOpOperation_NOTEQUAL = 22,
  BinaryOpOperation_BITWISE_AND = 23,
  BinaryOpOperation_BITWISE_OR = 24,
  BinaryOpOperation_BITWISE_XOR = 25,
  BinaryOpOperation_LOGICALXOR = 26,
  BinaryOpOperation_LEFTSHIFT = 27,
  BinaryOpOperation_RIGHTSHIFT = 28,
  BinaryOpOperation_MIN = BinaryOpOperation_ADD,
  BinaryOpOperation_MAX = BinaryOpOperation_RIGHTSHIFT
};

inline const BinaryOpOperation (&EnumValuesBinaryOpOperation())[28] {
  static const BinaryOpOperation values[] = {
    BinaryOpOperation_ADD,
    BinaryOpOperation_SUB,
    BinaryOpOperation_MUL,
    BinaryOpOperation_DIV,
    BinaryOpOperation_MAX_TEMP,
    BinaryOpOperation_MIN_TEMP,
    BinaryOpOperation_POW,
    BinaryOpOperation_REALDIV,
    BinaryOpOperation_MINIMUM,
    BinaryOpOperation_MAXIMUM,
    BinaryOpOperation_GREATER,
    BinaryOpOperation_GREATER_EQUAL,
    BinaryOpOperation_LESS,
    BinaryOpOperation_FLOORDIV,
    BinaryOpOperation_SquaredDifference,
    BinaryOpOperation_EQUAL,
    BinaryOpOperation_LESS_EQUAL,
    BinaryOpOperation_FLOORMOD,
    BinaryOpOperation_MOD,
    BinaryOpOperation_ATAN2,
    BinaryOpOperation_LOGICALOR,
    BinaryOpOperation_NOTEQUAL,
    BinaryOpOperation_BITWISE_AND,
    BinaryOpOperation_BITWISE_OR,
    BinaryOpOperation_BITWISE_XOR,
    BinaryOpOperation_LOGICALXOR,
    BinaryOpOperation_LEFTSHIFT,
    BinaryOpOperation_RIGHTSHIFT
  };
  return values;
}

inline const char * const *EnumNamesBinaryOpOperation() {
  static const char * const names[30] = {
    "ADD",
    "SUB",
    "MUL",
    "DIV",
    "MAX_TEMP",
    "MIN_TEMP",
    "POW",
    "REALDIV",
    "MINIMUM",
    "MAXIMUM",
    "GREATER",
    "GREATER_EQUAL",
    "LESS",
    "FLOORDIV",
    "SquaredDifference",
    "EQUAL",
    "LESS_EQUAL",
    "FLOORMOD",
    "",
    "MOD",
    "ATAN2",
    "LOGICALOR",
    "NOTEQUAL",
    "BITWISE_AND",
    "BITWISE_OR",
    "BITWISE_XOR",
    "LOGICALXOR",
    "LEFTSHIFT",
    "RIGHTSHIFT",
    nullptr
  };
  return names;
}

inline const char *EnumNameBinaryOpOperation(BinaryOpOperation e) {
  if (::flatbuffers::IsOutRange(e, BinaryOpOperation_ADD, BinaryOpOperation_RIGHTSHIFT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesBinaryOpOperation()[index];
}

enum ReductionType : int8_t {
  ReductionType_SUM = 0,
  ReductionType_ASUM = 1,
  ReductionType_SUMSQ = 2,
  ReductionType_MEAN = 3,
  ReductionType_MAXIMUM = 4,
  ReductionType_MINIMUM = 5,
  ReductionType_PROD = 6,
  ReductionType_ANY = 7,
  ReductionType_ALL = 8,
  ReductionType_MIN = ReductionType_SUM,
  ReductionType_MAX = ReductionType_ALL
};

inline const ReductionType (&EnumValuesReductionType())[9] {
  static const ReductionType values[] = {
    ReductionType_SUM,
    ReductionType_ASUM,
    ReductionType_SUMSQ,
    ReductionType_MEAN,
    ReductionType_MAXIMUM,
    ReductionType_MINIMUM,
    ReductionType_PROD,
    ReductionType_ANY,
    ReductionType_ALL
  };
  return values;
}

inline const char * const *EnumNamesReductionType() {
  static const char * const names[10] = {
    "SUM",
    "ASUM",
    "SUMSQ",
    "MEAN",
    "MAXIMUM",
    "MINIMUM",
    "PROD",
    "ANY",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameReductionType(ReductionType e) {
  if (::flatbuffers::IsOutRange(e, ReductionType_SUM, ReductionType_ALL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReductionType()[index];
}

enum UnaryOpOperation : int32_t {
  UnaryOpOperation_ABS = 0,
  UnaryOpOperation_NEG = 1,
  UnaryOpOperation_FLOOR = 2,
  UnaryOpOperation_CEIL = 3,
  UnaryOpOperation_SQUARE = 4,
  UnaryOpOperation_SQRT = 5,
  UnaryOpOperation_RSQRT = 6,
  UnaryOpOperation_EXP = 7,
  UnaryOpOperation_LOG = 8,
  UnaryOpOperation_SIN = 9,
  UnaryOpOperation_COS = 10,
  UnaryOpOperation_TAN = 11,
  UnaryOpOperation_ASIN = 12,
  UnaryOpOperation_ACOS = 13,
  UnaryOpOperation_ATAN = 14,
  UnaryOpOperation_RECIPROCAL = 15,
  UnaryOpOperation_LOG1P = 16,
  UnaryOpOperation_BNLL = 17,
  UnaryOpOperation_ACOSH = 18,
  UnaryOpOperation_SINH = 19,
  UnaryOpOperation_ASINH = 20,
  UnaryOpOperation_ATANH = 21,
  UnaryOpOperation_SIGN = 22,
  UnaryOpOperation_ROUND = 23,
  UnaryOpOperation_COSH = 24,
  UnaryOpOperation_ERF = 25,
  UnaryOpOperation_ERFC = 26,
  UnaryOpOperation_ERFINV = 27,
  UnaryOpOperation_EXPM1 = 28,
  UnaryOpOperation_SIGMOID = 29,
  UnaryOpOperation_TANH = 30,
  UnaryOpOperation_HARDSWISH = 31,
  UnaryOpOperation_GELU = 32,
  UnaryOpOperation_GELU_STANDARD = 33,
  UnaryOpOperation_SILU = 34,
  UnaryOpOperation_MIN = UnaryOpOperation_ABS,
  UnaryOpOperation_MAX = UnaryOpOperation_SILU
};

inline const UnaryOpOperation (&EnumValuesUnaryOpOperation())[35] {
  static const UnaryOpOperation values[] = {
    UnaryOpOperation_ABS,
    UnaryOpOperation_NEG,
    UnaryOpOperation_FLOOR,
    UnaryOpOperation_CEIL,
    UnaryOpOperation_SQUARE,
    UnaryOpOperation_SQRT,
    UnaryOpOperation_RSQRT,
    UnaryOpOperation_EXP,
    UnaryOpOperation_LOG,
    UnaryOpOperation_SIN,
    UnaryOpOperation_COS,
    UnaryOpOperation_TAN,
    UnaryOpOperation_ASIN,
    UnaryOpOperation_ACOS,
    UnaryOpOperation_ATAN,
    UnaryOpOperation_RECIPROCAL,
    UnaryOpOperation_LOG1P,
    UnaryOpOperation_BNLL,
    UnaryOpOperation_ACOSH,
    UnaryOpOperation_SINH,
    UnaryOpOperation_ASINH,
    UnaryOpOperation_ATANH,
    UnaryOpOperation_SIGN,
    UnaryOpOperation_ROUND,
    UnaryOpOperation_COSH,
    UnaryOpOperation_ERF,
    UnaryOpOperation_ERFC,
    UnaryOpOperation_ERFINV,
    UnaryOpOperation_EXPM1,
    UnaryOpOperation_SIGMOID,
    UnaryOpOperation_TANH,
    UnaryOpOperation_HARDSWISH,
    UnaryOpOperation_GELU,
    UnaryOpOperation_GELU_STANDARD,
    UnaryOpOperation_SILU
  };
  return values;
}

inline const char * const *EnumNamesUnaryOpOperation() {
  static const char * const names[36] = {
    "ABS",
    "NEG",
    "FLOOR",
    "CEIL",
    "SQUARE",
    "SQRT",
    "RSQRT",
    "EXP",
    "LOG",
    "SIN",
    "COS",
    "TAN",
    "ASIN",
    "ACOS",
    "ATAN",
    "RECIPROCAL",
    "LOG1P",
    "BNLL",
    "ACOSH",
    "SINH",
    "ASINH",
    "ATANH",
    "SIGN",
    "ROUND",
    "COSH",
    "ERF",
    "ERFC",
    "ERFINV",
    "EXPM1",
    "SIGMOID",
    "TANH",
    "HARDSWISH",
    "GELU",
    "GELU_STANDARD",
    "SILU",
    nullptr
  };
  return names;
}

inline const char *EnumNameUnaryOpOperation(UnaryOpOperation e) {
  if (::flatbuffers::IsOutRange(e, UnaryOpOperation_ABS, UnaryOpOperation_SILU)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesUnaryOpOperation()[index];
}

enum CropAndResizeMethod : int8_t {
  CropAndResizeMethod_BILINEAR = 0,
  CropAndResizeMethod_NEAREST = 1,
  CropAndResizeMethod_MIN = CropAndResizeMethod_BILINEAR,
  CropAndResizeMethod_MAX = CropAndResizeMethod_NEAREST
};

inline const CropAndResizeMethod (&EnumValuesCropAndResizeMethod())[2] {
  static const CropAndResizeMethod values[] = {
    CropAndResizeMethod_BILINEAR,
    CropAndResizeMethod_NEAREST
  };
  return values;
}

inline const char * const *EnumNamesCropAndResizeMethod() {
  static const char * const names[3] = {
    "BILINEAR",
    "NEAREST",
    nullptr
  };
  return names;
}

inline const char *EnumNameCropAndResizeMethod(CropAndResizeMethod e) {
  if (::flatbuffers::IsOutRange(e, CropAndResizeMethod_BILINEAR, CropAndResizeMethod_NEAREST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCropAndResizeMethod()[index];
}

enum DepthToSpaceMode : int8_t {
  DepthToSpaceMode_DCR = 0,
  DepthToSpaceMode_CRD = 1,
  DepthToSpaceMode_MIN = DepthToSpaceMode_DCR,
  DepthToSpaceMode_MAX = DepthToSpaceMode_CRD
};

inline const DepthToSpaceMode (&EnumValuesDepthToSpaceMode())[2] {
  static const DepthToSpaceMode values[] = {
    DepthToSpaceMode_DCR,
    DepthToSpaceMode_CRD
  };
  return values;
}

inline const char * const *EnumNamesDepthToSpaceMode() {
  static const char * const names[3] = {
    "DCR",
    "CRD",
    nullptr
  };
  return names;
}

inline const char *EnumNameDepthToSpaceMode(DepthToSpaceMode e) {
  if (::flatbuffers::IsOutRange(e, DepthToSpaceMode_DCR, DepthToSpaceMode_CRD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDepthToSpaceMode()[index];
}

enum PadValueMode : int8_t {
  PadValueMode_CONSTANT = 0,
  PadValueMode_REFLECT = 1,
  PadValueMode_SYMMETRIC = 2,
  PadValueMode_EDGE = 3,
  PadValueMode_MIN = PadValueMode_CONSTANT,
  PadValueMode_MAX = PadValueMode_EDGE
};

inline const PadValueMode (&EnumValuesPadValueMode())[4] {
  static const PadValueMode values[] = {
    PadValueMode_CONSTANT,
    PadValueMode_REFLECT,
    PadValueMode_SYMMETRIC,
    PadValueMode_EDGE
  };
  return values;
}

inline const char * const *EnumNamesPadValueMode() {
  static const char * const names[5] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "EDGE",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadValueMode(PadValueMode e) {
  if (::flatbuffers::IsOutRange(e, PadValueMode_CONSTANT, PadValueMode_EDGE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadValueMode()[index];
}

struct BinaryOp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BinaryOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTYPE = 4,
    VT_T = 6,
    VT_ACTIVATIONTYPE = 8
  };
  int32_t opType() const {
    return GetField<int32_t>(VT_OPTYPE, 0);
  }
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 1));
  }
  int32_t activationType() const {
    return GetField<int32_t>(VT_ACTIVATIONTYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OPTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<int32_t>(verifier, VT_ACTIVATIONTYPE, 4) &&
           verifier.EndTable();
  }
};

struct BinaryOpBuilder {
  typedef BinaryOp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_opType(int32_t opType) {
    fbb_.AddElement<int32_t>(BinaryOp::VT_OPTYPE, opType, 0);
  }
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(BinaryOp::VT_T, static_cast<int32_t>(T), 1);
  }
  void add_activationType(int32_t activationType) {
    fbb_.AddElement<int32_t>(BinaryOp::VT_ACTIVATIONTYPE, activationType, 0);
  }
  explicit BinaryOpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BinaryOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BinaryOp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BinaryOp> CreateBinaryOp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t opType = 0,
    MNN::DataType T = MNN::DataType_DT_FLOAT,
    int32_t activationType = 0) {
  BinaryOpBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  builder_.add_T(T);
  builder_.add_opType(opType);
  return builder_.Finish();
}

struct PackParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PackParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_AXIS = 6
  };
  MNN::DataType dataType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DATATYPE, 0));
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct PackParamBuilder {
  typedef PackParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dataType(MNN::DataType dataType) {
    fbb_.AddElement<int32_t>(PackParam::VT_DATATYPE, static_cast<int32_t>(dataType), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackParam::VT_AXIS, axis, 0);
  }
  explicit PackParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PackParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PackParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PackParam> CreatePackParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType dataType = MNN::DataType_DT_INVALID,
    int32_t axis = 0) {
  PackParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

struct StridedSliceParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StridedSliceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INDEX = 4,
    VT_T = 6,
    VT_BEGINMASK = 8,
    VT_ENDMASK = 10,
    VT_ELLIPSISMASK = 12,
    VT_NEWAXISMASK = 14,
    VT_SHRINKAXISMASK = 16,
    VT_FROMTYPE = 18
  };
  MNN::DataType Index() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_INDEX, 0));
  }
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  int32_t beginMask() const {
    return GetField<int32_t>(VT_BEGINMASK, 0);
  }
  int32_t endMask() const {
    return GetField<int32_t>(VT_ENDMASK, 0);
  }
  int32_t ellipsisMask() const {
    return GetField<int32_t>(VT_ELLIPSISMASK, 0);
  }
  int32_t newAxisMask() const {
    return GetField<int32_t>(VT_NEWAXISMASK, 0);
  }
  int32_t shrinkAxisMask() const {
    return GetField<int32_t>(VT_SHRINKAXISMASK, 0);
  }
  int32_t fromType() const {
    return GetField<int32_t>(VT_FROMTYPE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<int32_t>(verifier, VT_BEGINMASK, 4) &&
           VerifyField<int32_t>(verifier, VT_ENDMASK, 4) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSISMASK, 4) &&
           VerifyField<int32_t>(verifier, VT_NEWAXISMASK, 4) &&
           VerifyField<int32_t>(verifier, VT_SHRINKAXISMASK, 4) &&
           VerifyField<int32_t>(verifier, VT_FROMTYPE, 4) &&
           verifier.EndTable();
  }
};

struct StridedSliceParamBuilder {
  typedef StridedSliceParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Index(MNN::DataType Index) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_INDEX, static_cast<int32_t>(Index), 0);
  }
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_beginMask(int32_t beginMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_BEGINMASK, beginMask, 0);
  }
  void add_endMask(int32_t endMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_ENDMASK, endMask, 0);
  }
  void add_ellipsisMask(int32_t ellipsisMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_ELLIPSISMASK, ellipsisMask, 0);
  }
  void add_newAxisMask(int32_t newAxisMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_NEWAXISMASK, newAxisMask, 0);
  }
  void add_shrinkAxisMask(int32_t shrinkAxisMask) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_SHRINKAXISMASK, shrinkAxisMask, 0);
  }
  void add_fromType(int32_t fromType) {
    fbb_.AddElement<int32_t>(StridedSliceParam::VT_FROMTYPE, fromType, 0);
  }
  explicit StridedSliceParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StridedSliceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StridedSliceParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StridedSliceParam> CreateStridedSliceParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType Index = MNN::DataType_DT_INVALID,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    int32_t fromType = 0) {
  StridedSliceParamBuilder builder_(_fbb);
  builder_.add_fromType(fromType);
  builder_.add_shrinkAxisMask(shrinkAxisMask);
  builder_.add_newAxisMask(newAxisMask);
  builder_.add_ellipsisMask(ellipsisMask);
  builder_.add_endMask(endMask);
  builder_.add_beginMask(beginMask);
  builder_.add_T(T);
  builder_.add_Index(Index);
  return builder_.Finish();
}

struct SqueezeParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SqueezeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SQUEEZEDIMS = 4
  };
  const ::flatbuffers::Vector<int32_t> *squeezeDims() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SQUEEZEDIMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZEDIMS) &&
           verifier.VerifyVector(squeezeDims()) &&
           verifier.EndTable();
  }
};

struct SqueezeParamBuilder {
  typedef SqueezeParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_squeezeDims(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeezeDims) {
    fbb_.AddOffset(SqueezeParam::VT_SQUEEZEDIMS, squeezeDims);
  }
  explicit SqueezeParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SqueezeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SqueezeParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SqueezeParam> CreateSqueezeParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> squeezeDims = 0) {
  SqueezeParamBuilder builder_(_fbb);
  builder_.add_squeezeDims(squeezeDims);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SqueezeParam> CreateSqueezeParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeezeDims = nullptr) {
  auto squeezeDims__ = squeezeDims ? _fbb.CreateVector<int32_t>(*squeezeDims) : 0;
  return MNN::CreateSqueezeParam(
      _fbb,
      squeezeDims__);
}

struct CastParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CastParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  MNN::DataType srcT() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_SRCT, 0));
  }
  MNN::DataType dstT() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DSTT, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT, 4) &&
           VerifyField<int32_t>(verifier, VT_DSTT, 4) &&
           verifier.EndTable();
  }
};

struct CastParamBuilder {
  typedef CastParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_srcT(MNN::DataType srcT) {
    fbb_.AddElement<int32_t>(CastParam::VT_SRCT, static_cast<int32_t>(srcT), 0);
  }
  void add_dstT(MNN::DataType dstT) {
    fbb_.AddElement<int32_t>(CastParam::VT_DSTT, static_cast<int32_t>(dstT), 0);
  }
  explicit CastParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CastParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CastParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CastParam> CreateCastParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType srcT = MNN::DataType_DT_INVALID,
    MNN::DataType dstT = MNN::DataType_DT_INVALID) {
  CastParamBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

struct ReductionParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReductionParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPERATION = 4,
    VT_DIM = 6,
    VT_COEFF = 8,
    VT_KEEPDIMS = 10,
    VT_DTYPE = 12
  };
  MNN::ReductionType operation() const {
    return static_cast<MNN::ReductionType>(GetField<int8_t>(VT_OPERATION, 0));
  }
  const ::flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  MNN::DataType dType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OPERATION, 1) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<float>(verifier, VT_COEFF, 4) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS, 1) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           verifier.EndTable();
  }
};

struct ReductionParamBuilder {
  typedef ReductionParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_operation(MNN::ReductionType operation) {
    fbb_.AddElement<int8_t>(ReductionParam::VT_OPERATION, static_cast<int8_t>(operation), 0);
  }
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(ReductionParam::VT_DIM, dim);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(ReductionParam::VT_COEFF, coeff, 0.0f);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ReductionParam::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_dType(MNN::DataType dType) {
    fbb_.AddElement<int32_t>(ReductionParam::VT_DTYPE, static_cast<int32_t>(dType), 1);
  }
  explicit ReductionParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReductionParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReductionParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReductionParam> CreateReductionParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::ReductionType operation = MNN::ReductionType_SUM,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dim = 0,
    float coeff = 0.0f,
    bool keepDims = false,
    MNN::DataType dType = MNN::DataType_DT_FLOAT) {
  ReductionParamBuilder builder_(_fbb);
  builder_.add_dType(dType);
  builder_.add_coeff(coeff);
  builder_.add_dim(dim);
  builder_.add_keepDims(keepDims);
  builder_.add_operation(operation);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReductionParam> CreateReductionParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::ReductionType operation = MNN::ReductionType_SUM,
    const std::vector<int32_t> *dim = nullptr,
    float coeff = 0.0f,
    bool keepDims = false,
    MNN::DataType dType = MNN::DataType_DT_FLOAT) {
  auto dim__ = dim ? _fbb.CreateVector<int32_t>(*dim) : 0;
  return MNN::CreateReductionParam(
      _fbb,
      operation,
      dim__,
      coeff,
      keepDims,
      dType);
}

struct Gather FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GatherBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TINDICES = 4,
    VT_TPARAMS = 6,
    VT_VALIDATEINDICES = 8,
    VT_AXIS = 10
  };
  MNN::DataType Tindices() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TINDICES, 0));
  }
  MNN::DataType Tparams() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TPARAMS, 0));
  }
  bool validateIndices() const {
    return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TINDICES, 4) &&
           VerifyField<int32_t>(verifier, VT_TPARAMS, 4) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES, 1) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct GatherBuilder {
  typedef Gather Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Tindices(MNN::DataType Tindices) {
    fbb_.AddElement<int32_t>(Gather::VT_TINDICES, static_cast<int32_t>(Tindices), 0);
  }
  void add_Tparams(MNN::DataType Tparams) {
    fbb_.AddElement<int32_t>(Gather::VT_TPARAMS, static_cast<int32_t>(Tparams), 0);
  }
  void add_validateIndices(bool validateIndices) {
    fbb_.AddElement<uint8_t>(Gather::VT_VALIDATEINDICES, static_cast<uint8_t>(validateIndices), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Gather::VT_AXIS, axis, 0);
  }
  explicit GatherBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Gather> CreateGather(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType Tindices = MNN::DataType_DT_INVALID,
    MNN::DataType Tparams = MNN::DataType_DT_INVALID,
    bool validateIndices = false,
    int32_t axis = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_Tparams(Tparams);
  builder_.add_Tindices(Tindices);
  builder_.add_validateIndices(validateIndices);
  return builder_.Finish();
}

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ExpandDimsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_TDIM = 6,
    VT_AXIS = 8
  };
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  MNN::DataType Tdim() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TDIM, 0));
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<int32_t>(verifier, VT_TDIM, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct ExpandDimsBuilder {
  typedef ExpandDims Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_Tdim(MNN::DataType Tdim) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_TDIM, static_cast<int32_t>(Tdim), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_AXIS, axis, 0);
  }
  explicit ExpandDimsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ExpandDims> CreateExpandDims(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    MNN::DataType Tdim = MNN::DataType_DT_INVALID,
    int32_t axis = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_Tdim(Tdim);
  builder_.add_T(T);
  return builder_.Finish();
}

struct Selu FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SeluBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ALPHA = 6
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct SeluBuilder {
  typedef Selu Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(Selu::VT_SCALE, scale, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Selu::VT_ALPHA, alpha, 0.0f);
  }
  explicit SeluBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Selu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Selu>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Selu> CreateSelu(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float alpha = 0.0f) {
  SeluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_scale(scale);
  return builder_.Finish();
}

struct AsString FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AsStringBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_PRECISION = 6,
    VT_SCIENTIFIC = 8,
    VT_SHORTEST = 10,
    VT_WIDTH = 12,
    VT_FILLSTRING = 14
  };
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  int32_t precision() const {
    return GetField<int32_t>(VT_PRECISION, 0);
  }
  bool scientific() const {
    return GetField<uint8_t>(VT_SCIENTIFIC, 0) != 0;
  }
  bool shortest() const {
    return GetField<uint8_t>(VT_SHORTEST, 0) != 0;
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  const ::flatbuffers::String *fillString() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILLSTRING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<int32_t>(verifier, VT_PRECISION, 4) &&
           VerifyField<uint8_t>(verifier, VT_SCIENTIFIC, 1) &&
           VerifyField<uint8_t>(verifier, VT_SHORTEST, 1) &&
           VerifyField<int32_t>(verifier, VT_WIDTH, 4) &&
           VerifyOffset(verifier, VT_FILLSTRING) &&
           verifier.VerifyString(fillString()) &&
           verifier.EndTable();
  }
};

struct AsStringBuilder {
  typedef AsString Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(AsString::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_precision(int32_t precision) {
    fbb_.AddElement<int32_t>(AsString::VT_PRECISION, precision, 0);
  }
  void add_scientific(bool scientific) {
    fbb_.AddElement<uint8_t>(AsString::VT_SCIENTIFIC, static_cast<uint8_t>(scientific), 0);
  }
  void add_shortest(bool shortest) {
    fbb_.AddElement<uint8_t>(AsString::VT_SHORTEST, static_cast<uint8_t>(shortest), 0);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(AsString::VT_WIDTH, width, 0);
  }
  void add_fillString(::flatbuffers::Offset<::flatbuffers::String> fillString) {
    fbb_.AddOffset(AsString::VT_FILLSTRING, fillString);
  }
  explicit AsStringBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AsString> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AsString>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AsString> CreateAsString(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    int32_t precision = 0,
    bool scientific = false,
    bool shortest = false,
    int32_t width = 0,
    ::flatbuffers::Offset<::flatbuffers::String> fillString = 0) {
  AsStringBuilder builder_(_fbb);
  builder_.add_fillString(fillString);
  builder_.add_width(width);
  builder_.add_precision(precision);
  builder_.add_T(T);
  builder_.add_shortest(shortest);
  builder_.add_scientific(scientific);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AsString> CreateAsStringDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    int32_t precision = 0,
    bool scientific = false,
    bool shortest = false,
    int32_t width = 0,
    const char *fillString = nullptr) {
  auto fillString__ = fillString ? _fbb.CreateString(fillString) : 0;
  return MNN::CreateAsString(
      _fbb,
      T,
      precision,
      scientific,
      shortest,
      width,
      fillString__);
}

struct ReduceJoin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReduceJoinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEPDIMS = 4,
    VT_SEPARATOR = 6
  };
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  const ::flatbuffers::String *separator() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SEPARATOR);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS, 1) &&
           VerifyOffset(verifier, VT_SEPARATOR) &&
           verifier.VerifyString(separator()) &&
           verifier.EndTable();
  }
};

struct ReduceJoinBuilder {
  typedef ReduceJoin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ReduceJoin::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_separator(::flatbuffers::Offset<::flatbuffers::String> separator) {
    fbb_.AddOffset(ReduceJoin::VT_SEPARATOR, separator);
  }
  explicit ReduceJoinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReduceJoin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReduceJoin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReduceJoin> CreateReduceJoin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool keepDims = false,
    ::flatbuffers::Offset<::flatbuffers::String> separator = 0) {
  ReduceJoinBuilder builder_(_fbb);
  builder_.add_separator(separator);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReduceJoin> CreateReduceJoinDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool keepDims = false,
    const char *separator = nullptr) {
  auto separator__ = separator ? _fbb.CreateString(separator) : 0;
  return MNN::CreateReduceJoin(
      _fbb,
      keepDims,
      separator__);
}

struct UnaryOp FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef UnaryOpBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPTYPE = 4,
    VT_T = 6,
    VT_TABLEINT8 = 8
  };
  MNN::UnaryOpOperation opType() const {
    return static_cast<MNN::UnaryOpOperation>(GetField<int32_t>(VT_OPTYPE, 0));
  }
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  const ::flatbuffers::Vector<int8_t> *tableInt8() const {
    return GetPointer<const ::flatbuffers::Vector<int8_t> *>(VT_TABLEINT8);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OPTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyOffset(verifier, VT_TABLEINT8) &&
           verifier.VerifyVector(tableInt8()) &&
           verifier.EndTable();
  }
};

struct UnaryOpBuilder {
  typedef UnaryOp Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_opType(MNN::UnaryOpOperation opType) {
    fbb_.AddElement<int32_t>(UnaryOp::VT_OPTYPE, static_cast<int32_t>(opType), 0);
  }
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(UnaryOp::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_tableInt8(::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> tableInt8) {
    fbb_.AddOffset(UnaryOp::VT_TABLEINT8, tableInt8);
  }
  explicit UnaryOpBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<UnaryOp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<UnaryOp>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<UnaryOp> CreateUnaryOp(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::UnaryOpOperation opType = MNN::UnaryOpOperation_ABS,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    ::flatbuffers::Offset<::flatbuffers::Vector<int8_t>> tableInt8 = 0) {
  UnaryOpBuilder builder_(_fbb);
  builder_.add_tableInt8(tableInt8);
  builder_.add_T(T);
  builder_.add_opType(opType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<UnaryOp> CreateUnaryOpDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::UnaryOpOperation opType = MNN::UnaryOpOperation_ABS,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    const std::vector<int8_t> *tableInt8 = nullptr) {
  auto tableInt8__ = tableInt8 ? _fbb.CreateVector<int8_t>(*tableInt8) : 0;
  return MNN::CreateUnaryOp(
      _fbb,
      opType,
      T,
      tableInt8__);
}

struct TopKV2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TopKV2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_SORTED = 6,
    VT_LARGEST = 8
  };
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 1));
  }
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 0) != 0;
  }
  bool largest() const {
    return GetField<uint8_t>(VT_LARGEST, 1) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<uint8_t>(verifier, VT_SORTED, 1) &&
           VerifyField<uint8_t>(verifier, VT_LARGEST, 1) &&
           verifier.EndTable();
  }
};

struct TopKV2Builder {
  typedef TopKV2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(TopKV2::VT_T, static_cast<int32_t>(T), 1);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopKV2::VT_SORTED, static_cast<uint8_t>(sorted), 0);
  }
  void add_largest(bool largest) {
    fbb_.AddElement<uint8_t>(TopKV2::VT_LARGEST, static_cast<uint8_t>(largest), 1);
  }
  explicit TopKV2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TopKV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TopKV2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TopKV2> CreateTopKV2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_FLOAT,
    bool sorted = false,
    bool largest = true) {
  TopKV2Builder builder_(_fbb);
  builder_.add_T(T);
  builder_.add_largest(largest);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

struct CropAndResize FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CropAndResizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXTRAPOLATIONVALUE = 4,
    VT_METHOD = 6
  };
  float extrapolationValue() const {
    return GetField<float>(VT_EXTRAPOLATIONVALUE, 0.0f);
  }
  MNN::CropAndResizeMethod method() const {
    return static_cast<MNN::CropAndResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATIONVALUE, 4) &&
           VerifyField<int8_t>(verifier, VT_METHOD, 1) &&
           verifier.EndTable();
  }
};

struct CropAndResizeBuilder {
  typedef CropAndResize Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_extrapolationValue(float extrapolationValue) {
    fbb_.AddElement<float>(CropAndResize::VT_EXTRAPOLATIONVALUE, extrapolationValue, 0.0f);
  }
  void add_method(MNN::CropAndResizeMethod method) {
    fbb_.AddElement<int8_t>(CropAndResize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  explicit CropAndResizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CropAndResize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CropAndResize>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CropAndResize> CreateCropAndResize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float extrapolationValue = 0.0f,
    MNN::CropAndResizeMethod method = MNN::CropAndResizeMethod_BILINEAR) {
  CropAndResizeBuilder builder_(_fbb);
  builder_.add_extrapolationValue(extrapolationValue);
  builder_.add_method(method);
  return builder_.Finish();
}

struct Fill FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FillBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FillBuilder {
  typedef Fill Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit FillBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Fill> CreateFill(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  FillBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GatherV2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GatherV2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TAXIS = 4,
    VT_TINDICES = 6,
    VT_TPARAMS = 8
  };
  MNN::DataType Taxis() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TAXIS, 0));
  }
  MNN::DataType Tindices() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TINDICES, 0));
  }
  MNN::DataType Tparams() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TPARAMS, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TAXIS, 4) &&
           VerifyField<int32_t>(verifier, VT_TINDICES, 4) &&
           VerifyField<int32_t>(verifier, VT_TPARAMS, 4) &&
           verifier.EndTable();
  }
};

struct GatherV2Builder {
  typedef GatherV2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Taxis(MNN::DataType Taxis) {
    fbb_.AddElement<int32_t>(GatherV2::VT_TAXIS, static_cast<int32_t>(Taxis), 0);
  }
  void add_Tindices(MNN::DataType Tindices) {
    fbb_.AddElement<int32_t>(GatherV2::VT_TINDICES, static_cast<int32_t>(Tindices), 0);
  }
  void add_Tparams(MNN::DataType Tparams) {
    fbb_.AddElement<int32_t>(GatherV2::VT_TPARAMS, static_cast<int32_t>(Tparams), 0);
  }
  explicit GatherV2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GatherV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GatherV2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GatherV2> CreateGatherV2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType Taxis = MNN::DataType_DT_INVALID,
    MNN::DataType Tindices = MNN::DataType_DT_INVALID,
    MNN::DataType Tparams = MNN::DataType_DT_INVALID) {
  GatherV2Builder builder_(_fbb);
  builder_.add_Tparams(Tparams);
  builder_.add_Tindices(Tindices);
  builder_.add_Taxis(Taxis);
  return builder_.Finish();
}

struct NonMaxSuppressionV2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef NonMaxSuppressionV2Builder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NonMaxSuppressionV2Builder {
  typedef NonMaxSuppressionV2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit NonMaxSuppressionV2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<NonMaxSuppressionV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<NonMaxSuppressionV2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<NonMaxSuppressionV2> CreateNonMaxSuppressionV2(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  NonMaxSuppressionV2Builder builder_(_fbb);
  return builder_.Finish();
}

struct Range FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TIDX = 4
  };
  MNN::DataType Tidx() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TIDX, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIDX, 4) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  typedef Range Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Tidx(MNN::DataType Tidx) {
    fbb_.AddElement<int32_t>(Range::VT_TIDX, static_cast<int32_t>(Tidx), 0);
  }
  explicit RangeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Range> CreateRange(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType Tidx = MNN::DataType_DT_INVALID) {
  RangeBuilder builder_(_fbb);
  builder_.add_Tidx(Tidx);
  return builder_.Finish();
}

struct Rank FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RankBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RankBuilder {
  typedef Rank Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit RankBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Rank> CreateRank(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Size FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTDATATYPE = 4
  };
  MNN::DataType outputDataType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_OUTPUTDATATYPE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTDATATYPE, 4) &&
           verifier.EndTable();
  }
};

struct SizeBuilder {
  typedef Size Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_outputDataType(MNN::DataType outputDataType) {
    fbb_.AddElement<int32_t>(Size::VT_OUTPUTDATATYPE, static_cast<int32_t>(outputDataType), 0);
  }
  explicit SizeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Size> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Size>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Size> CreateSize(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType outputDataType = MNN::DataType_DT_INVALID) {
  SizeBuilder builder_(_fbb);
  builder_.add_outputDataType(outputDataType);
  return builder_.Finish();
}

struct Transpose FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TransposeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TPERM = 4
  };
  MNN::DataType Tperm() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TPERM, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TPERM, 4) &&
           verifier.EndTable();
  }
};

struct TransposeBuilder {
  typedef Transpose Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_Tperm(MNN::DataType Tperm) {
    fbb_.AddElement<int32_t>(Transpose::VT_TPERM, static_cast<int32_t>(Tperm), 0);
  }
  explicit TransposeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Transpose> CreateTranspose(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType Tperm = MNN::DataType_DT_INVALID) {
  TransposeBuilder builder_(_fbb);
  builder_.add_Tperm(Tperm);
  return builder_.Finish();
}

struct SliceTf FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SliceTfBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           verifier.EndTable();
  }
};

struct SliceTfBuilder {
  typedef SliceTf Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(SliceTf::VT_T, static_cast<int32_t>(T), 0);
  }
  explicit SliceTfBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SliceTf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SliceTf>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SliceTf> CreateSliceTf(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID) {
  SliceTfBuilder builder_(_fbb);
  builder_.add_T(T);
  return builder_.Finish();
}

struct QuantizeMaxMin FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizeMaxMinBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4
  };
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           verifier.EndTable();
  }
};

struct QuantizeMaxMinBuilder {
  typedef QuantizeMaxMin Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(QuantizeMaxMin::VT_T, static_cast<int32_t>(T), 0);
  }
  explicit QuantizeMaxMinBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizeMaxMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizeMaxMin>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizeMaxMin> CreateQuantizeMaxMin(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID) {
  QuantizeMaxMinBuilder builder_(_fbb);
  builder_.add_T(T);
  return builder_.Finish();
}

struct Crop FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CropBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSET = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 2);
  }
  const ::flatbuffers::Vector<int32_t> *offset() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OFFSET);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyOffset(verifier, VT_OFFSET) &&
           verifier.VerifyVector(offset()) &&
           verifier.EndTable();
  }
};

struct CropBuilder {
  typedef Crop Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Crop::VT_AXIS, axis, 2);
  }
  void add_offset(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> offset) {
    fbb_.AddOffset(Crop::VT_OFFSET, offset);
  }
  explicit CropBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Crop> CreateCrop(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 2,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> offset = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Crop> CreateCropDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 2,
    const std::vector<int32_t> *offset = nullptr) {
  auto offset__ = offset ? _fbb.CreateVector<int32_t>(*offset) : 0;
  return MNN::CreateCrop(
      _fbb,
      axis,
      offset__);
}

struct SpaceBatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpaceBatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDING = 6
  };
  const MNN::Blob *blockShape() const {
    return GetPointer<const MNN::Blob *>(VT_BLOCKSHAPE);
  }
  const MNN::Blob *padding() const {
    return GetPointer<const MNN::Blob *>(VT_PADDING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyTable(blockShape()) &&
           VerifyOffset(verifier, VT_PADDING) &&
           verifier.VerifyTable(padding()) &&
           verifier.EndTable();
  }
};

struct SpaceBatchBuilder {
  typedef SpaceBatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blockShape(::flatbuffers::Offset<MNN::Blob> blockShape) {
    fbb_.AddOffset(SpaceBatch::VT_BLOCKSHAPE, blockShape);
  }
  void add_padding(::flatbuffers::Offset<MNN::Blob> padding) {
    fbb_.AddOffset(SpaceBatch::VT_PADDING, padding);
  }
  explicit SpaceBatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpaceBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpaceBatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpaceBatch> CreateSpaceBatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<MNN::Blob> blockShape = 0,
    ::flatbuffers::Offset<MNN::Blob> padding = 0) {
  SpaceBatchBuilder builder_(_fbb);
  builder_.add_padding(padding);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

struct MatMul FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MatMulBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_T = 4,
    VT_TRANSPOSEA = 6,
    VT_TRANSPOSEB = 8,
    VT_WEIGHT = 10,
    VT_BIAS = 12
  };
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 0));
  }
  bool transposeA() const {
    return GetField<uint8_t>(VT_TRANSPOSEA, 0) != 0;
  }
  bool transposeB() const {
    return GetField<uint8_t>(VT_TRANSPOSEB, 0) != 0;
  }
  const ::flatbuffers::Vector<float> *weight() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_WEIGHT);
  }
  const ::flatbuffers::Vector<float> *bias() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BIAS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEA, 1) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEB, 1) &&
           VerifyOffset(verifier, VT_WEIGHT) &&
           verifier.VerifyVector(weight()) &&
           VerifyOffset(verifier, VT_BIAS) &&
           verifier.VerifyVector(bias()) &&
           verifier.EndTable();
  }
};

struct MatMulBuilder {
  typedef MatMul Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(MatMul::VT_T, static_cast<int32_t>(T), 0);
  }
  void add_transposeA(bool transposeA) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEA, static_cast<uint8_t>(transposeA), 0);
  }
  void add_transposeB(bool transposeB) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEB, static_cast<uint8_t>(transposeB), 0);
  }
  void add_weight(::flatbuffers::Offset<::flatbuffers::Vector<float>> weight) {
    fbb_.AddOffset(MatMul::VT_WEIGHT, weight);
  }
  void add_bias(::flatbuffers::Offset<::flatbuffers::Vector<float>> bias) {
    fbb_.AddOffset(MatMul::VT_BIAS, bias);
  }
  explicit MatMulBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MatMul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MatMul>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MatMul> CreateMatMul(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    bool transposeA = false,
    bool transposeB = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> weight = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> bias = 0) {
  MatMulBuilder builder_(_fbb);
  builder_.add_bias(bias);
  builder_.add_weight(weight);
  builder_.add_T(T);
  builder_.add_transposeB(transposeB);
  builder_.add_transposeA(transposeA);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MatMul> CreateMatMulDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType T = MNN::DataType_DT_INVALID,
    bool transposeA = false,
    bool transposeB = false,
    const std::vector<float> *weight = nullptr,
    const std::vector<float> *bias = nullptr) {
  auto weight__ = weight ? _fbb.CreateVector<float>(*weight) : 0;
  auto bias__ = bias ? _fbb.CreateVector<float>(*bias) : 0;
  return MNN::CreateMatMul(
      _fbb,
      T,
      transposeA,
      transposeB,
      weight__,
      bias__);
}

struct MomentsParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MomentsParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4,
    VT_KEEPDIMS = 6,
    VT_DTYPE = 8
  };
  const ::flatbuffers::Vector<int32_t> *dim() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_DIM);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 1) != 0;
  }
  MNN::DataType dType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIM) &&
           verifier.VerifyVector(dim()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS, 1) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           verifier.EndTable();
  }
};

struct MomentsParamBuilder {
  typedef MomentsParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dim(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dim) {
    fbb_.AddOffset(MomentsParam::VT_DIM, dim);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(MomentsParam::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 1);
  }
  void add_dType(MNN::DataType dType) {
    fbb_.AddElement<int32_t>(MomentsParam::VT_DTYPE, static_cast<int32_t>(dType), 1);
  }
  explicit MomentsParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MomentsParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MomentsParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MomentsParam> CreateMomentsParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> dim = 0,
    bool keepDims = true,
    MNN::DataType dType = MNN::DataType_DT_FLOAT) {
  MomentsParamBuilder builder_(_fbb);
  builder_.add_dType(dType);
  builder_.add_dim(dim);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MomentsParam> CreateMomentsParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dim = nullptr,
    bool keepDims = true,
    MNN::DataType dType = MNN::DataType_DT_FLOAT) {
  auto dim__ = dim ? _fbb.CreateVector<int32_t>(*dim) : 0;
  return MNN::CreateMomentsParam(
      _fbb,
      dim__,
      keepDims,
      dType);
}

struct RNNParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RNNParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMUNITS = 4,
    VT_ISBIDIRECTIONALRNN = 6,
    VT_LINEARBEFORERESET = 8,
    VT_KEEPALLOUTPUTS = 10,
    VT_FWGATEWEIGHT = 12,
    VT_FWGATEBIAS = 14,
    VT_FWCANDIDATEWEIGHT = 16,
    VT_FWCANDIDATEBIAS = 18,
    VT_FWRECURRENTBIAS = 20,
    VT_BWGATEWEIGHT = 22,
    VT_BWGATEBIAS = 24,
    VT_BWCANDIDATEWEIGHT = 26,
    VT_BWCANDIDATEBIAS = 28,
    VT_BWRECURRENTBIAS = 30
  };
  int32_t numUnits() const {
    return GetField<int32_t>(VT_NUMUNITS, 0);
  }
  bool isBidirectionalRNN() const {
    return GetField<uint8_t>(VT_ISBIDIRECTIONALRNN, 0) != 0;
  }
  bool linearBeforeReset() const {
    return GetField<uint8_t>(VT_LINEARBEFORERESET, 0) != 0;
  }
  bool keepAllOutputs() const {
    return GetField<uint8_t>(VT_KEEPALLOUTPUTS, 0) != 0;
  }
  const MNN::Blob *fwGateWeight() const {
    return GetPointer<const MNN::Blob *>(VT_FWGATEWEIGHT);
  }
  const MNN::Blob *fwGateBias() const {
    return GetPointer<const MNN::Blob *>(VT_FWGATEBIAS);
  }
  const MNN::Blob *fwCandidateWeight() const {
    return GetPointer<const MNN::Blob *>(VT_FWCANDIDATEWEIGHT);
  }
  const MNN::Blob *fwCandidateBias() const {
    return GetPointer<const MNN::Blob *>(VT_FWCANDIDATEBIAS);
  }
  const MNN::Blob *fwRecurrentBias() const {
    return GetPointer<const MNN::Blob *>(VT_FWRECURRENTBIAS);
  }
  const MNN::Blob *bwGateWeight() const {
    return GetPointer<const MNN::Blob *>(VT_BWGATEWEIGHT);
  }
  const MNN::Blob *bwGateBias() const {
    return GetPointer<const MNN::Blob *>(VT_BWGATEBIAS);
  }
  const MNN::Blob *bwCandidateWeight() const {
    return GetPointer<const MNN::Blob *>(VT_BWCANDIDATEWEIGHT);
  }
  const MNN::Blob *bwCandidateBias() const {
    return GetPointer<const MNN::Blob *>(VT_BWCANDIDATEBIAS);
  }
  const MNN::Blob *bwRecurrentBias() const {
    return GetPointer<const MNN::Blob *>(VT_BWRECURRENTBIAS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMUNITS, 4) &&
           VerifyField<uint8_t>(verifier, VT_ISBIDIRECTIONALRNN, 1) &&
           VerifyField<uint8_t>(verifier, VT_LINEARBEFORERESET, 1) &&
           VerifyField<uint8_t>(verifier, VT_KEEPALLOUTPUTS, 1) &&
           VerifyOffset(verifier, VT_FWGATEWEIGHT) &&
           verifier.VerifyTable(fwGateWeight()) &&
           VerifyOffset(verifier, VT_FWGATEBIAS) &&
           verifier.VerifyTable(fwGateBias()) &&
           VerifyOffset(verifier, VT_FWCANDIDATEWEIGHT) &&
           verifier.VerifyTable(fwCandidateWeight()) &&
           VerifyOffset(verifier, VT_FWCANDIDATEBIAS) &&
           verifier.VerifyTable(fwCandidateBias()) &&
           VerifyOffset(verifier, VT_FWRECURRENTBIAS) &&
           verifier.VerifyTable(fwRecurrentBias()) &&
           VerifyOffset(verifier, VT_BWGATEWEIGHT) &&
           verifier.VerifyTable(bwGateWeight()) &&
           VerifyOffset(verifier, VT_BWGATEBIAS) &&
           verifier.VerifyTable(bwGateBias()) &&
           VerifyOffset(verifier, VT_BWCANDIDATEWEIGHT) &&
           verifier.VerifyTable(bwCandidateWeight()) &&
           VerifyOffset(verifier, VT_BWCANDIDATEBIAS) &&
           verifier.VerifyTable(bwCandidateBias()) &&
           VerifyOffset(verifier, VT_BWRECURRENTBIAS) &&
           verifier.VerifyTable(bwRecurrentBias()) &&
           verifier.EndTable();
  }
};

struct RNNParamBuilder {
  typedef RNNParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_numUnits(int32_t numUnits) {
    fbb_.AddElement<int32_t>(RNNParam::VT_NUMUNITS, numUnits, 0);
  }
  void add_isBidirectionalRNN(bool isBidirectionalRNN) {
    fbb_.AddElement<uint8_t>(RNNParam::VT_ISBIDIRECTIONALRNN, static_cast<uint8_t>(isBidirectionalRNN), 0);
  }
  void add_linearBeforeReset(bool linearBeforeReset) {
    fbb_.AddElement<uint8_t>(RNNParam::VT_LINEARBEFORERESET, static_cast<uint8_t>(linearBeforeReset), 0);
  }
  void add_keepAllOutputs(bool keepAllOutputs) {
    fbb_.AddElement<uint8_t>(RNNParam::VT_KEEPALLOUTPUTS, static_cast<uint8_t>(keepAllOutputs), 0);
  }
  void add_fwGateWeight(::flatbuffers::Offset<MNN::Blob> fwGateWeight) {
    fbb_.AddOffset(RNNParam::VT_FWGATEWEIGHT, fwGateWeight);
  }
  void add_fwGateBias(::flatbuffers::Offset<MNN::Blob> fwGateBias) {
    fbb_.AddOffset(RNNParam::VT_FWGATEBIAS, fwGateBias);
  }
  void add_fwCandidateWeight(::flatbuffers::Offset<MNN::Blob> fwCandidateWeight) {
    fbb_.AddOffset(RNNParam::VT_FWCANDIDATEWEIGHT, fwCandidateWeight);
  }
  void add_fwCandidateBias(::flatbuffers::Offset<MNN::Blob> fwCandidateBias) {
    fbb_.AddOffset(RNNParam::VT_FWCANDIDATEBIAS, fwCandidateBias);
  }
  void add_fwRecurrentBias(::flatbuffers::Offset<MNN::Blob> fwRecurrentBias) {
    fbb_.AddOffset(RNNParam::VT_FWRECURRENTBIAS, fwRecurrentBias);
  }
  void add_bwGateWeight(::flatbuffers::Offset<MNN::Blob> bwGateWeight) {
    fbb_.AddOffset(RNNParam::VT_BWGATEWEIGHT, bwGateWeight);
  }
  void add_bwGateBias(::flatbuffers::Offset<MNN::Blob> bwGateBias) {
    fbb_.AddOffset(RNNParam::VT_BWGATEBIAS, bwGateBias);
  }
  void add_bwCandidateWeight(::flatbuffers::Offset<MNN::Blob> bwCandidateWeight) {
    fbb_.AddOffset(RNNParam::VT_BWCANDIDATEWEIGHT, bwCandidateWeight);
  }
  void add_bwCandidateBias(::flatbuffers::Offset<MNN::Blob> bwCandidateBias) {
    fbb_.AddOffset(RNNParam::VT_BWCANDIDATEBIAS, bwCandidateBias);
  }
  void add_bwRecurrentBias(::flatbuffers::Offset<MNN::Blob> bwRecurrentBias) {
    fbb_.AddOffset(RNNParam::VT_BWRECURRENTBIAS, bwRecurrentBias);
  }
  explicit RNNParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RNNParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RNNParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RNNParam> CreateRNNParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numUnits = 0,
    bool isBidirectionalRNN = false,
    bool linearBeforeReset = false,
    bool keepAllOutputs = false,
    ::flatbuffers::Offset<MNN::Blob> fwGateWeight = 0,
    ::flatbuffers::Offset<MNN::Blob> fwGateBias = 0,
    ::flatbuffers::Offset<MNN::Blob> fwCandidateWeight = 0,
    ::flatbuffers::Offset<MNN::Blob> fwCandidateBias = 0,
    ::flatbuffers::Offset<MNN::Blob> fwRecurrentBias = 0,
    ::flatbuffers::Offset<MNN::Blob> bwGateWeight = 0,
    ::flatbuffers::Offset<MNN::Blob> bwGateBias = 0,
    ::flatbuffers::Offset<MNN::Blob> bwCandidateWeight = 0,
    ::flatbuffers::Offset<MNN::Blob> bwCandidateBias = 0,
    ::flatbuffers::Offset<MNN::Blob> bwRecurrentBias = 0) {
  RNNParamBuilder builder_(_fbb);
  builder_.add_bwRecurrentBias(bwRecurrentBias);
  builder_.add_bwCandidateBias(bwCandidateBias);
  builder_.add_bwCandidateWeight(bwCandidateWeight);
  builder_.add_bwGateBias(bwGateBias);
  builder_.add_bwGateWeight(bwGateWeight);
  builder_.add_fwRecurrentBias(fwRecurrentBias);
  builder_.add_fwCandidateBias(fwCandidateBias);
  builder_.add_fwCandidateWeight(fwCandidateWeight);
  builder_.add_fwGateBias(fwGateBias);
  builder_.add_fwGateWeight(fwGateWeight);
  builder_.add_numUnits(numUnits);
  builder_.add_keepAllOutputs(keepAllOutputs);
  builder_.add_linearBeforeReset(linearBeforeReset);
  builder_.add_isBidirectionalRNN(isBidirectionalRNN);
  return builder_.Finish();
}

struct BatchMatMulParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BatchMatMulParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADJX = 4,
    VT_ADJY = 6
  };
  bool adjX() const {
    return GetField<uint8_t>(VT_ADJX, 0) != 0;
  }
  bool adjY() const {
    return GetField<uint8_t>(VT_ADJY, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ADJX, 1) &&
           VerifyField<uint8_t>(verifier, VT_ADJY, 1) &&
           verifier.EndTable();
  }
};

struct BatchMatMulParamBuilder {
  typedef BatchMatMulParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_adjX(bool adjX) {
    fbb_.AddElement<uint8_t>(BatchMatMulParam::VT_ADJX, static_cast<uint8_t>(adjX), 0);
  }
  void add_adjY(bool adjY) {
    fbb_.AddElement<uint8_t>(BatchMatMulParam::VT_ADJY, static_cast<uint8_t>(adjY), 0);
  }
  explicit BatchMatMulParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BatchMatMulParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BatchMatMulParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<BatchMatMulParam> CreateBatchMatMulParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool adjX = false,
    bool adjY = false) {
  BatchMatMulParamBuilder builder_(_fbb);
  builder_.add_adjY(adjY);
  builder_.add_adjX(adjX);
  return builder_.Finish();
}

struct DepthSpaceParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DepthSpaceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_MODE = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  MNN::DepthToSpaceMode mode() const {
    return static_cast<MNN::DepthToSpaceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE, 4) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
};

struct DepthSpaceParamBuilder {
  typedef DepthSpaceParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(DepthSpaceParam::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_mode(MNN::DepthToSpaceMode mode) {
    fbb_.AddElement<int8_t>(DepthSpaceParam::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit DepthSpaceParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DepthSpaceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DepthSpaceParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DepthSpaceParam> CreateDepthSpaceParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    MNN::DepthToSpaceMode mode = MNN::DepthToSpaceMode_DCR) {
  DepthSpaceParamBuilder builder_(_fbb);
  builder_.add_blockSize(blockSize);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct ReverseSequenceParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReverseSequenceParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATCHDIM = 4,
    VT_SEQDIM = 6
  };
  int32_t batchDim() const {
    return GetField<int32_t>(VT_BATCHDIM, 0);
  }
  int32_t seqDim() const {
    return GetField<int32_t>(VT_SEQDIM, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIM, 4) &&
           VerifyField<int32_t>(verifier, VT_SEQDIM, 4) &&
           verifier.EndTable();
  }
};

struct ReverseSequenceParamBuilder {
  typedef ReverseSequenceParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_batchDim(int32_t batchDim) {
    fbb_.AddElement<int32_t>(ReverseSequenceParam::VT_BATCHDIM, batchDim, 0);
  }
  void add_seqDim(int32_t seqDim) {
    fbb_.AddElement<int32_t>(ReverseSequenceParam::VT_SEQDIM, seqDim, 0);
  }
  explicit ReverseSequenceParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReverseSequenceParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReverseSequenceParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReverseSequenceParam> CreateReverseSequenceParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batchDim = 0,
    int32_t seqDim = 0) {
  ReverseSequenceParamBuilder builder_(_fbb);
  builder_.add_seqDim(seqDim);
  builder_.add_batchDim(batchDim);
  return builder_.Finish();
}

struct DetectionPostProcessParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DetectionPostProcessParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXDETECTIONS = 4,
    VT_MAXCLASSESPERDETECTION = 6,
    VT_DETECTIONSPERCLASS = 8,
    VT_NMSSCORETHRESHOLD = 10,
    VT_IOUTHRESHOLD = 12,
    VT_NUMCLASSES = 14,
    VT_USEREGULARNMS = 16,
    VT_CENTERSIZEENCODING = 18
  };
  int32_t maxDetections() const {
    return GetField<int32_t>(VT_MAXDETECTIONS, 0);
  }
  int32_t maxClassesPerDetection() const {
    return GetField<int32_t>(VT_MAXCLASSESPERDETECTION, 0);
  }
  int32_t detectionsPerClass() const {
    return GetField<int32_t>(VT_DETECTIONSPERCLASS, 0);
  }
  float nmsScoreThreshold() const {
    return GetField<float>(VT_NMSSCORETHRESHOLD, 0.0f);
  }
  float iouThreshold() const {
    return GetField<float>(VT_IOUTHRESHOLD, 0.0f);
  }
  int32_t numClasses() const {
    return GetField<int32_t>(VT_NUMCLASSES, 0);
  }
  bool useRegularNMS() const {
    return GetField<uint8_t>(VT_USEREGULARNMS, 0) != 0;
  }
  const ::flatbuffers::Vector<float> *centerSizeEncoding() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_CENTERSIZEENCODING);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MAXDETECTIONS, 4) &&
           VerifyField<int32_t>(verifier, VT_MAXCLASSESPERDETECTION, 4) &&
           VerifyField<int32_t>(verifier, VT_DETECTIONSPERCLASS, 4) &&
           VerifyField<float>(verifier, VT_NMSSCORETHRESHOLD, 4) &&
           VerifyField<float>(verifier, VT_IOUTHRESHOLD, 4) &&
           VerifyField<int32_t>(verifier, VT_NUMCLASSES, 4) &&
           VerifyField<uint8_t>(verifier, VT_USEREGULARNMS, 1) &&
           VerifyOffset(verifier, VT_CENTERSIZEENCODING) &&
           verifier.VerifyVector(centerSizeEncoding()) &&
           verifier.EndTable();
  }
};

struct DetectionPostProcessParamBuilder {
  typedef DetectionPostProcessParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_maxDetections(int32_t maxDetections) {
    fbb_.AddElement<int32_t>(DetectionPostProcessParam::VT_MAXDETECTIONS, maxDetections, 0);
  }
  void add_maxClassesPerDetection(int32_t maxClassesPerDetection) {
    fbb_.AddElement<int32_t>(DetectionPostProcessParam::VT_MAXCLASSESPERDETECTION, maxClassesPerDetection, 0);
  }
  void add_detectionsPerClass(int32_t detectionsPerClass) {
    fbb_.AddElement<int32_t>(DetectionPostProcessParam::VT_DETECTIONSPERCLASS, detectionsPerClass, 0);
  }
  void add_nmsScoreThreshold(float nmsScoreThreshold) {
    fbb_.AddElement<float>(DetectionPostProcessParam::VT_NMSSCORETHRESHOLD, nmsScoreThreshold, 0.0f);
  }
  void add_iouThreshold(float iouThreshold) {
    fbb_.AddElement<float>(DetectionPostProcessParam::VT_IOUTHRESHOLD, iouThreshold, 0.0f);
  }
  void add_numClasses(int32_t numClasses) {
    fbb_.AddElement<int32_t>(DetectionPostProcessParam::VT_NUMCLASSES, numClasses, 0);
  }
  void add_useRegularNMS(bool useRegularNMS) {
    fbb_.AddElement<uint8_t>(DetectionPostProcessParam::VT_USEREGULARNMS, static_cast<uint8_t>(useRegularNMS), 0);
  }
  void add_centerSizeEncoding(::flatbuffers::Offset<::flatbuffers::Vector<float>> centerSizeEncoding) {
    fbb_.AddOffset(DetectionPostProcessParam::VT_CENTERSIZEENCODING, centerSizeEncoding);
  }
  explicit DetectionPostProcessParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DetectionPostProcessParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DetectionPostProcessParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DetectionPostProcessParam> CreateDetectionPostProcessParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t maxDetections = 0,
    int32_t maxClassesPerDetection = 0,
    int32_t detectionsPerClass = 0,
    float nmsScoreThreshold = 0.0f,
    float iouThreshold = 0.0f,
    int32_t numClasses = 0,
    bool useRegularNMS = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> centerSizeEncoding = 0) {
  DetectionPostProcessParamBuilder builder_(_fbb);
  builder_.add_centerSizeEncoding(centerSizeEncoding);
  builder_.add_numClasses(numClasses);
  builder_.add_iouThreshold(iouThreshold);
  builder_.add_nmsScoreThreshold(nmsScoreThreshold);
  builder_.add_detectionsPerClass(detectionsPerClass);
  builder_.add_maxClassesPerDetection(maxClassesPerDetection);
  builder_.add_maxDetections(maxDetections);
  builder_.add_useRegularNMS(useRegularNMS);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DetectionPostProcessParam> CreateDetectionPostProcessParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t maxDetections = 0,
    int32_t maxClassesPerDetection = 0,
    int32_t detectionsPerClass = 0,
    float nmsScoreThreshold = 0.0f,
    float iouThreshold = 0.0f,
    int32_t numClasses = 0,
    bool useRegularNMS = false,
    const std::vector<float> *centerSizeEncoding = nullptr) {
  auto centerSizeEncoding__ = centerSizeEncoding ? _fbb.CreateVector<float>(*centerSizeEncoding) : 0;
  return MNN::CreateDetectionPostProcessParam(
      _fbb,
      maxDetections,
      maxClassesPerDetection,
      detectionsPerClass,
      nmsScoreThreshold,
      iouThreshold,
      numClasses,
      useRegularNMS,
      centerSizeEncoding__);
}

struct OneHotParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OneHotParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_AXIS = 6
  };
  MNN::DataType dType() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_DTYPE, 1));
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, -1);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DTYPE, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           verifier.EndTable();
  }
};

struct OneHotParamBuilder {
  typedef OneHotParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dType(MNN::DataType dType) {
    fbb_.AddElement<int32_t>(OneHotParam::VT_DTYPE, static_cast<int32_t>(dType), 1);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotParam::VT_AXIS, axis, -1);
  }
  explicit OneHotParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<OneHotParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<OneHotParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<OneHotParam> CreateOneHotParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::DataType dType = MNN::DataType_DT_FLOAT,
    int32_t axis = -1) {
  OneHotParamBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_dType(dType);
  return builder_.Finish();
}

struct PadParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PadParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  MNN::PadValueMode mode() const {
    return static_cast<MNN::PadValueMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE, 1) &&
           verifier.EndTable();
  }
};

struct PadParamBuilder {
  typedef PadParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mode(MNN::PadValueMode mode) {
    fbb_.AddElement<int8_t>(PadParam::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit PadParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PadParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PadParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PadParam> CreatePadParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    MNN::PadValueMode mode = MNN::PadValueMode_CONSTANT) {
  PadParamBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct LayerNorm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LayerNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_GAMMA = 8,
    VT_BETA = 10,
    VT_GROUP = 12,
    VT_EXTERNAL = 14,
    VT_USERMSNORM = 16
  };
  const ::flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  const ::flatbuffers::Vector<float> *gamma() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_GAMMA);
  }
  const ::flatbuffers::Vector<float> *beta() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BETA);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  const ::flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool useRMSNorm() const {
    return GetField<uint8_t>(VT_USERMSNORM, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyVector(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyVector(beta()) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           VerifyField<uint8_t>(verifier, VT_USERMSNORM, 1) &&
           verifier.EndTable();
  }
};

struct LayerNormBuilder {
  typedef LayerNorm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(LayerNorm::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(LayerNorm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_gamma(::flatbuffers::Offset<::flatbuffers::Vector<float>> gamma) {
    fbb_.AddOffset(LayerNorm::VT_GAMMA, gamma);
  }
  void add_beta(::flatbuffers::Offset<::flatbuffers::Vector<float>> beta) {
    fbb_.AddOffset(LayerNorm::VT_BETA, beta);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(LayerNorm::VT_GROUP, group, 1);
  }
  void add_external(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(LayerNorm::VT_EXTERNAL, external);
  }
  void add_useRMSNorm(bool useRMSNorm) {
    fbb_.AddElement<uint8_t>(LayerNorm::VT_USERMSNORM, static_cast<uint8_t>(useRMSNorm), 0);
  }
  explicit LayerNormBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LayerNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LayerNorm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LayerNorm> CreateLayerNorm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> axis = 0,
    float epsilon = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> gamma = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> beta = 0,
    int32_t group = 1,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external = 0,
    bool useRMSNorm = false) {
  LayerNormBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_group(group);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  builder_.add_useRMSNorm(useRMSNorm);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LayerNorm> CreateLayerNormDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    float epsilon = 0.0f,
    const std::vector<float> *gamma = nullptr,
    const std::vector<float> *beta = nullptr,
    int32_t group = 1,
    const std::vector<int64_t> *external = nullptr,
    bool useRMSNorm = false) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  auto gamma__ = gamma ? _fbb.CreateVector<float>(*gamma) : 0;
  auto beta__ = beta ? _fbb.CreateVector<float>(*beta) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return MNN::CreateLayerNorm(
      _fbb,
      axis__,
      epsilon,
      gamma__,
      beta__,
      group,
      external__,
      useRMSNorm);
}

struct GroupNorm FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GroupNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_GAMMA = 8,
    VT_BETA = 10,
    VT_GROUP = 12,
    VT_BSWISH = 14,
    VT_EXTERNAL = 16
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  const ::flatbuffers::Vector<float> *gamma() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_GAMMA);
  }
  const ::flatbuffers::Vector<float> *beta() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_BETA);
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 1);
  }
  int32_t bSwish() const {
    return GetField<int32_t>(VT_BSWISH, 0);
  }
  const ::flatbuffers::Vector<int64_t> *external() const {
    return GetPointer<const ::flatbuffers::Vector<int64_t> *>(VT_EXTERNAL);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<float>(verifier, VT_EPSILON, 4) &&
           VerifyOffset(verifier, VT_GAMMA) &&
           verifier.VerifyVector(gamma()) &&
           VerifyOffset(verifier, VT_BETA) &&
           verifier.VerifyVector(beta()) &&
           VerifyField<int32_t>(verifier, VT_GROUP, 4) &&
           VerifyField<int32_t>(verifier, VT_BSWISH, 4) &&
           VerifyOffset(verifier, VT_EXTERNAL) &&
           verifier.VerifyVector(external()) &&
           verifier.EndTable();
  }
};

struct GroupNormBuilder {
  typedef GroupNorm Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GroupNorm::VT_AXIS, axis, 0);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(GroupNorm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_gamma(::flatbuffers::Offset<::flatbuffers::Vector<float>> gamma) {
    fbb_.AddOffset(GroupNorm::VT_GAMMA, gamma);
  }
  void add_beta(::flatbuffers::Offset<::flatbuffers::Vector<float>> beta) {
    fbb_.AddOffset(GroupNorm::VT_BETA, beta);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(GroupNorm::VT_GROUP, group, 1);
  }
  void add_bSwish(int32_t bSwish) {
    fbb_.AddElement<int32_t>(GroupNorm::VT_BSWISH, bSwish, 0);
  }
  void add_external(::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external) {
    fbb_.AddOffset(GroupNorm::VT_EXTERNAL, external);
  }
  explicit GroupNormBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GroupNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GroupNorm>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GroupNorm> CreateGroupNorm(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    float epsilon = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> gamma = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> beta = 0,
    int32_t group = 1,
    int32_t bSwish = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int64_t>> external = 0) {
  GroupNormBuilder builder_(_fbb);
  builder_.add_external(external);
  builder_.add_bSwish(bSwish);
  builder_.add_group(group);
  builder_.add_beta(beta);
  builder_.add_gamma(gamma);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<GroupNorm> CreateGroupNormDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    float epsilon = 0.0f,
    const std::vector<float> *gamma = nullptr,
    const std::vector<float> *beta = nullptr,
    int32_t group = 1,
    int32_t bSwish = 0,
    const std::vector<int64_t> *external = nullptr) {
  auto gamma__ = gamma ? _fbb.CreateVector<float>(*gamma) : 0;
  auto beta__ = beta ? _fbb.CreateVector<float>(*beta) : 0;
  auto external__ = external ? _fbb.CreateVector<int64_t>(*external) : 0;
  return MNN::CreateGroupNorm(
      _fbb,
      axis,
      epsilon,
      gamma__,
      beta__,
      group,
      bSwish,
      external__);
}

struct RandomUniform FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RandomUniformBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6,
    VT_TYPE = 8,
    VT_LOW = 10,
    VT_HIGH = 12
  };
  int32_t seed() const {
    return GetField<int32_t>(VT_SEED, 0);
  }
  int32_t seed2() const {
    return GetField<int32_t>(VT_SEED2, 0);
  }
  MNN::DataType type() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_TYPE, 1));
  }
  float low() const {
    return GetField<float>(VT_LOW, 0.0f);
  }
  float high() const {
    return GetField<float>(VT_HIGH, 1.0f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEED, 4) &&
           VerifyField<int32_t>(verifier, VT_SEED2, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           VerifyField<float>(verifier, VT_LOW, 4) &&
           VerifyField<float>(verifier, VT_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct RandomUniformBuilder {
  typedef RandomUniform Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_seed(int32_t seed) {
    fbb_.AddElement<int32_t>(RandomUniform::VT_SEED, seed, 0);
  }
  void add_seed2(int32_t seed2) {
    fbb_.AddElement<int32_t>(RandomUniform::VT_SEED2, seed2, 0);
  }
  void add_type(MNN::DataType type) {
    fbb_.AddElement<int32_t>(RandomUniform::VT_TYPE, static_cast<int32_t>(type), 1);
  }
  void add_low(float low) {
    fbb_.AddElement<float>(RandomUniform::VT_LOW, low, 0.0f);
  }
  void add_high(float high) {
    fbb_.AddElement<float>(RandomUniform::VT_HIGH, high, 1.0f);
  }
  explicit RandomUniformBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RandomUniform> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RandomUniform>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RandomUniform> CreateRandomUniform(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seed = 0,
    int32_t seed2 = 0,
    MNN::DataType type = MNN::DataType_DT_FLOAT,
    float low = 0.0f,
    float high = 1.0f) {
  RandomUniformBuilder builder_(_fbb);
  builder_.add_high(high);
  builder_.add_low(low);
  builder_.add_type(type);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

struct TensorArray FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DYNAMIC_SIZE = 4,
    VT_IDENTICAL_ELEMENT_SHAPES = 6,
    VT_ELEMENT_SHAPE = 8,
    VT_T = 10,
    VT_AXIS = 12,
    VT_KEEPDIMS = 14,
    VT_NEW_AXIS = 16
  };
  bool dynamic_size() const {
    return GetField<uint8_t>(VT_DYNAMIC_SIZE, 0) != 0;
  }
  bool identical_element_shapes() const {
    return GetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, 0) != 0;
  }
  const ::flatbuffers::Vector<int32_t> *element_shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
  }
  MNN::DataType T() const {
    return static_cast<MNN::DataType>(GetField<int32_t>(VT_T, 1));
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool keepdims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 1) != 0;
  }
  bool new_axis() const {
    return GetField<uint8_t>(VT_NEW_AXIS, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC_SIZE, 1) &&
           VerifyField<uint8_t>(verifier, VT_IDENTICAL_ELEMENT_SHAPES, 1) &&
           VerifyOffset(verifier, VT_ELEMENT_SHAPE) &&
           verifier.VerifyVector(element_shape()) &&
           VerifyField<int32_t>(verifier, VT_T, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS, 1) &&
           VerifyField<uint8_t>(verifier, VT_NEW_AXIS, 1) &&
           verifier.EndTable();
  }
};

struct TensorArrayBuilder {
  typedef TensorArray Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_dynamic_size(bool dynamic_size) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_DYNAMIC_SIZE, static_cast<uint8_t>(dynamic_size), 0);
  }
  void add_identical_element_shapes(bool identical_element_shapes) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(identical_element_shapes), 0);
  }
  void add_element_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> element_shape) {
    fbb_.AddOffset(TensorArray::VT_ELEMENT_SHAPE, element_shape);
  }
  void add_T(MNN::DataType T) {
    fbb_.AddElement<int32_t>(TensorArray::VT_T, static_cast<int32_t>(T), 1);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(TensorArray::VT_AXIS, axis, 0);
  }
  void add_keepdims(bool keepdims) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_KEEPDIMS, static_cast<uint8_t>(keepdims), 1);
  }
  void add_new_axis(bool new_axis) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_NEW_AXIS, static_cast<uint8_t>(new_axis), 0);
  }
  explicit TensorArrayBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TensorArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TensorArray>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TensorArray> CreateTensorArray(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> element_shape = 0,
    MNN::DataType T = MNN::DataType_DT_FLOAT,
    int32_t axis = 0,
    bool keepdims = true,
    bool new_axis = false) {
  TensorArrayBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_T(T);
  builder_.add_element_shape(element_shape);
  builder_.add_new_axis(new_axis);
  builder_.add_keepdims(keepdims);
  builder_.add_identical_element_shapes(identical_element_shapes);
  builder_.add_dynamic_size(dynamic_size);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TensorArray> CreateTensorArrayDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    const std::vector<int32_t> *element_shape = nullptr,
    MNN::DataType T = MNN::DataType_DT_FLOAT,
    int32_t axis = 0,
    bool keepdims = true,
    bool new_axis = false) {
  auto element_shape__ = element_shape ? _fbb.CreateVector<int32_t>(*element_shape) : 0;
  return MNN::CreateTensorArray(
      _fbb,
      dynamic_size,
      identical_element_shapes,
      element_shape__,
      T,
      axis,
      keepdims,
      new_axis);
}

struct LSTMBlockCell FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LSTMBlockCellBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CELL_CLIP = 4,
    VT_FORGET_BIAS = 6,
    VT_USE_PEEPHOLE = 8
  };
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 3.0f);
  }
  float forget_bias() const {
    return GetField<float>(VT_FORGET_BIAS, 1.0f);
  }
  bool use_peephole() const {
    return GetField<uint8_t>(VT_USE_PEEPHOLE, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CELL_CLIP, 4) &&
           VerifyField<float>(verifier, VT_FORGET_BIAS, 4) &&
           VerifyField<uint8_t>(verifier, VT_USE_PEEPHOLE, 1) &&
           verifier.EndTable();
  }
};

struct LSTMBlockCellBuilder {
  typedef LSTMBlockCell Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMBlockCell::VT_CELL_CLIP, cell_clip, 3.0f);
  }
  void add_forget_bias(float forget_bias) {
    fbb_.AddElement<float>(LSTMBlockCell::VT_FORGET_BIAS, forget_bias, 1.0f);
  }
  void add_use_peephole(bool use_peephole) {
    fbb_.AddElement<uint8_t>(LSTMBlockCell::VT_USE_PEEPHOLE, static_cast<uint8_t>(use_peephole), 0);
  }
  explicit LSTMBlockCellBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LSTMBlockCell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LSTMBlockCell>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LSTMBlockCell> CreateLSTMBlockCell(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float cell_clip = 3.0f,
    float forget_bias = 1.0f,
    bool use_peephole = false) {
  LSTMBlockCellBuilder builder_(_fbb);
  builder_.add_forget_bias(forget_bias);
  builder_.add_cell_clip(cell_clip);
  builder_.add_use_peephole(use_peephole);
  return builder_.Finish();
}

}  // namespace MNN

#endif  // FLATBUFFERS_GENERATED_TENSORFLOWOP_MNN_H_
